<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>HDU 1166 敌兵布阵——线段树，树状数组 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这题本来我打算用前缀数组实现源数据的处理，并把更变用map实现，发现后来还是超时了； 借机学习了一下线段树，虽然没怎么看懂，但大概还是理解了一点；这题用 指针构成的线段树 和 数组构成的线段树 分别来实现了一下资料：线段树从零开始 - CSDN博客http://blog.csdn.net/zearot/article/details/52280189线段树详解 （原理，实现与应用） - CSDN博">
<meta property="og:type" content="article">
<meta property="og:title" content="HDU 1166 敌兵布阵——线段树，树状数组">
<meta property="og:url" content="http://yoursite.com/2018/02/06/hdu-1166-e6-95-8c-e5-85-b5-e5-b8-83-e9-98-b5-e7-ba-bf-e6-ae-b5-e6-a0-91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="这题本来我打算用前缀数组实现源数据的处理，并把更变用map实现，发现后来还是超时了； 借机学习了一下线段树，虽然没怎么看懂，但大概还是理解了一点；这题用 指针构成的线段树 和 数组构成的线段树 分别来实现了一下资料：线段树从零开始 - CSDN博客http://blog.csdn.net/zearot/article/details/52280189线段树详解 （原理，实现与应用） - CSDN博">
<meta property="og:updated_time" content="2018-03-02T10:34:14.515Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HDU 1166 敌兵布阵——线段树，树状数组">
<meta name="twitter:description" content="这题本来我打算用前缀数组实现源数据的处理，并把更变用map实现，发现后来还是超时了； 借机学习了一下线段树，虽然没怎么看懂，但大概还是理解了一点；这题用 指针构成的线段树 和 数组构成的线段树 分别来实现了一下资料：线段树从零开始 - CSDN博客http://blog.csdn.net/zearot/article/details/52280189线段树详解 （原理，实现与应用） - CSDN博">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-hdu-1166-e6-95-8c-e5-85-b5-e5-b8-83-e9-98-b5-e7-ba-bf-e6-ae-b5-e6-a0-91" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/06/hdu-1166-e6-95-8c-e5-85-b5-e5-b8-83-e9-98-b5-e7-ba-bf-e6-ae-b5-e6-a0-91/" class="article-date">
  <time datetime="2018-02-06T09:33:38.000Z" itemprop="datePublished">2018-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HDU 1166 敌兵布阵——线段树，树状数组
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这题本来我打算用前缀数组实现源数据的处理，并把更变用map<int ,int="">实现，发现后来还是超时了；</int></p>
<p>借机学习了一下线段树，虽然没怎么看懂，但大概还是理解了一点；<br>这题用 指针构成的线段树 和 数组构成的线段树 分别来实现了一下<br>资料：<br>线段树从零开始 - CSDN博客<br><a href="http://blog.csdn.net/zearot/article/details/52280189" target="_blank" rel="noopener">http://blog.csdn.net/zearot/article/details/52280189</a><br>线段树详解 （原理，实现与应用） - CSDN博客<br><a href="http://blog.csdn.net/zearot/article/details/48299459" target="_blank" rel="noopener">http://blog.csdn.net/zearot/article/details/48299459</a></p>
<p>看到有人用树状数组实现，学习了一下树状数组，代码贴在最后：<br>资料：<br>树状数组入门<br><a href="https://www.cnblogs.com/hsd-/p/6139376.html" target="_blank" rel="noopener">https://www.cnblogs.com/hsd-/p/6139376.html</a></p>
<p>题目来源：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1166" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1166</a></p>
<pre>
敌兵布阵
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 106625    Accepted Submission(s): 44789

Problem Description
C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。
中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:"你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说："我知错了。。。"但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.

Input
第一行一个整数T，表示有T组数据。
每组数据第一行一个正整数N（N<=50000）,表示敌人有n个工兵营地，接下来有n个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1<=ai<=50）。 1="" 2="" 3="" 4="" 5="" 6="" 7="" 8="" 9="" 10="" 33="" 59="" 1394="" 1540="" 1542="" 1698="" 1754="" 接下来每行有一条命令，命令有4种形式：="" (1)="" add="" i="" j,i和j为正整数,表示第i个营地增加j个人（j不超过30）="" (2)sub="" j="" ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;="" (3)query="" ,i和j为正整数,i<="j，表示询问第i到第j个营地的总人数;" (4)end="" 表示结束，这条命令在每组数据最后出现;="" 每组数据最多有40000条命令="" output="" 对第i组数据,首先输出“case="" i:”和回车,="" 对于每个query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。="" sample="" input="" query="" sub="" end="" case="" 1:="" author="" windbreaker="" recommend="" eddy="" |="" we="" have="" carefully="" selected several="" similar="" problems="" for="" you:="" <="" pre="">

<p>指针线段树：<br>`</p>
<p>#include <iostream></iostream></p>
<p>#include <cstdio></cstdio></p>
<p>#include <cstring></cstring></p>
<p>using namespace std;</p>
<p>// 线段树</p>
<p>struct Node {<br>    int lp;<br>    int rp;<br>    int mid;<br>    int sum;<br>    Node<em> left;<br>    Node</em> right;<br>    Node(int l, int r): lp(l), rp(r), mid((l + r) / 2), left(NULL), right(NULL) {}//new初始化的内存不一定自动填0<br>};</p>
<p>int list[50005];//从1开始</p>
<p>int T, N, a, b;</p>
<p>Node<em> buildTree(int l, int r) {<br>    Node</em> p = new Node(l, r);<br>    if (l == r) {<br>        p-&gt;sum = list[l];<br>        return p;<br>    }<br>    p-&gt;left = buildTree(l, p-&gt;mid);<br>    p-&gt;right = buildTree(p-&gt;mid + 1, r);</p>
<pre><code>p-&gt;sum = p-&gt;left-&gt;sum + p-&gt;right-&gt;sum;
return p;
</code></pre><p>}</p>
<p>void treeAdd(Node *which, int where, int what) {</p>
<pre><code>if (which-&gt;left != NULL &amp;&amp; which-&gt;right != NULL) {
    treeAdd((where &lt;= which-&gt;mid) ? which-&gt;left : which-&gt;right, where, what);
}
which-&gt;sum += what;
</code></pre><p>}</p>
<p>int calSum(Node * which, int from, int to) {</p>
<pre><code>if (from == which-&gt;lp &amp;&amp; to == which-&gt;rp) {
    return which-&gt;sum;
}

if (from &lt;= which-&gt;mid) {
    if (to &gt; which-&gt;mid) {//横跨
        return calSum(which-&gt;left, from, which-&gt;mid) + calSum(which-&gt;right, which-&gt;mid + 1, to);
    } else {//全在左边
        return calSum(which-&gt;left, from, to);
    }
} else {//全在右边
    return calSum(which-&gt;right, from, to);
}

return 0;
</code></pre><p>}</p>
<p>void del(Node * which) {<br>    if (which-&gt;left) {<br>        del(which-&gt;left);<br>    }<br>    if (which-&gt;right) {<br>        del(which-&gt;right);<br>    }</p>
<pre><code>delete which;
</code></pre><p>}</p>
<p>int main(int argc, char const *argv[])<br>{</p>
<pre><code>char cmd[10];
scanf(&quot;%d&quot;, &amp;T);

for (int t = 1; t &lt;= T; t++) {

    memset(list, 0, sizeof(list));

    scanf(&quot;%d&quot;, &amp;N);

    for (int i = 0; i &lt; N; i++) {
        scanf(&quot;%d&quot;, list + i);
    }

    Node* root = buildTree(0, N - 1);

    printf(&quot;Case %d:\n&quot;, t);
    while (1) {
        scanf(&quot;%s&quot;, cmd);
        if (&apos;E&apos; == cmd[0]) {
            break;
        }
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        switch (cmd[0]) {
        case &apos;Q&apos;:
            printf(&quot;%d\n&quot;, calSum(root, a - 1, b - 1));
            break;
        case &apos;A&apos;:
            list[a - 1] += b;
            treeAdd(root, a - 1, b);
            break;
        case &apos;S&apos;:
            list[a - 1] -= b;
            treeAdd(root, a - 1, -b);
            break;
        }
    }

    del(root);
    root = NULL;

}

return 0;
</code></pre><p>}<br><code>自定义结构体组成的数组实现线段树：</code></p>
<p>#include <iostream></iostream></p>
<p>#include <cstdio></cstdio></p>
<p>#include <cstring></cstring></p>
<p>using namespace std;</p>
<p>// 线段树</p>
<p>struct Node {<br>    int lp;<br>    int rp;<br>    int mid;<br>    int sum;<br>} nodes[50005 &lt;&lt; 2];//空间为原数组的四倍长，1储存根元素，对于第k个节点，K&lt;&lt;1表示左支，(k&lt;&lt;1)|1表示右支</p>
<p>int list[50005];//从0开始</p>
<p>int T, N, a, b;</p>
<p>int buildTree(int which, int l, int r) {</p>
<pre><code>nodes[which].lp = l;
nodes[which].rp = r;
nodes[which].mid = ((l + r) &gt;&gt; 1);

if (l == r) {
    nodes[which].sum = list[l];

} else {
    nodes[which].sum += buildTree(which &lt;&lt; 1, l, (l + r) &gt;&gt; 1);
    nodes[which].sum += buildTree((which &lt;&lt; 1) | 1, ((l + r) &gt;&gt; 1) + 1, r);
}

return nodes[which].sum;
</code></pre><p>}</p>
<p>void treeAdd(int which, int where, int what) {</p>
<pre><code>if (nodes[which].lp != nodes[which].rp) {
    treeAdd((where &lt;= nodes[which].mid) ? which &lt;&lt; 1 : (which &lt;&lt; 1) | 1, where, what);
}
nodes[which].sum += what;
</code></pre><p>}</p>
<p>int calSum(int which, int from, int to) {</p>
<pre><code>// printf(&quot;from_%d,to_%d,and_now_is_%d,%d\n&quot;, from, to, nodes[which].lp, nodes[which].rp);
if (from == nodes[which].lp &amp;&amp; to == nodes[which].rp) {
    return nodes[which].sum;
}

if (from &lt;= nodes[which].mid) {
    if (to &gt; nodes[which].mid) {//横跨
        return calSum(which &lt;&lt; 1, from, nodes[which].mid) + calSum((which &lt;&lt; 1) | 1, nodes[which].mid + 1, to);
    } else {//全在左边
        return calSum(which &lt;&lt; 1, from, to);
    }
} else {//全在右边
    return calSum((which &lt;&lt; 1) | 1, from, to);
}

return 0;
</code></pre><p>}</p>
<p>int main(int argc, char const *argv[])<br>{</p>
<pre><code>char cmd[10];
scanf(&quot;%d&quot;, &amp;T);

for (int t = 1; t &lt;= T; t++) {

    memset(list, 0, sizeof(list));
    memset(nodes, 0, sizeof(nodes));

    scanf(&quot;%d&quot;, &amp;N);

    for (int i = 0; i &lt; N; i++) {
        scanf(&quot;%d&quot;, list + i);
    }

    buildTree(1, 0, N - 1);

    printf(&quot;Case %d:\n&quot;, t);
    while (1) {
        scanf(&quot;%s&quot;, cmd);
        if (&apos;E&apos; == cmd[0]) {
            break;
        }
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        switch (cmd[0]) {
        case &apos;Q&apos;:
            printf(&quot;%d\n&quot;, calSum(1, a - 1, b - 1));
            break;
        case &apos;A&apos;:
            list[a - 1] += b;
            treeAdd(1, a - 1, b);
            break;
        case &apos;S&apos;:
            list[a - 1] -= b;
            treeAdd(1, a - 1, -b);
            break;
        }
    }

}

return 0;
</code></pre><p>}<br>`</p>
<p>树状数组实现：代码量超少！！！<br>`</p>
<p>#include <iostream></iostream></p>
<p>#include <cstdio></cstdio></p>
<p>#include <cstring></cstring></p>
<p>//Accept</p>
<p>#define lowbit(x) (x&amp;(-x))</p>
<p>//lowbit(x) 其实代表了第x号节点最底层代表的区间长度</p>
<p>using namespace std;</p>
<p>/**</p>
<ul>
<li>c[x]</li>
<li>1000</li>
<li>/————————————————————————————[8]</li>
<li>/                                 |</li>
<li>100                                 |</li>
<li>/————————————[4]                   /————————————[ ]</li>
<li>/                 |                  /                 |</li>
<li>010                 |                110                 |</li>
<li>/————[2]           /————[ ]           /————[6]           /————[ ]</li>
<li>/         |          /         |          /         |          /         |</li>
<li>001         |        011         |        101         |        111         |</li>
<li>[1]        [ ]        [3]        [ ]        [5]        [ ]        [7]        [ ]<br>*/<br>int c[50005];//树状数组,从1开始<br>// c[i] = data[i - 2 ^ k + 1 … i];</li>
</ul>
<p>int data[50005];//存储原始数据,从1开始</p>
<p>int s[50005];//前缀数组,在init时用到,从1开始</p>
<p>int T, N, a, b;</p>
<p>int calSum(int where) {//返回从data[1…where]<br>    int su = 0;<br>    while (where) {<br>        su += c[where];<br>        where -= lowbit(where);<br>    }<br>    return su;<br>}</p>
<p>void add(int where, int what) {<br>    while (where &lt;= N) {<br>        c[where] += what;<br>        where += lowbit(where);<br>    }<br>}</p>
<p>int init() {<br>    int sum = 0;<br>    // for (int i = 1; i &lt;= N; i++) {<br>    //     for (int x = i - lowbit(i) + 1; x &lt;= i; x++) {<br>    //         c[i] += data[x];<br>    //     }<br>    // }<br>    // 用前缀数组来进行优化：<br>    for (int i = 1; i &lt;= N; i++) {<br>        c[i] = s[i] - s[i - lowbit(i)];<br>    }</p>
<p>}</p>
<p>int main(int argc, char const *argv[])<br>{</p>
<pre><code>char cmd[10];
scanf(&quot;%d&quot;, &amp;T);

for (int t = 1; t &lt;= T; t++) {

    memset(c, 0, sizeof(c));
    memset(data, 0, sizeof(data));
    memset(s, 0, sizeof(s));

    scanf(&quot;%d&quot;, &amp;N);

    for (int i = 1; i &lt;= N; i++) {
        scanf(&quot;%d&quot;, data + i);
        s[i] = s[i - 1] + data[i];
    }

    init();

    printf(&quot;Case %d:\n&quot;, t);
    for (;;) {
        scanf(&quot;%s&quot;, cmd);
        if (&apos;E&apos; == cmd[0]) {
            break;
        }
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        switch (cmd[0]) {
        case &apos;Q&apos;:
            printf(&quot;%d\n&quot;, calSum(b) - calSum(a - 1));
            break;
        case &apos;A&apos;:
            add(a, b);
            break;
        case &apos;S&apos;:
            add(a, -b);
            break;
        }
    }
}

return 0;
</code></pre><p>}<br>`</p>
</=50000）,表示敌人有n个工兵营地，接下来有n个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1<=ai<=50）。></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/06/hdu-1166-e6-95-8c-e5-85-b5-e5-b8-83-e9-98-b5-e7-ba-bf-e6-ae-b5-e6-a0-91/" data-id="cje9syozt001o23w54p6pbgx5" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/02/06/e6-9c-80-e9-95-bf-e9-80-92-e5-a2-9e-e5-ad-90-e5-88-97-e7-9a-84-e5-8f-a6-e4-b8-80-e7-a7-8d-e6-80-9d-e8-b7-af-ef-bc-88-e8-bd-ac-e5-8c-96-e4-b8-balcs-e9-97-ae-e9-a2-98-ef-bc-89/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          最长递增子列的另一种思路（转化为LCS问题）
        
      </div>
    </a>
  
  
    <a href="/2018/02/02/e7-ae-97-e6-b3-95-e8-af-8d-e6-b1-87/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">算法词汇</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/Java/">Java</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/CodeForces/">CodeForces</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CodeForces/动态规划/">动态规划</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CodeForces/动态规划/算法/">算法</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/HDU/">HDU</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HDU/POJ/">POJ</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HDU/POJ/动态规划/">动态规划</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HDU/POJ/动态规划/算法/">算法</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/HDU/动态规划/">动态规划</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HDU/动态规划/未分类/">未分类</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xposed/">Xposed</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/raspberry-pi/">raspberry pi</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/闲时研究/">闲时研究</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/02/HelloWorld/">HelloWorld</a>
          </li>
        
          <li>
            <a href="/2018/03/02/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/03/02/hdu-2586-how-far-away-ef-bc-9f-e6-a0-91-e4-b8-8a-e8-8a-82-e7-82-b9-e6-9c-80-e7-9f-ad-e8-b7-9d-e7-a6-bb-ef-bc-8clca-ef-bc-8c-e5-8f-8c-e4-ba-b2-e8-a1-a8-e7-a4-ba-e6-b3-95-e6-9a-b4/">HDU 2586 How far away ？——树上节点最短距离，LCA， 双亲表示法+暴力从下至上追溯，孩子链表示法+（Tarjan 或 欧拉环游RMQ+（ST 或 SegmentTree））</a>
          </li>
        
          <li>
            <a href="/2018/02/27/codeforces-891-a-pride/">CodeForces 891 A. Pride</a>
          </li>
        
          <li>
            <a href="/2018/02/26/hdu-1080-poj-1080-human-gene-functions-e5-8a-a8-e6-80-81-e8-a7-84-e5-88-92/">HDU 1080 POJ 1080 Human Gene Functions——动态规划</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>