<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++拷贝函数</title>
    <url>/blog/1/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*	拷贝构造函数,编译器默认提供</span><br><span class="line">*	触发情形：</span><br><span class="line">*	Teacher tear2(tear1);</span><br><span class="line">*	或者：</span><br><span class="line">*	Teacher tear3 = tear1;//多发生于作为函数参数传递时</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//函数声明</span><br><span class="line">Teacher::Teacher(const Teacher&amp; teacher);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++构造函数中转而调用其它构造函数的三种方法</title>
    <url>/blog/2/</url>
    <content><![CDATA[<h2 id="C-构造函数中转而调用其它构造函数的三种方法"><a href="#C-构造函数中转而调用其它构造函数的三种方法" class="headerlink" title="C++构造函数中转而调用其它构造函数的三种方法"></a><strong>C++构造函数中转而调用其它构造函数的三种方法</strong></h2><p><strong>0x00 在初始化列表中调调用另一个构造函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*	warning: delegating constructors only available with -std=c++11 or -std=gnu++11</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Teacher::Teacher(): Teacher(&quot;unknown&quot;,30) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>0x01 使用this指针显式调用构造函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*	经过实践发现g++似乎不能这么用</span><br><span class="line">*	error: cannot call constructor ‘Teacher::Teacher’ directly</span><br><span class="line">*	参见：</span><br><span class="line">*	https://stackoverflow.com/questions/9253619/c-cannot-call-constructor-directly</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Teacher::Teacher() &#123;</span><br><span class="line">	this-&gt;Teacher::Teacher(&quot;unknown&quot;,30);//此方法必须加上作用域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>0x02 原始内存覆盖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*	使用new (void*p) ClassType(param...)，这种语句的意思是不重新分配内存，而是直接覆盖在原内存上。</span><br><span class="line">*	参见：</span><br><span class="line">*	https://www.jianshu.com/p/4af119c44086</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Teacher::Teacher():m_iMaxStudentNum(30) &#123;</span><br><span class="line">	new (this) Teacher(&quot;unknown&quot;,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++枚举enum</title>
    <url>/blog/3/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/bruce_0712/article/details/54984371" target="_blank" rel="noopener">http://blog.csdn.net/bruce_0712/article/details/54984371</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces 429B B.Working out</title>
    <url>/blog/4/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/429/B" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/429/B</a><br>对于题中刁钻的要求，仔细分析所给条件的等价条件，有时候，所给条件符合的情形只有很少的几种。</p>
<p><a href="http://blog.csdn.net/cc_again/article/details/25691925" target="_blank" rel="noopener">http://blog.csdn.net/cc_again/article/details/25691925</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目意思：</span><br><span class="line">给n*m的矩阵，每个格子有个数，A从(1,1)出发只能向下或右走，终点为(n,m)，B从(n,1)出发只能向上或右走，终点为(1,m)。两个人的速度不一样，走到的格子可以获的该格子的数，两人相遇的格子上的数两个人都不能拿。求A和B能拿到的数的总和的最大值。</span><br><span class="line">n,m&lt;=1000</span><br><span class="line">解题思路：</span><br><span class="line">dp.</span><br><span class="line">先预处理出每个格子到四个角落格子的路径最大数值，然后枚举两个人相遇的交点格子，枚举A、B的进来和出去方式，求最大值即可。</span><br><span class="line">注意边界情况。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX 1005</span><br><span class="line"></span><br><span class="line">long data[MAX][MAX];</span><br><span class="line">long dp0[MAX][MAX];</span><br><span class="line">long dp1[MAX][MAX];</span><br><span class="line">long dp2[MAX][MAX];</span><br><span class="line">long dp3[MAX][MAX];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	int n, m;</span><br><span class="line"></span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	for (int x = 1; x &lt;= n; x++) &#123;</span><br><span class="line"></span><br><span class="line">		for (int y = 1; y &lt;= m; y++) &#123;</span><br><span class="line"></span><br><span class="line">			scanf(&quot;%ld&quot;, data[x] + y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int x = 1; x &lt;= n; x++) &#123;</span><br><span class="line">		for (int y = 1; y &lt;= m; y++) &#123;</span><br><span class="line">			dp0[x][y] = data[x][y] + max(dp0[x - 1][y] , dp0[x][y - 1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int x = n; x &gt;= 1; x--) &#123;</span><br><span class="line">		for (int y = m; y &gt;= 1; y--) &#123;</span><br><span class="line">			dp1[x][y] = data[x][y] + max(dp1[x + 1][y] , dp1[x][y + 1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int x = n; x &gt;= 1; x--) &#123;</span><br><span class="line">		for (int y = 1; y &lt;= m; y++) &#123;</span><br><span class="line">			dp2[x][y] = data[x][y] + max(dp2[x + 1][y] , dp2[x][y - 1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int x = 1; x &lt;= n; x++) &#123;</span><br><span class="line">		for (int y = m; y &gt;= 1; y--) &#123;</span><br><span class="line">			dp3[x][y] = data[x][y] + max(dp3[x - 1][y] , dp3[x][y + 1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	long largest = 0;</span><br><span class="line">	for (int x = 2; x &lt; n; x++) &#123;</span><br><span class="line">		for (int y = 2; y &lt; m; y++ ) &#123;</span><br><span class="line"></span><br><span class="line">			/**</span><br><span class="line">			* 由于路径只允许重叠一次，根据两人的行动方向可知，重叠时</span><br><span class="line">			* 要么是第一个人从上向下通过，第二个人从左向右通过</span><br><span class="line">			* 要么是第一个人从左向右通过，第二个人从下向上通过</span><br><span class="line">			*/</span><br><span class="line">			largest = max(largest, dp0[x - 1][y] + dp1[x + 1][y] + dp2[x][y - 1] + dp3[x][y + 1]);</span><br><span class="line">			largest = max(largest, dp0[x][y - 1] + dp1[x][y + 1] + dp2[x + 1][y] + dp3[x - 1][y]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%ld\n&quot;, largest);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>CodeForces 699D Fix a Tree——并查集优化 给出所有节点的父节点（有向图），用最少的修改生成一颗合法的树（环的判断，去环）</title>
    <url>/blog/7/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D. Fix a Tree</span><br><span class="line">time limit per test</span><br><span class="line">2 seconds</span><br><span class="line">memory limit per test</span><br><span class="line">256 megabytes</span><br><span class="line">input</span><br><span class="line">standard input</span><br><span class="line">output</span><br><span class="line">standard output</span><br><span class="line"></span><br><span class="line">A tree is an undirected connected graph without cycles.</span><br><span class="line"></span><br><span class="line">Let&apos;s consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p1, p2, ..., pn, where pi denotes a parent of vertex i (here, for convenience a root is considered its own parent).</span><br><span class="line">For this rooted tree the array p is [2, 3, 3, 2].</span><br><span class="line"></span><br><span class="line">Given a sequence p1, p2, ..., pn, one is able to restore a tree:</span><br><span class="line"></span><br><span class="line">    There must be exactly one index r that pr = r. A vertex r is a root of the tree.</span><br><span class="line">    For all other n - 1 vertices i, there is an edge between vertex i and vertex pi. </span><br><span class="line"></span><br><span class="line">A sequence p1, p2, ..., pn is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.</span><br><span class="line"></span><br><span class="line">You are given a sequence a1, a2, ..., an, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.</span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">The first line of the input contains an integer n (2 ≤ n ≤ 200 000) — the number of vertices in the tree.</span><br><span class="line"></span><br><span class="line">The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n).</span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">In the first line print the minimum number of elements to change, in order to get a valid sequence.</span><br><span class="line"></span><br><span class="line">In the second line, print any valid sequence possible to get from (a1, a2, ..., an) in the minimum number of changes. If there are many such sequences, any of them will be accepted.</span><br><span class="line">Examples</span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">2 3 3 4</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2 3 4 4 </span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line">3 2 2 5 3</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">3 2 2 5 3 </span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">2 3 5 4 1 6 6 7</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">2 3 7 8 1 6 6 7</span><br></pre></td></tr></table></figure>
<p>##<strong>0x00</strong></p>
<p><strong>这题我的第一种解法就是先将多个树合并到一起，然后遍历每一个节点，暴力搜寻环，类似dfs，不断向父元素递进，用一个set储存途经的所有元素，对于查找到节点i时，判断它的父元素在set中是否出现了，如果出现了就说明成了环，然后设置节点i的父节点为一个统一的根节点<br>为了优化速度，引入一个visited数组记录某个节点是否已经访问过，如果访问过那么下一次遇到的时候就直接结束向父元素的递进</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// AC</span><br><span class="line">//200ms</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; line;//缓存查找过程中经过的所有元素,耗时高</span><br><span class="line"></span><br><span class="line">int n, changes = 0;</span><br><span class="line">int root = 0;</span><br><span class="line"></span><br><span class="line">int fa[200005];//这个数组作为最后的输出结果</span><br><span class="line">int visited[200005];//优化</span><br><span class="line"></span><br><span class="line">void check(int i) &#123;//检查是否有环出现</span><br><span class="line"></span><br><span class="line">	if (!line.empty()) &#123;</span><br><span class="line">		line.clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (fa[i] != i) &#123;//未到达树顶端时不断循环</span><br><span class="line"></span><br><span class="line">		visited[i] = 1;</span><br><span class="line"></span><br><span class="line">		if (line.count(fa[i])) &#123;//若找到环</span><br><span class="line">			changes++;//改变次数+1</span><br><span class="line">			if (!root) &#123;//若还没有根元素</span><br><span class="line">				root = i;// 将此时的i作为根元素</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fa[i] = root;//把当前元素挂到根元素下</span><br><span class="line"></span><br><span class="line">			return;//退出循环</span><br><span class="line"></span><br><span class="line">		&#125; else &#123;//若这一步也没出现环</span><br><span class="line">			line.insert(i);//把当前元素加到set中</span><br><span class="line">			i = fa[i];// 迭代</span><br><span class="line">			if (visited[i]) &#123; //若已经拜访过了,就直接退出，这一步优化很关键！</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">	for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, fa + i);</span><br><span class="line">		if (fa[i] == i) &#123;</span><br><span class="line">			if (root) &#123; //若此前已经有根节点</span><br><span class="line">				fa[i] = root;</span><br><span class="line">				changes++;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				root = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">		if (!visited[i]) &#123;</span><br><span class="line">			check(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, changes);</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d&quot;, fa[1]);</span><br><span class="line"></span><br><span class="line">	for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">		printf(&quot; %d&quot;, fa[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##<strong>0x01</strong><br><strong>我的第二种解法是结合并查集</strong></p>
<p><strong>思考<br>如果将一个树中的某个节点i的父节点设置为某个节点j，导致出现了环，那么显然从j沿着父节点的方向去递推（用并查集的find函数），最终一定会到达i节点（先把所有没有指定父节点的节点指向自己，即初始化fa[x] = x，这样find（j）就会在i节点处结束）</strong></p>
<p><strong>也就是说当i = find(j)的时候,如果把i的父节点设置为j，就会造成环的出现<br>抓住这一点，在环即将出现时，我们就可以把i的父节点改成指向统一的根节点，这样就用一个操作就把环消除了</strong></p>
<p><strong>优化：<br>由于最终我们要输出一个最少修改数量的数组，但是find函数的优化是建立在把大量节点直接挂到根节点下的这种操作上的，所以我建立了另一个数组icopy来让find函数得以优化</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//并查集实现</span><br><span class="line">//108ms</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*	思路:</span><br><span class="line">*	所有可能的情况就两种,</span><br><span class="line">*	1.正常的树</span><br><span class="line">*	2.成环</span><br><span class="line">*	我们要做的是,把环拆开成树,把所有树并在一起,要做到操作次数最少,那么当然是一个环在某一个地方拆开,指向另一个根节点,但是到底指向哪里暂时还不知道,所以让它先指向自己,称为假根节点,记录下这些假节点,之后再来处理它的去向</span><br><span class="line">*	如果有多个根节点,选其中一个作为最终的根节点,其余的根节点和假节点都并在它的下面[操作次数=假根节点的数量 + 根节点的数量 - 1]</span><br><span class="line">*	如果没有根节点,那么某一个假节点作为最终根节点[操作次数 = 假根节点数量 + 根节点数量(是0)]</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int n, changes = 0, root;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; fackRoot;</span><br><span class="line"></span><br><span class="line">int fa[200005];//这个数组作为最后的输出结果</span><br><span class="line">int facopy[200005];//这个数组作为最后的输出结果</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">	for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">		facopy[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int i) &#123;//非递归实现</span><br><span class="line">	int icopy = i;</span><br><span class="line">	while (i != facopy[i]) &#123;//找到根元素</span><br><span class="line">		i = facopy[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (icopy != facopy[icopy]) &#123;</span><br><span class="line">		icopy = facopy[icopy];//获取父节点</span><br><span class="line">		facopy[icopy] = i;//挂到根节点下</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">	init();</span><br><span class="line"></span><br><span class="line">	for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, fa + i);</span><br><span class="line"></span><br><span class="line">		if (fa[i] == i) &#123;</span><br><span class="line">			if (root) &#123;</span><br><span class="line">				changes++;//做出改变</span><br><span class="line">				fa[i] = root;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				root = i;</span><br><span class="line">			&#125;</span><br><span class="line">			facopy[i] = root;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (i == find(fa[i])) &#123;//若出现环</span><br><span class="line">				//加入到fackRoot</span><br><span class="line">				fackRoot.push(i);</span><br><span class="line">				// facopy[i] = i;//拆开环，作为假的根元素，暂时指向自己</span><br><span class="line">				// 上面这一步操作不用写，因为之前对并查集执行过init()操作</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				facopy[i] = find(fa[i]);//直接挂在根节点</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 处理所有fackRoot</span><br><span class="line">	changes += fackRoot.size();</span><br><span class="line">	while (!fackRoot.empty()) &#123;</span><br><span class="line">		if (root) &#123;//若之前确立了根元素</span><br><span class="line">			fa[fackRoot.front()] = root;</span><br><span class="line">			fackRoot.pop();</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			root = fackRoot.front();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, changes);</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d&quot;, fa[1]);</span><br><span class="line"></span><br><span class="line">	for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">		printf(&quot; %d&quot;, fa[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>CodeForces 697D 树+概率</title>
    <url>/blog/5/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/697/D" target="_blank" rel="noopener">原题链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D. Puzzles</span><br><span class="line">time limit per test</span><br><span class="line">1 second</span><br><span class="line">memory limit per test</span><br><span class="line">256 megabytes</span><br><span class="line">input</span><br><span class="line">standard input</span><br><span class="line">output</span><br><span class="line">standard output</span><br><span class="line"></span><br><span class="line">Barney lives in country USC (United States of Charzeh). USC has n cities numbered from 1 through n and n - 1 roads between them. Cities and roads of USC form a rooted tree (Barney&apos;s not sure why it is rooted). Root of the tree is the city number 1\. Thus if one will start his journey from city 1, he can visit any city he wants by following roads.</span><br><span class="line"></span><br><span class="line">Some girl has stolen Barney&apos;s heart, and Barney wants to find her. He starts looking for in the root of the tree and (since he is Barney Stinson not a random guy), he uses a random DFS to search in the cities. A pseudo code of this algorithm is as follows:</span><br><span class="line"></span><br><span class="line">let starting_time be an array of length n</span><br><span class="line">current_time = 0</span><br><span class="line">dfs(v):</span><br><span class="line">	current_time = current_time + 1</span><br><span class="line">	starting_time[v] = current_time</span><br><span class="line">	shuffle children[v] randomly (each permutation with equal possibility)</span><br><span class="line">	// children[v] is vector of children cities of city v</span><br><span class="line">	for u in children[v]:</span><br><span class="line">		dfs(u)</span><br><span class="line"></span><br><span class="line">As told before, Barney will start his journey in the root of the tree (equivalent to call dfs(1)).</span><br><span class="line"></span><br><span class="line">Now Barney needs to pack a backpack and so he wants to know more about his upcoming journey: for every city i, Barney wants to know the expected value of starting_time[i]. He&apos;s a friend of Jon Snow and knows nothing, that&apos;s why he asked for your help.</span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">The first line of input contains a single integer n (1 ≤ n ≤ 105) — the number of cities in USC.</span><br><span class="line"></span><br><span class="line">The second line contains n - 1 integers p2, p3, ..., pn (1 ≤ pi &lt; i), where pi is the number of the parent city of city number i in the tree, meaning there is a road between cities numbered pi and i in USC.</span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">In the first and only line of output print n numbers, where i-th number is the expected value of starting_time[i].</span><br><span class="line"></span><br><span class="line">Your answer for each city will be considered correct if its absolute or relative error does not exceed 10 - 6.</span><br><span class="line">Examples</span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">7</span><br><span class="line">1 2 1 1 4 4</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">1.0 4.0 5.0 3.5 4.5 5.0 5.0 </span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">1 1 2 2 4 4 3 3 1 10 8</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">1.0 5.0 5.5 6.5 7.5 8.0 8.0 7.0 7.5 6.5 7.5 8.0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">//multiset的定义在set头文件中</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int data[100005][2];//[0]自身以及子节点的数量[1]父节点</span><br><span class="line">double ans[100005];</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">	int x;//父节点</span><br><span class="line">	int y;//子节点</span><br><span class="line"></span><br><span class="line">	Node(int x, int y): x(x), y(y) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	int operator &lt; (Node const &amp; n) const &#123;//倒序</span><br><span class="line">		return x &gt; n.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multiset&lt;Node&gt; ms;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int n, temp;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	data[1][0] = 1;</span><br><span class="line">	for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;temp);</span><br><span class="line">		data[i][0] = 1;</span><br><span class="line">		data[i][1] = temp;</span><br><span class="line">		Node n(temp, i);</span><br><span class="line">		ms.insert(n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 从树的最底开始上升</span><br><span class="line">	int cou = 0;</span><br><span class="line">	for (multiset&lt;Node&gt;::iterator i = ms.begin(); i != ms.end(); ++i) &#123;</span><br><span class="line">		data[i-&gt;x][0] += data[i-&gt;y][0];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ans[1] = 1.0;</span><br><span class="line">	printf(&quot;1.0&quot;);</span><br><span class="line">	for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">		/**</span><br><span class="line">		* 第i个节点的期望 == 它的父节点的期望 + 在它自身的耗时(1) + 第i个节点的兄弟节点及它拓展的子节点耗时的期望(即兄弟节点及它拓展的子节点数 * 0.5)</span><br><span class="line">		* (兄弟节点及它拓展的子节点数 == i 的父节点 - i 节点拓展的树的所有节点(包括i) - 1(父节点自身))，</span><br><span class="line">		* 这些节点每一个要么在i之前被遍历，要么在i之后，于是期望值乘以0.5</span><br><span class="line">		*/</span><br><span class="line">		ans[i] = ans[data[i][1]] + 1 + (data[data[i][1]][0] - 1 - data[i][0]) * 0.5;</span><br><span class="line">		printf(&quot; %.1f&quot;, ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>CodeForces 699C Vacations——动态规划</title>
    <url>/blog/6/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/699/C" target="_blank" rel="noopener">原题链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C. Vacations</span><br><span class="line">time limit per test</span><br><span class="line">1 second</span><br><span class="line">memory limit per test</span><br><span class="line">256 megabytes</span><br><span class="line">input</span><br><span class="line">standard input</span><br><span class="line">output</span><br><span class="line">standard output</span><br><span class="line"></span><br><span class="line">Vasya has n days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this n days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the i-th day there are four options:</span><br><span class="line"></span><br><span class="line">    on this day the gym is closed and the contest is not carried out;</span><br><span class="line">    on this day the gym is closed and the contest is carried out;</span><br><span class="line">    on this day the gym is open and the contest is not carried out;</span><br><span class="line">    on this day the gym is open and the contest is carried out. </span><br><span class="line"></span><br><span class="line">On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).</span><br><span class="line"></span><br><span class="line">Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.</span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">The first line contains a positive integer n (1 ≤ n ≤ 100) — the number of days of Vasya&apos;s vacations.</span><br><span class="line"></span><br><span class="line">The second line contains the sequence of integers a1, a2, ..., an (0 ≤ ai ≤ 3) separated by space, where:</span><br><span class="line"></span><br><span class="line">    ai equals 0, if on the i-th day of vacations the gym is closed and the contest is not carried out;</span><br><span class="line">    ai equals 1, if on the i-th day of vacations the gym is closed, but the contest is carried out;</span><br><span class="line">    ai equals 2, if on the i-th day of vacations the gym is open and the contest is not carried out;</span><br><span class="line">    ai equals 3, if on the i-th day of vacations the gym is open and the contest is carried out.</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:</span><br><span class="line"></span><br><span class="line">    to do sport on any two consecutive days,</span><br><span class="line">    to write the contest on any two consecutive days. </span><br><span class="line"></span><br><span class="line">Examples</span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">1 3 2 0</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">7</span><br><span class="line">1 3 3 2 1 2 3</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">2 2</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Note</span><br><span class="line"></span><br><span class="line">In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3\. Thus, he will have a rest for only 2 days.</span><br><span class="line"></span><br><span class="line">In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.</span><br><span class="line"></span><br><span class="line">In the third test Vasya can do sport either on a day number 1 or number 2\. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int max(int x, int y) &#123;</span><br><span class="line">	return x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line">int max(int x, int y, int z) &#123;</span><br><span class="line">	return x &gt; y ? (x &gt; z ? x : z) : (y &gt; z ? y : z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	int g_date[t] = &#123;0&#125;;//g_date[i](i从0开始)表示第i天体育场是否开放</span><br><span class="line">	int c_date[t] = &#123;0&#125;;//c_date[i](i从0开始)表示第i天是否有比赛</span><br><span class="line"></span><br><span class="line">	int dp[t][3] = &#123;0&#125;;</span><br><span class="line">	// dp[i][x],i从0开始，储存截止到第i天结束工作的天数，工作天数越多，说明休息天数越少</span><br><span class="line">	// [i][0]表示第i天啥都不做，[i][1]表示第i天去体育馆，[i][2]表示第i天打比赛，</span><br><span class="line">	int c_dp[t][2] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	int temp;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; t; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;temp);</span><br><span class="line">		switch (temp) &#123;</span><br><span class="line">		case 0:</span><br><span class="line">			break;</span><br><span class="line">		case 1:</span><br><span class="line">			c_date[i] = 1;</span><br><span class="line">			break;</span><br><span class="line">		case 2:</span><br><span class="line">			g_date[i] = 1;</span><br><span class="line">			break;</span><br><span class="line">		case 3:</span><br><span class="line">			c_date[i] = 1;</span><br><span class="line">			g_date[i] = 1;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; t ; i++) &#123;</span><br><span class="line">		if (i == 0) &#123;//第一天的情况</span><br><span class="line">			dp[i][0] = 0;</span><br><span class="line"></span><br><span class="line">			if (g_date[i]) &#123;//若第i天体育馆开放</span><br><span class="line">				dp[i][1] = 1;//选择去体育馆</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (c_date[i]) &#123;//若第i天有比赛可打</span><br><span class="line">				dp[i][2] = 1;//选择去打比赛</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; else &#123;//若不是第一天</span><br><span class="line"></span><br><span class="line">			dp[i][0] = max(dp[i - 1][1], dp[i - 1][0], dp[i - 1][2]);//选择什么也不做，那么最大工作天数等于昨天的三种情况里最大的那个</span><br><span class="line">			if (g_date[i]) &#123;//若今天体育馆开门</span><br><span class="line">				dp[i][1] = 1 + max(dp[i - 1][0], dp[i - 1][2]);//从昨天啥都不做和昨天去打比赛中选一个最大的</span><br><span class="line">			&#125;//若今天体育馆不开门，显然今天dp[i][1]的状态是不存在的，不能被使用，如何防止以后用到这种不存在的状态呢？这里就和max函数有关系了，只要把不存在的状态的值设置的足够小，那么max函数就肯定不会选取这个比别的数都小的值作为返回值，也就是max函数恰好筛选掉了不合法的状态，而dp[i][1]为默认值0，我们知道工作天数的最小值就是0，所以我们可以大胆地不对dp[i][1]赋值，当然如果你怕出问题的话，你可以赋值为-1或者-inf</span><br><span class="line"></span><br><span class="line">			if (c_date[i]) &#123;//若今天有比赛可打</span><br><span class="line">				dp[i][2] = 1 + max(dp[i - 1][1], dp[i - 1][0]);</span><br><span class="line">			&#125;//若今天无比赛，情况和上面的描述类似，可以不赋值(就用默认值0)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 最小休息天数 = 总天数 - 最大工作天数</span><br><span class="line">	printf(&quot;%d\n&quot;, t - max(dp[t - 1][0], dp[t - 1][1], dp[t - 1][2]));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>CodeForces 891 A. Pride</title>
    <url>/blog/8/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/891/A" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/891/A</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long dp[2005][2005]; // dp[x][y]表示gcd(x...(x + y))</span><br><span class="line">/*</span><br><span class="line">x是起始点位置,y是距离</span><br><span class="line">a1, a2, a3, a4, a5, a6, a7, a8</span><br><span class="line">	↑	←	y	→	↑</span><br><span class="line">	x				x + y</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// gcd(a1, a2, a3) = gcd(gcd(a1, a2), a3) = gcd(gcd(a1, a2), gcd(a2, a3))</span><br><span class="line">// 所以</span><br><span class="line"></span><br><span class="line">// 状态方程</span><br><span class="line">// dp[x][y] = gcd(dp[x][y - 1], dp[x + 1][y - 1])</span><br><span class="line"></span><br><span class="line">long long gcd(long long a, long long b) &#123;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		a = a % b;</span><br><span class="line">		if (!a) &#123;</span><br><span class="line">			return b;</span><br><span class="line">		&#125;</span><br><span class="line">		b = b % a;</span><br><span class="line">		if (!b) &#123;</span><br><span class="line">			return a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	int ones = 0;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">	for (int x = 0; x &lt; n; x++) &#123;</span><br><span class="line">		scanf(&quot;%lld&quot;, dp[x]);</span><br><span class="line">		if (dp[x][0] == 1) &#123;</span><br><span class="line">			ones++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// printf(&quot;%lld\t&quot;, dp[x][0]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	if (ones) &#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, n - ones);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int y = 1; y &lt; n; y++) &#123;//跨度距离从1开始</span><br><span class="line">		for (int x = 0; x + y &lt; n; x++) &#123;//起始位置从x开始</span><br><span class="line"></span><br><span class="line">			dp[x][y] = gcd(dp[x][y - 1], dp[x + 1][y - 1]);</span><br><span class="line"></span><br><span class="line">			// printf(&quot;%lld\t&quot;, dp[x][y]);</span><br><span class="line"></span><br><span class="line">			if (dp[x][y] == 1) &#123;</span><br><span class="line">				// printf(&quot;\n&quot;);</span><br><span class="line">				printf(&quot;%d\n&quot;, n + y - 1);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;-1\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*	</span><br><span class="line">*	in:</span><br><span class="line">*	</span><br><span class="line">*	5</span><br><span class="line">*	2 2 3 4 6</span><br><span class="line">*	</span><br><span class="line">*	out:</span><br><span class="line">*	</span><br><span class="line">*	2		2		3		4		6</span><br><span class="line">*	↑↗		↑↗</span><br><span class="line">*	2		1</span><br><span class="line">*	</span><br><span class="line">*	result：</span><br><span class="line">*	</span><br><span class="line">*	5</span><br><span class="line">*	</span><br><span class="line">*	</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>CodeForces</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>C——printf格式化动态长度</title>
    <url>/blog/9/</url>
    <content><![CDATA[<p>printf要格式化输出动态长度的数，有两种方法：</p>
<p><strong>0x00 构造一个字符数组，先根据要动态的长度构造出对应的格式化字符串，然后传入printf的第一个参数。</strong></p>
<p><strong>0x01 采用<code>*</code>来占用长度的位置</strong></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf(&quot;%.*f&quot;, length, num);</span><br></pre></td></tr></table></figure></p>
<p>长度作为第二个参数传入。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Fragment != Fragment ? —— Xposed开发时遇到的关于ClassLoader的问题</title>
    <url>/blog/10/</url>
    <content><![CDATA[<p>今天在写Xposed模块的过程中，为了找到某个Field，需要判断Filed的某个祖先的类型是是Fragment类型</p>
<p>但在做比较的时候出现了问题，发生了Fragment != Fragment的问题：</p>
<p>注：这里的 Fragment 是 android.support.v4.app.Fragment 而不是 android.app.Fragment</p>
<p>我们知道v4包是要额外导入的，<br><img src="/images/blog/10_1.png" alt=""></p>
<p>所以说，一共出现了两份v4包，一份打包在宿主app里，一份打包在自己的模块里面，在加载的时候会出现因为ClassLoader不一致而导致两个class不同的情况</p>
<p>如图：<br><img src="/images/blog/10_0.png" alt=""></p>
<p><strong>在debug添加查看发现，两个Class虽然都是android.support.v4.app.Fragment但由于ClassLoader不一样，导致两个Class不相等；</strong></p>
<p>查看其它的Class发现，系统自带的那些jar里面的Class都是由BootClassLoader加载的，<br><img src="/images/blog/10_2.png" alt=""><br>而BootClassLoader的实例在虚拟机中只有一个，所以模块中的Context.class和宿主app里的Context.class是一样的</p>
]]></content>
      <categories>
        <category>Xposed</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 1003 Max sum——分治法的应用，动态规划，前缀数组</title>
    <url>/blog/11/</url>
    <content><![CDATA[<p>原题： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1003</a></p>
<p>看到这题的时候一脸懵逼，网上寻找解答，发现都讲的不详细，变量声明也很短，根本看不出是什么用途，这里给出了我的解答，参考了网上各位大神的方法，加上了注释，方便学习。</p>
<p>##<strong>0x00 分治法解题</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct Sequence</span><br><span class="line">&#123;</span><br><span class="line">	//表示一个数组</span><br><span class="line"></span><br><span class="line">	int sum;//数组元素之和</span><br><span class="line">	int leftPosition;//数组左边界位置</span><br><span class="line">	int rightPosition;//数组右边界位置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	求最大子列：</span><br><span class="line"></span><br><span class="line">	首先明确：</span><br><span class="line">		给定一个数列</span><br><span class="line">		其最大子列的范围，要么包括正中间的位置，要么全在最中间位置的左边，要么全在最中间位置的右边</span><br><span class="line">		这三种情况在迭代函数中分别处理</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">struct Sequence getMaxSequence(int * sourceSequence, int leftPosition, int rightPosition) &#123;</span><br><span class="line"></span><br><span class="line">	// printf(&quot;into： %d, %d\n&quot;,leftPosition,rightPosition);</span><br><span class="line">	int mediumPosition;</span><br><span class="line"></span><br><span class="line">	//范围：[leftPosition, rightPosition]</span><br><span class="line">	if (leftPosition == rightPosition) &#123;</span><br><span class="line">		//给定范围内的子数列只有一个元素,构造一个struct sequence来描述;</span><br><span class="line">		struct Sequence sequence;</span><br><span class="line">		sequence.leftPosition = leftPosition;</span><br><span class="line"></span><br><span class="line">		sequence.rightPosition = rightPosition;</span><br><span class="line">		sequence.sum = sourceSequence[leftPosition];</span><br><span class="line">		// printf(&quot;return: %d, %d\n&quot;,sequence.leftPosition,sequence.rightPosition);</span><br><span class="line"></span><br><span class="line">		return sequence;</span><br><span class="line">		    //将这个元素返回</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//取得中间位置</span><br><span class="line">	mediumPosition = (leftPosition + rightPosition) / 2;</span><br><span class="line"></span><br><span class="line">	//构造三种struct来保存三种情况的返回值；</span><br><span class="line">	struct Sequence leftSequence;</span><br><span class="line">	struct Sequence rightSequence;</span><br><span class="line">	struct Sequence aroundSequence;</span><br><span class="line"></span><br><span class="line">	leftSequence = getMaxSequence(sourceSequence, leftPosition, mediumPosition);</span><br><span class="line"></span><br><span class="line">	rightSequence = getMaxSequence(sourceSequence, mediumPosition + 1, rightPosition);</span><br><span class="line"></span><br><span class="line">	//第三种情况下，先从中间向左边查找找出最大的和，再从中间向右边查找找出最大的和，相加得到横跨中间位置的最大值及范围</span><br><span class="line">	//先是左边</span><br><span class="line">	//先保存向左边出发遇到的第一个值</span><br><span class="line">	int leftMaxSumTmp = sourceSequence[mediumPosition];</span><br><span class="line">	//并保存该值的位置</span><br><span class="line">	aroundSequence.leftPosition = mediumPosition;</span><br><span class="line"></span><br><span class="line">	int leftSumTmp = 0;</span><br><span class="line">	for (int index = mediumPosition; index &gt;= leftPosition; index--) &#123;</span><br><span class="line">		leftSumTmp = leftSumTmp + sourceSequence[index];</span><br><span class="line">		if (leftSumTmp &gt;= leftMaxSumTmp) &#123;</span><br><span class="line">			//如果发现从中间到左边某一项的所有值之和比leftMaxSumTmp更大了,就更新leftMaxSumTmp</span><br><span class="line">			//并记录此位置到aroundSequence的leftPosition字段</span><br><span class="line">			leftMaxSumTmp = leftSumTmp;</span><br><span class="line">			aroundSequence.leftPosition = index;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//再是右边</span><br><span class="line">	//先保存向右边出发遇到的第一个值(因为到这里leftPosition和rightPosition不相等所以meiumPosition + 1（一定小于等于rightPosition）一定没有超过范围：[leftPosition, rightPosition])，不加if</span><br><span class="line">	int rightMaxSumTmp = sourceSequence[mediumPosition + 1];</span><br><span class="line">	//保存该值的位置</span><br><span class="line">	aroundSequence.rightPosition = mediumPosition + 1;</span><br><span class="line"></span><br><span class="line">	int rightSumTmp = 0;</span><br><span class="line">	for (int index = mediumPosition + 1; index &lt;= rightPosition; index++) &#123;</span><br><span class="line">		rightSumTmp = rightSumTmp + sourceSequence[index];</span><br><span class="line">		if (rightSumTmp &gt;= rightMaxSumTmp) &#123;</span><br><span class="line">			//如果发现从中间到右边某一项的所有值之和比rightMaxSumTmp更大了,就更新rightMaxSumTmp</span><br><span class="line">			//并记录此位置到aroundSequence的rightPosition字段</span><br><span class="line">			rightMaxSumTmp = rightSumTmp;</span><br><span class="line">			aroundSequence.rightPosition = index;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	aroundSequence.sum = leftMaxSumTmp + rightMaxSumTmp;</span><br><span class="line"></span><br><span class="line">	//三选一返回，选sum最长的那个返回</span><br><span class="line"></span><br><span class="line">	// printf(&quot;return: %d, %d\n&quot;,finalSequence.leftPosition,finalSequence.rightPosition);</span><br><span class="line">	return (leftSequence.sum &gt; rightSequence.sum) ? ((leftSequence.sum &gt; aroundSequence.sum) ? leftSequence : aroundSequence) : ((rightSequence.sum &gt; aroundSequence.sum) ? rightSequence : aroundSequence);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int numOfCase , indexOfCase = 1,lengthOfSquence;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;numOfCase);</span><br><span class="line">	while (indexOfCase &lt;= numOfCase) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;lengthOfSquence);</span><br><span class="line">		int sourceSequence[100000];</span><br><span class="line">		for(int index = 0;index &lt;lengthOfSquence;index++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,sourceSequence + index); </span><br><span class="line">		&#125;</span><br><span class="line">		struct Sequence aimSequence =  getMaxSequence(sourceSequence,0,lengthOfSquence - 1);</span><br><span class="line">		printf(&quot;Case %d:\n%d %d %d\n&quot;, indexOfCase ,aimSequence.sum,aimSequence.leftPosition + 1,aimSequence.rightPosition + 1);</span><br><span class="line">		if(indexOfCase != numOfCase)&#123;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		indexOfCase++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>寒假看到这样一篇文章，讲的很详细<br><a href="http://conw.net/archives/9/#comment-25" target="_blank" rel="noopener">http://conw.net/archives/9/#comment-25</a></p>
<p>##<strong>0x01 动态规划</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">#define iinf 1e9</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// O(n)AC</span><br><span class="line"></span><br><span class="line">// 动态规划</span><br><span class="line">// 原先维护一个dp数组，dp[i]保存以第i个位子结尾的所有子列的最大和</span><br><span class="line">// dp[i] = list[i] + max(dp[i - 1], 0);</span><br><span class="line">// 自处省略这个数组，用两个变量来实现</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int T, N, last, now, ans, startpos, l, r;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	for (int j = 1; j &lt;= T; j++) &#123;</span><br><span class="line">		last = -1;</span><br><span class="line">		ans = -iinf;</span><br><span class="line">		l = 1;</span><br><span class="line">		r = 1;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line"></span><br><span class="line">		for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;now);</span><br><span class="line">			if (last &gt;= 0) &#123;</span><br><span class="line">				last = now + last;</span><br><span class="line"></span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				last = now;</span><br><span class="line">				startpos = i;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (last &gt; ans) &#123;</span><br><span class="line">				ans = last;</span><br><span class="line">				l = startpos;</span><br><span class="line">				r = i;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (j == 1) &#123;</span><br><span class="line">			printf(&quot;Case 1:\n&quot;);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			printf(&quot;\nCase %d:\n&quot;, j);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d %d %d\n&quot;, ans, l, r);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##<strong>0x02 结合优化后的前缀数组</strong></p>
<p>用这种用法的人似乎更多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">#define iinf 1e9</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// O(n)AC</span><br><span class="line"></span><br><span class="line">// 另一种结合前缀数组的方法</span><br><span class="line">// data[i] = list[0...(i - 1)];</span><br><span class="line">// data数组从1开始避免对边界的判断</span><br><span class="line">// 则list[x...y] = data[y + 1] - data[x];</span><br><span class="line">// i作为循环变量</span><br><span class="line">// 维护data[i]的最小值mi，更新ans的最大值</span><br><span class="line">// mi = min(mi, data[i])</span><br><span class="line">// ans = max(data[i] - mi, ans)</span><br><span class="line">// 可知若以第y个元素结尾的所有子列中list[x...y]为最优解，那么data[x]一定是data[1],data[2],data[3]...data[y](注意这里没有data[y+1],因为至少要有一个元素)中的最小值</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int T, N, sum, now, ans, min, minpos, l, r;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	for (int j = 1; j &lt;= T; j++) &#123;</span><br><span class="line">		sum = 0;</span><br><span class="line">		ans = -iinf;</span><br><span class="line">		min = 0;</span><br><span class="line">		minpos = 0;</span><br><span class="line">		l = 1;</span><br><span class="line">		r = 1;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line"></span><br><span class="line">		for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;now);</span><br><span class="line">			sum += now;</span><br><span class="line">			if (sum - min &gt; ans) &#123;//更新答案，这里使用的是上一次循环的min值</span><br><span class="line">				r = i;</span><br><span class="line">				l = minpos + 1;</span><br><span class="line">				ans = sum - min;</span><br><span class="line">			&#125;</span><br><span class="line">			if (sum &lt; min) &#123;//该判断语句不可和上一句调换，否则将可能出现最优解的数列长度为0；</span><br><span class="line">				min = sum;//更新本次循环的min，为在下一循环中使用到</span><br><span class="line">				minpos = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (j == 1) &#123;</span><br><span class="line">			printf(&quot;Case 1:\n&quot;);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			printf(&quot;\nCase %d:\n&quot;, j);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d %d %d\n&quot;, ans, l, r);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HDU</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 1080 POJ 1080 Human Gene Functions——动态规划</title>
    <url>/blog/12/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=1080" target="_blank" rel="noopener">http://poj.org/problem?id=1080</a><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1080" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1080</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">#define MAX(x,y,z) ((x)&gt;(y)?((x)&gt;(z)?(x):(z)):((y)&gt;(z)?(y):(z)))</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char str1[105];</span><br><span class="line">char str2[105];</span><br><span class="line">int list[6][6] = &#123;</span><br><span class="line">//	  		&#123; \0,  A,  C,  G,  T,  -&#125;</span><br><span class="line">	/*\0*/	&#123;  0,  0,  0,  0,  0,  0&#125;,</span><br><span class="line">	/*A*/	&#123;  0,  5, -1, -2, -1, -3&#125;,</span><br><span class="line">	/*C*/	&#123;  0, -1,  5, -3, -2, -4&#125;,</span><br><span class="line">	/*G*/	&#123;  0, -2, -3,  5, -2, -2&#125;,</span><br><span class="line">	/*T*/	&#123;  0, -1, -2, -2,  5, -1&#125;,</span><br><span class="line">	/*-*/	&#123;  0, -3, -4, -2, -1,  0&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;char, int&gt;m;</span><br><span class="line"></span><br><span class="line">int dp[105][105];//dp[x][y]表示str1中1...x-1个字符和str2中第1...y-1之间匹配的最优解</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int T, len1, len2;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line"></span><br><span class="line">	m[&apos;\0&apos;] = 0;</span><br><span class="line">	m[&apos;A&apos;] = 1;</span><br><span class="line">	m[&apos;C&apos;] = 2;</span><br><span class="line">	m[&apos;G&apos;] = 3;</span><br><span class="line">	m[&apos;T&apos;] = 4;</span><br><span class="line">	m[&apos;-&apos;] = 5;</span><br><span class="line"></span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		scanf(&quot;%d%s&quot;, &amp;len1, str1 + 1);</span><br><span class="line">		scanf(&quot;%d%s&quot;, &amp;len2, str2 + 1);</span><br><span class="line"></span><br><span class="line">		// printf(&quot;\t\t&quot;);</span><br><span class="line">		// for (int y = 0; y &lt; len2; y++) &#123;</span><br><span class="line">		// 	printf(&quot;%c\t&quot;, s2[y]);</span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n\t&quot;);</span><br><span class="line"></span><br><span class="line">		// for (int y = 0; y &lt;= len2; y++) &#123;</span><br><span class="line">		// 	printf(&quot;%d\t&quot;, dp[0][y]);</span><br><span class="line"></span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">		for (int x = 1; x &lt;= len1 + 1; x++) &#123;</span><br><span class="line">			dp[x][0] = -1e9;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (int y = 1; y &lt;= len2 + 1; y++) &#123;</span><br><span class="line">			dp[0][y] = -1e9;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (int x = 1; x &lt;= len1 + 1; x++) &#123;</span><br><span class="line"></span><br><span class="line">			for (int y = 1; y &lt;= len2 + 1; y++) &#123;</span><br><span class="line">				dp[x][y] = MAX(</span><br><span class="line">				               dp[x - 1][y - 1] + list[m[str1[x - 1]]][m[str2[y - 1]]],</span><br><span class="line">				               dp[x - 1][y] + list[m[str1[x - 1]]][m[&apos;-&apos;]],</span><br><span class="line">				               dp[x][y - 1] + list[m[&apos;-&apos;]][m[str2[y - 1]]]</span><br><span class="line">				           );</span><br><span class="line"></span><br><span class="line">//取消注釋打印流程</span><br><span class="line"></span><br><span class="line">/*				if (dp[x - 1][y - 1] + list[m[str1[x - 1]]][m[str2[y - 1]]]</span><br><span class="line">				        &gt;= dp[x - 1][y] + list[m[str1[x - 1]]][m[&apos;-&apos;]]) &#123;</span><br><span class="line">					if (dp[x - 1][y - 1] + list[m[str1[x - 1]]][m[str2[y - 1]]]</span><br><span class="line">					        &gt;=</span><br><span class="line">					        dp[x][y - 1] + list[m[&apos;-&apos;]][m[str2[y - 1]]]) &#123;</span><br><span class="line">						printf(&quot;↖%d\t&quot;, dp[x][y]);</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						printf(&quot;←%d\t&quot;, dp[x][y]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					if (dp[x - 1][y] + list[m[str1[x - 1]]][m[&apos;-&apos;]]</span><br><span class="line">					        &gt;=</span><br><span class="line">					        dp[x][y - 1] + list[m[&apos;-&apos;]][m[str2[y - 1]]]) &#123;</span><br><span class="line">						printf(&quot;↑%d\t&quot;, dp[x][y]);</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						printf(&quot;←%d\t&quot;, dp[x][y]);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[len1 + 1][len2 + 1]);</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		*</span><br><span class="line">		*	in:</span><br><span class="line">		*	</span><br><span class="line">		*	2</span><br><span class="line">		*	7 AGTGATG</span><br><span class="line">		*	5 GTTAG</span><br><span class="line">		*	7 AGCTATT</span><br><span class="line">		*	9 AGCTTTAAA</span><br><span class="line">		*	</span><br><span class="line">		*	out:</span><br><span class="line">		*	</span><br><span class="line">		*	↖0		←-2		←-3		←-4		←-7		←-9</span><br><span class="line">		*	↑-3		↖-2		↖-3		↖-4		↖1		←-1</span><br><span class="line">		*	↑-5		↖2		←1		←0		↑-1		↖6</span><br><span class="line">		*	↑-6		↑1		↖7		↖6		←3		↑5</span><br><span class="line">		*	↑-8		↖-1		↑5		↖5		↖4		↖8</span><br><span class="line">		*	↑-11	↑-4		↑2		↖4		↖10		←8</span><br><span class="line">		*	↑-12	↑-5		↖1		↖7		↑9		↖8</span><br><span class="line">		*	↑-14	↖-7		↑-1		↑5		↑7		↖14</span><br><span class="line">		*	</span><br><span class="line">		*	14</span><br><span class="line">		*	</span><br><span class="line">		*	↖0		←-3		←-5		←-9		←-10	←-11	←-12	←-15	←-18	←-21</span><br><span class="line">		*	↑-3		↖5		←3		←-1		←-2		←-3		←-4		↖-7		↖-10	↖-13</span><br><span class="line">		*	↑-5		↑3		↖10		←6		←5		←4		←3		←0		←-3		←-6</span><br><span class="line">		*	↑-9		↑-1		↑6		↖15		←14		←13		←12		←9		←6		←3</span><br><span class="line">		*	↑-10	↑-2		↑5		↑14		↖20		↖19		↖18		←15		←12		←9</span><br><span class="line">		*	↑-13	↖-5		↑2		↑11		↑17		↖19		↖18		↖23		↖20		↖17</span><br><span class="line">		*	↑-14	↑-6		↑1		↑10		↖16		↖22		↖24		↑22		↖22		↖19</span><br><span class="line">		*	↑-15	↑-7		↑0		↑9		↖15		↖21		↖27		←24		↖21		↖21</span><br><span class="line">		*	</span><br><span class="line">		*	</span><br><span class="line">		*	21</span><br><span class="line">		*	</span><br><span class="line">		*	</span><br><span class="line">		*	</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后来发现是自己想得太多了，这个题的“状态”不一定非要理解成原先那样，<br>其实完全可以也像最大公共子列那样的，<br>dp[x][y]表示str1的前x个字符和str2的前y个字符之间的匹配结果的最优解<br>这样也便于理解，便于思考</p>
<p>这样的话dp[x][y]就是最终答案，不过要注意边界的预处理<br>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">#define MAX(x,y,z) ((x)&gt;(y)?((x)&gt;(z)?(x):(z)):((y)&gt;(z)?(y):(z)))</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char str1[105];</span><br><span class="line">char str2[105];</span><br><span class="line">int list[6][6] = &#123;</span><br><span class="line">//	  		&#123;  A,  C,  G,  T,  -&#125;</span><br><span class="line">	/*A*/	&#123;  5, -1, -2, -1, -3&#125;,</span><br><span class="line">	/*C*/	&#123; -1,  5, -3, -2, -4&#125;,</span><br><span class="line">	/*G*/	&#123; -2, -3,  5, -2, -2&#125;,</span><br><span class="line">	/*T*/	&#123; -1, -2, -2,  5, -1&#125;,</span><br><span class="line">	/*-*/	&#123; -3, -4, -2, -1,  0&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;char, int&gt;m;</span><br><span class="line"></span><br><span class="line">int dp[105][105];//dp[x][y]表示str1中1...x个字符和str2中第1...y这两个子串之间的所有匹配方式的最大利益</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int T, len1, len2;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line"></span><br><span class="line">	m[&apos;A&apos;] = 0;</span><br><span class="line">	m[&apos;C&apos;] = 1;</span><br><span class="line">	m[&apos;G&apos;] = 2;</span><br><span class="line">	m[&apos;T&apos;] = 3;</span><br><span class="line">	m[&apos;-&apos;] = 4;</span><br><span class="line"></span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		scanf(&quot;%d%s&quot;, &amp;len1, str1 + 1);</span><br><span class="line">		scanf(&quot;%d%s&quot;, &amp;len2, str2 + 1);</span><br><span class="line"></span><br><span class="line">		// printf(&quot;\t\t&quot;);</span><br><span class="line">		// for (int y = 0; y &lt; len2; y++) &#123;</span><br><span class="line">		// 	printf(&quot;%c\t&quot;, s2[y]);</span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n\t&quot;);</span><br><span class="line"></span><br><span class="line">		// for (int y = 0; y &lt;= len2; y++) &#123;</span><br><span class="line">		// 	printf(&quot;%d\t&quot;, dp[0][y]);</span><br><span class="line"></span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">		for (int x = 1; x &lt;= len1; x++) &#123;</span><br><span class="line">			dp[x][0] = dp[x - 1][0] + list[m[str1[x]]][m[&apos;-&apos;]];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// printf(&quot;↖0\t&quot;);</span><br><span class="line">		for (int y = 1; y &lt;= len2; y++) &#123;</span><br><span class="line">			dp[0][y] = dp[0][y - 1] + list[m[str2[y]]][m[&apos;-&apos;]];</span><br><span class="line">			// printf(&quot;←%d\t&quot;, dp[0][y]);</span><br><span class="line">		&#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">		for (int x = 1; x &lt;= len1; x++) &#123;</span><br><span class="line"></span><br><span class="line">			// printf(&quot;↑%d\t&quot;, dp[x][0]);</span><br><span class="line"></span><br><span class="line">			for (int y = 1; y &lt;= len2; y++) &#123;</span><br><span class="line">				dp[x][y] = MAX(</span><br><span class="line">				               dp[x - 1][y - 1] + list[m[str1[x]]][m[str2[y]]],</span><br><span class="line">				               dp[x - 1][y] + list[m[str1[x]]][m[&apos;-&apos;]],</span><br><span class="line">				               dp[x][y - 1] + list[m[&apos;-&apos;]][m[str2[y]]]</span><br><span class="line">				           );</span><br><span class="line"></span><br><span class="line">//取消所有额外注释可打印流程</span><br><span class="line">				/*</span><br><span class="line">								if (dp[x - 1][y - 1] + list[m[str1[x]]][m[str2[y]]]</span><br><span class="line">								        &gt;= dp[x - 1][y] + list[m[str1[x]]][m[&apos;-&apos;]]) &#123;</span><br><span class="line">									if (dp[x - 1][y - 1] + list[m[str1[x]]][m[str2[y]]]</span><br><span class="line">									        &gt;=</span><br><span class="line">									        dp[x][y - 1] + list[m[&apos;-&apos;]][m[str2[y]]]) &#123;</span><br><span class="line">										printf(&quot;↖%d\t&quot;, dp[x][y]);</span><br><span class="line">									&#125; else &#123;</span><br><span class="line">										printf(&quot;←%d\t&quot;, dp[x][y]);</span><br><span class="line">									&#125;</span><br><span class="line">								&#125; else &#123;</span><br><span class="line">									if (dp[x - 1][y] + list[m[str1[x]]][m[&apos;-&apos;]]</span><br><span class="line">									        &gt;=</span><br><span class="line">									        dp[x][y - 1] + list[m[&apos;-&apos;]][m[str2[y]]]) &#123;</span><br><span class="line">										printf(&quot;↑%d\t&quot;, dp[x][y]);</span><br><span class="line">									&#125; else &#123;</span><br><span class="line">										printf(&quot;←%d\t&quot;, dp[x][y]);</span><br><span class="line"></span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">				*/</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">						printf(&quot;\n&quot;);</span><br><span class="line">			*/</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[len1][len2]);</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		*</span><br><span class="line">		*	in:</span><br><span class="line">		*</span><br><span class="line">		*	2</span><br><span class="line">		*	7 AGTGATG</span><br><span class="line">		*	5 GTTAG</span><br><span class="line">		*	7 AGCTATT</span><br><span class="line">		*	9 AGCTTTAAA</span><br><span class="line">		*</span><br><span class="line">		*	out:</span><br><span class="line">		*</span><br><span class="line">		*	↖0		←-2		←-3		←-4		←-7		←-9</span><br><span class="line">		*	↑-3		↖-2		↖-3		↖-4		↖1		←-1</span><br><span class="line">		*	↑-5		↖2		←1		←0		↑-1		↖6</span><br><span class="line">		*	↑-6		↑1		↖7		↖6		←3		↑5</span><br><span class="line">		*	↑-8		↖-1		↑5		↖5		↖4		↖8</span><br><span class="line">		*	↑-11	↑-4		↑2		↖4		↖10		←8</span><br><span class="line">		*	↑-12	↑-5		↖1		↖7		↑9		↖8</span><br><span class="line">		*	↑-14	↖-7		↑-1		↑5		↑7		↖14</span><br><span class="line">		*</span><br><span class="line">		*	14</span><br><span class="line">		*</span><br><span class="line">		*	↖0		←-3		←-5		←-9		←-10	←-11	←-12	←-15	←-18	←-21</span><br><span class="line">		*	↑-3		↖5		←3		←-1		←-2		←-3		←-4		↖-7		↖-10	↖-13</span><br><span class="line">		*	↑-5		↑3		↖10		←6		←5		←4		←3		←0		←-3		←-6</span><br><span class="line">		*	↑-9		↑-1		↑6		↖15		←14		←13		←12		←9		←6		←3</span><br><span class="line">		*	↑-10	↑-2		↑5		↑14		↖20		↖19		↖18		←15		←12		←9</span><br><span class="line">		*	↑-13	↖-5		↑2		↑11		↑17		↖19		↖18		↖23		↖20		↖17</span><br><span class="line">		*	↑-14	↑-6		↑1		↑10		↖16		↖22		↖24		↑22		↖22		↖19</span><br><span class="line">		*	↑-15	↑-7		↑0		↑9		↖15		↖21		↖27		←24		↖21		↖21</span><br><span class="line">		*</span><br><span class="line">		*</span><br><span class="line">		*	21</span><br><span class="line">		*</span><br><span class="line">		*</span><br><span class="line">		*</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HDU</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 1325 1272 并查集判断有向图和无向图是否构成一棵树型</title>
    <url>/blog/14/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1325" target="_blank" rel="noopener">HDU 1325</a><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1272" target="_blank" rel="noopener">HDU 1272</a></p>
<p>HDU 1325是有向图，给定某个节点是另一个元素的父节点<br>HDU 1272是无向图，将两个节点连接起来</p>
<p>共同点：判断是否成环，判断是树木还是森林</p>
<p>区别：有向图可能出现多个箭头指向同一个节点的情况（即一个节点多个父节点）<br>例如<br><img src="http://acm.hdu.edu.cn/data/images/1325-3.gif" alt="多节点指向同一节点"></p>
<p>另外，关于HDU 1272</p>
<p>评论区看到一种利用离散数学结论的解法<br>（对于无向图）<br>如果m个节点被连成环，那么边的条数就是 m<br>如果m个节点形成了n个树，那么边的条数就是 m - n<br>（这个动动笔画画就能明白）<br><a href="http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=28804&#038;messageid=1&#038;deep=0" target="_blank" rel="noopener">链接：这题目干嘛都用并查集做啊</a><br>那么按照题目要求：Yes的条件就是<br>1.边的条数 = 所有节点数 - 1<br>或<br>2.节点数为0</p>
<p>上代码：<br>HDU 1325<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">#define maxlen 200005</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//并查集实现</span><br><span class="line"></span><br><span class="line">int roots, ok;</span><br><span class="line"></span><br><span class="line">int fa[maxlen];</span><br><span class="line"></span><br><span class="line">// 这个栈和栈顶指针只是用来记录出现过的元素，用来清空fa数组用的，</span><br><span class="line">// 记录fa数组的哪些地方被用过了，</span><br><span class="line">// 完成一个示例以后就根据这个栈里面记录的位置来把fa数组里面对应的位置恢复成0</span><br><span class="line">// 之所以不用memset，是因为fa数组很大，不是所有部分都用上了，每次都把整个数组写0太浪费时间了</span><br><span class="line">int stack[maxlen];</span><br><span class="line">int top = -1;</span><br><span class="line"></span><br><span class="line">int find(int i) &#123;//非递归实现</span><br><span class="line">	int icopy = i;</span><br><span class="line">	while (i != fa[i]) &#123;//找到根元素</span><br><span class="line">		i = fa[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (icopy != fa[icopy]) &#123;</span><br><span class="line">		icopy = fa[icopy];//获取父节点</span><br><span class="line">		fa[icopy] = i;//挂到根节点下</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">	int a, b, t = 1;</span><br><span class="line"></span><br><span class="line">	int count = 0;</span><br><span class="line">	while (1) &#123;</span><br><span class="line"></span><br><span class="line">		ok = 1;</span><br><span class="line">		count = 0;</span><br><span class="line"></span><br><span class="line">		// memset(fa, 0, sizeof(fa));//每次都全部写0，耗时长，改为用栈记录修改过的位置</span><br><span class="line"></span><br><span class="line">		while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">			// a --&gt; b</span><br><span class="line">			// a是b的父节点</span><br><span class="line"></span><br><span class="line">			if (ok) &#123;</span><br><span class="line">				if (!fa[a]) &#123; //若a没有出现过,就初始化为自己</span><br><span class="line">					fa[a] = a;</span><br><span class="line">					count++;</span><br><span class="line"></span><br><span class="line">					top++;</span><br><span class="line">					stack[top] = a;</span><br><span class="line">					// printf(&quot;add\n&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				if (!fa[b]) &#123;</span><br><span class="line">					fa[b] = b;</span><br><span class="line"></span><br><span class="line">					top++;</span><br><span class="line">					stack[top] = b;</span><br><span class="line"></span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					if (fa[b] == b) &#123;</span><br><span class="line">						count--;</span><br><span class="line">						// printf(&quot;sub\n&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				if (fa[b] != b &amp;&amp; fa[b] != a) &#123;//若出现多指一,则不ok</span><br><span class="line">					ok = 0;</span><br><span class="line">					// printf(&quot;die 1\n&quot;);</span><br><span class="line">					continue;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					a = find(a);//把a换为a的根节点</span><br><span class="line">					if (b == a) &#123;//环</span><br><span class="line">						ok = 0;</span><br><span class="line">						// printf(&quot;die 2\n&quot;);</span><br><span class="line">						continue;</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						fa[b] = a;//直接挂在根节点</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (a &lt; 0 &amp;&amp; b &lt; 0) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ok) &#123;</span><br><span class="line">			if (count != 1) &#123;</span><br><span class="line">				ok = 0;</span><br><span class="line">				// printf(&quot;die 3\n&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case %d is %sa tree.\n&quot;, t, ok ? &quot;&quot; : &quot;not &quot;);</span><br><span class="line"></span><br><span class="line">		while (top != -1) &#123;</span><br><span class="line">			fa[stack[top]] = 0;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		t++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HDU 1272</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">#define maxlen 200005</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//并查集实现</span><br><span class="line">//虽然给的输入似乎是无向的，但最终我们构造的依然是一个有向的树，我们只要考虑是否会出现环和森林，所以这题和hdu1325性质相同</span><br><span class="line"></span><br><span class="line">int ok;</span><br><span class="line"></span><br><span class="line">int fa[maxlen];</span><br><span class="line"></span><br><span class="line">// 这个栈和栈顶指针只是用来记录出现过的元素，用来清空fa数组用的，</span><br><span class="line">// 记录fa数组的哪些地方被用过了，</span><br><span class="line">// 完成一个示例以后就根据这个栈里面记录的位置来把fa数组里面对应的位置恢复成0</span><br><span class="line">// 之所以不用memset，是因为fa数组很大，不是所有部分都用上了，每次都把整个数组写0太浪费时间了</span><br><span class="line">int stack[maxlen];</span><br><span class="line">int top = -1;</span><br><span class="line"></span><br><span class="line">int find(int i) &#123;//非递归实现</span><br><span class="line">	int icopy = i;</span><br><span class="line">	while (i != fa[i]) &#123;//找到根元素</span><br><span class="line">		i = fa[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (icopy != fa[icopy]) &#123;</span><br><span class="line">		icopy = fa[icopy];//获取父节点</span><br><span class="line">		fa[icopy] = i;//挂到根节点下</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">	int a, b;</span><br><span class="line"></span><br><span class="line">	int countOfRoots = 0;</span><br><span class="line">	while (1) &#123;</span><br><span class="line"></span><br><span class="line">		ok = 1;</span><br><span class="line">		countOfRoots = 0;</span><br><span class="line"></span><br><span class="line">		// memset(fa, 0, sizeof(fa));//每次都全部写0，耗时长，改为用栈记录修改过的位置</span><br><span class="line"></span><br><span class="line">		while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">			if (ok) &#123;</span><br><span class="line"></span><br><span class="line">				if (!fa[a]) &#123; //若a没有出现过,就初始化为自己</span><br><span class="line"></span><br><span class="line">					top++;</span><br><span class="line">					stack[top] = a;//所有出现过的节点都记录在stack中</span><br><span class="line"></span><br><span class="line">					if (!fa[b]) &#123;//若b也没有出现过</span><br><span class="line"></span><br><span class="line">						top++;</span><br><span class="line">						stack[top] = b;</span><br><span class="line"></span><br><span class="line">						//指定a为b的父节点,a为独立的根节点</span><br><span class="line"></span><br><span class="line">						fa[a] = a;</span><br><span class="line">						fa[b] = a;</span><br><span class="line">						countOfRoots++;//根节点数量+1</span><br><span class="line"></span><br><span class="line">					&#125; else &#123;//若b出现过</span><br><span class="line"></span><br><span class="line">						fa[a] = find(b);//把a直接挂到b的根节点下</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125; else &#123;//若a出现过</span><br><span class="line"></span><br><span class="line">					if (!fa[b]) &#123;//而b没出现过</span><br><span class="line"></span><br><span class="line">						top++;</span><br><span class="line">						stack[top] = b;</span><br><span class="line"></span><br><span class="line">						fa[b] = find(a);//把b直接挂到a的根节点下</span><br><span class="line">					&#125; else &#123;//b也出现过</span><br><span class="line"></span><br><span class="line">						if (find(a) == find(b)) &#123;//同一根节点</span><br><span class="line">							//成环</span><br><span class="line">							ok = 0;</span><br><span class="line">						&#125; else &#123;</span><br><span class="line">							// 把两个树合并</span><br><span class="line">							fa[find(a)] = find(b);</span><br><span class="line">							countOfRoots--;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (a &lt; 0 &amp;&amp; b &lt; 0) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (ok) &#123;</span><br><span class="line">			if (top != -1) &#123;//排除掉一个元素都没有的情况（空树）</span><br><span class="line">				if (countOfRoots != 1) &#123;</span><br><span class="line">					ok = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%s\n&quot;, ok ? &quot;Yes&quot; : &quot;No&quot;);</span><br><span class="line"></span><br><span class="line">		while (top != -1) &#123;</span><br><span class="line">			fa[stack[top]] = 0;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HDU</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 1166 敌兵布阵——线段树，树状数组</title>
    <url>/blog/13/</url>
    <content><![CDATA[<p>这题本来我打算用前缀数组实现源数据的处理，并把更变用map<int ,int="">实现，发现后来还是超时了；</int></p>
<p>借机学习了一下线段树，虽然没怎么看懂，但大概还是理解了一点；<br>这题用 指针构成的线段树 和 数组构成的线段树 分别来实现了一下<br>资料：<br>线段树从零开始 - CSDN博客<br><a href="http://blog.csdn.net/zearot/article/details/52280189" target="_blank" rel="noopener">http://blog.csdn.net/zearot/article/details/52280189</a><br>线段树详解 （原理，实现与应用） - CSDN博客<br><a href="http://blog.csdn.net/zearot/article/details/48299459" target="_blank" rel="noopener">http://blog.csdn.net/zearot/article/details/48299459</a><br>看到有人用树状数组实现，学习了一下树状数组，代码贴在最后：<br>资料：<br>树状数组入门<br><a href="https://www.cnblogs.com/hsd-/p/6139376.html" target="_blank" rel="noopener">https://www.cnblogs.com/hsd-/p/6139376.html</a></p>
<p>题目来源：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1166" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1166</a></p>
<blockquote>
<p>敌兵布阵<br>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 106625    Accepted Submission(s): 44789</p>
<p>Problem Description<br>C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。<br>中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.</p>
<p>Input<br>第一行一个整数T，表示有T组数据。<br>每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。<br>接下来每行有一条命令，命令有4种形式：<br>(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）<br>(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;<br>(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;<br>(4)End 表示结束，这条命令在每组数据最后出现;<br>每组数据最多有40000条命令</p>
<p>Output<br>对第i组数据,首先输出“Case i:”和回车,<br>对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。</p>
<p>Sample Input</p>
<p>1<br>10<br>1 2 3 4 5 6 7 8 9 10<br>Query 1 3<br>Add 3 6<br>Query 2 7<br>Sub 10 2<br>Add 6 3<br>Query 3 10<br>End </p>
<p>Sample Output</p>
<p>Case 1:<br>6<br>33<br>59</p>
<p>Author<br>Windbreaker</p>
<p>Recommend<br>Eddy   |   We have carefully selected several similar problems for you:  1394 1698 1754 1542 1540 </p>
</blockquote>
<p>指针线段树：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 线段树</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">	int lp;</span><br><span class="line">	int rp;</span><br><span class="line">	int mid;</span><br><span class="line">	int sum;</span><br><span class="line">	Node* left;</span><br><span class="line">	Node* right;</span><br><span class="line">	Node(int l, int r): lp(l), rp(r), mid((l + r) / 2), left(NULL), right(NULL) &#123;&#125;//new初始化的内存不一定自动填0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int list[50005];//从1开始</span><br><span class="line"></span><br><span class="line">int T, N, a, b;</span><br><span class="line"></span><br><span class="line">Node* buildTree(int l, int r) &#123;</span><br><span class="line">	Node* p = new Node(l, r);</span><br><span class="line">	if (l == r) &#123;</span><br><span class="line">		p-&gt;sum = list[l];</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;left = buildTree(l, p-&gt;mid);</span><br><span class="line">	p-&gt;right = buildTree(p-&gt;mid + 1, r);</span><br><span class="line"></span><br><span class="line">	p-&gt;sum = p-&gt;left-&gt;sum + p-&gt;right-&gt;sum;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void treeAdd(Node *which, int where, int what) &#123;</span><br><span class="line"></span><br><span class="line">	if (which-&gt;left != NULL &amp;&amp; which-&gt;right != NULL) &#123;</span><br><span class="line">		treeAdd((where &lt;= which-&gt;mid) ? which-&gt;left : which-&gt;right, where, what);</span><br><span class="line">	&#125;</span><br><span class="line">	which-&gt;sum += what;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int calSum(Node * which, int from, int to) &#123;</span><br><span class="line"></span><br><span class="line">	if (from == which-&gt;lp &amp;&amp; to == which-&gt;rp) &#123;</span><br><span class="line">		return which-&gt;sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (from &lt;= which-&gt;mid) &#123;</span><br><span class="line">		if (to &gt; which-&gt;mid) &#123;//横跨</span><br><span class="line">			return calSum(which-&gt;left, from, which-&gt;mid) + calSum(which-&gt;right, which-&gt;mid + 1, to);</span><br><span class="line">		&#125; else &#123;//全在左边</span><br><span class="line">			return calSum(which-&gt;left, from, to);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;//全在右边</span><br><span class="line">		return calSum(which-&gt;right, from, to);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void del(Node * which) &#123;</span><br><span class="line">	if (which-&gt;left) &#123;</span><br><span class="line">		del(which-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	if (which-&gt;right) &#123;</span><br><span class="line">		del(which-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	delete which;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	char cmd[10];</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line"></span><br><span class="line">	for (int t = 1; t &lt;= T; t++) &#123;</span><br><span class="line"></span><br><span class="line">		memset(list, 0, sizeof(list));</span><br><span class="line"></span><br><span class="line">		scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, list + i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Node* root = buildTree(0, N - 1);</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case %d:\n&quot;, t);</span><br><span class="line">		while (1) &#123;</span><br><span class="line">			scanf(&quot;%s&quot;, cmd);</span><br><span class="line">			if (&apos;E&apos; == cmd[0]) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">			switch (cmd[0]) &#123;</span><br><span class="line">			case &apos;Q&apos;:</span><br><span class="line">				printf(&quot;%d\n&quot;, calSum(root, a - 1, b - 1));</span><br><span class="line">				break;</span><br><span class="line">			case &apos;A&apos;:</span><br><span class="line">				list[a - 1] += b;</span><br><span class="line">				treeAdd(root, a - 1, b);</span><br><span class="line">				break;</span><br><span class="line">			case &apos;S&apos;:</span><br><span class="line">				list[a - 1] -= b;</span><br><span class="line">				treeAdd(root, a - 1, -b);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		del(root);</span><br><span class="line">		root = NULL;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义结构体组成的数组实现线段树：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 线段树</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">	int lp;</span><br><span class="line">	int rp;</span><br><span class="line">	int mid;</span><br><span class="line">	int sum;</span><br><span class="line">&#125; nodes[50005 &lt;&lt; 2];//空间为原数组的四倍长，1储存根元素，对于第k个节点，K&lt;&lt;1表示左支，(k&lt;&lt;1)|1表示右支</span><br><span class="line"></span><br><span class="line">int list[50005];//从0开始</span><br><span class="line"></span><br><span class="line">int T, N, a, b;</span><br><span class="line"></span><br><span class="line">int buildTree(int which, int l, int r) &#123;</span><br><span class="line"></span><br><span class="line">	nodes[which].lp = l;</span><br><span class="line">	nodes[which].rp = r;</span><br><span class="line">	nodes[which].mid = ((l + r) &gt;&gt; 1);</span><br><span class="line"></span><br><span class="line">	if (l == r) &#123;</span><br><span class="line">		nodes[which].sum = list[l];</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		nodes[which].sum += buildTree(which &lt;&lt; 1, l, (l + r) &gt;&gt; 1);</span><br><span class="line">		nodes[which].sum += buildTree((which &lt;&lt; 1) | 1, ((l + r) &gt;&gt; 1) + 1, r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return nodes[which].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void treeAdd(int which, int where, int what) &#123;</span><br><span class="line"></span><br><span class="line">	if (nodes[which].lp != nodes[which].rp) &#123;</span><br><span class="line">		treeAdd((where &lt;= nodes[which].mid) ? which &lt;&lt; 1 : (which &lt;&lt; 1) | 1, where, what);</span><br><span class="line">	&#125;</span><br><span class="line">	nodes[which].sum += what;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int calSum(int which, int from, int to) &#123;</span><br><span class="line"></span><br><span class="line">	// printf(&quot;from_%d,to_%d,and_now_is_%d,%d\n&quot;, from, to, nodes[which].lp, nodes[which].rp);</span><br><span class="line">	if (from == nodes[which].lp &amp;&amp; to == nodes[which].rp) &#123;</span><br><span class="line">		return nodes[which].sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (from &lt;= nodes[which].mid) &#123;</span><br><span class="line">		if (to &gt; nodes[which].mid) &#123;//横跨</span><br><span class="line">			return calSum(which &lt;&lt; 1, from, nodes[which].mid) + calSum((which &lt;&lt; 1) | 1, nodes[which].mid + 1, to);</span><br><span class="line">		&#125; else &#123;//全在左边</span><br><span class="line">			return calSum(which &lt;&lt; 1, from, to);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;//全在右边</span><br><span class="line">		return calSum((which &lt;&lt; 1) | 1, from, to);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	char cmd[10];</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line"></span><br><span class="line">	for (int t = 1; t &lt;= T; t++) &#123;</span><br><span class="line"></span><br><span class="line">		memset(list, 0, sizeof(list));</span><br><span class="line">		memset(nodes, 0, sizeof(nodes));</span><br><span class="line"></span><br><span class="line">		scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, list + i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		buildTree(1, 0, N - 1);</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case %d:\n&quot;, t);</span><br><span class="line">		while (1) &#123;</span><br><span class="line">			scanf(&quot;%s&quot;, cmd);</span><br><span class="line">			if (&apos;E&apos; == cmd[0]) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">			switch (cmd[0]) &#123;</span><br><span class="line">			case &apos;Q&apos;:</span><br><span class="line">				printf(&quot;%d\n&quot;, calSum(1, a - 1, b - 1));</span><br><span class="line">				break;</span><br><span class="line">			case &apos;A&apos;:</span><br><span class="line">				list[a - 1] += b;</span><br><span class="line">				treeAdd(1, a - 1, b);</span><br><span class="line">				break;</span><br><span class="line">			case &apos;S&apos;:</span><br><span class="line">				list[a - 1] -= b;</span><br><span class="line">				treeAdd(1, a - 1, -b);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>树状数组实现：代码量超少！！！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">//Accept</span><br><span class="line"></span><br><span class="line">#define lowbit(x) (x&amp;(-x))</span><br><span class="line"></span><br><span class="line">//lowbit(x) 其实代表了第x号节点最底层代表的区间长度</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*	c[x]</span><br><span class="line">*															1000</span><br><span class="line">*							   /————————————————————————————[8]</span><br><span class="line">*							  /								 |</span><br><span class="line">*							100								 |</span><br><span class="line">*			   /————————————[4]				   /————————————[ ]</span><br><span class="line">*			  /				 |				  /				 |</span><br><span class="line">*			010				 |				110				 |</span><br><span class="line">*	   /————[2]		   /————[ ]		   /————[6]		   /————[ ]</span><br><span class="line">*	  /		 |		  /		 |		  /		 |		  /		 |</span><br><span class="line">*	001		 |		011		 |		101		 |		111		 |</span><br><span class="line">*	[1]		[ ]		[3]		[ ]		[5]		[ ]		[7]		[ ]</span><br><span class="line">*/</span><br><span class="line">int c[50005];//树状数组,从1开始</span><br><span class="line">// c[i] = data[i - 2 ^ k + 1 ... i];</span><br><span class="line"></span><br><span class="line">int data[50005];//存储原始数据,从1开始</span><br><span class="line"></span><br><span class="line">int s[50005];//前缀数组,在init时用到,从1开始</span><br><span class="line"></span><br><span class="line">int T, N, a, b;</span><br><span class="line"></span><br><span class="line">int calSum(int where) &#123;//返回从data[1...where]</span><br><span class="line">	int su = 0;</span><br><span class="line">	while (where) &#123;</span><br><span class="line">		su += c[where];</span><br><span class="line">		where -= lowbit(where);</span><br><span class="line">	&#125;</span><br><span class="line">	return su;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int where, int what) &#123;</span><br><span class="line">	while (where &lt;= N) &#123;</span><br><span class="line">		c[where] += what;</span><br><span class="line">		where += lowbit(where);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int init() &#123;</span><br><span class="line">	int sum = 0;</span><br><span class="line">	// for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">	// 	for (int x = i - lowbit(i) + 1; x &lt;= i; x++) &#123;</span><br><span class="line">	// 		c[i] += data[x];</span><br><span class="line">	// 	&#125;</span><br><span class="line">	// &#125;</span><br><span class="line">	// 用前缀数组来进行优化：</span><br><span class="line">	for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">		c[i] = s[i] - s[i - lowbit(i)];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	char cmd[10];</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line"></span><br><span class="line">	for (int t = 1; t &lt;= T; t++) &#123;</span><br><span class="line"></span><br><span class="line">		memset(c, 0, sizeof(c));</span><br><span class="line">		memset(data, 0, sizeof(data));</span><br><span class="line">		memset(s, 0, sizeof(s));</span><br><span class="line"></span><br><span class="line">		scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line"></span><br><span class="line">		for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, data + i);</span><br><span class="line">			s[i] = s[i - 1] + data[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		init();</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case %d:\n&quot;, t);</span><br><span class="line">		for (;;) &#123;</span><br><span class="line">			scanf(&quot;%s&quot;, cmd);</span><br><span class="line">			if (&apos;E&apos; == cmd[0]) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">			switch (cmd[0]) &#123;</span><br><span class="line">			case &apos;Q&apos;:</span><br><span class="line">				printf(&quot;%d\n&quot;, calSum(b) - calSum(a - 1));</span><br><span class="line">				break;</span><br><span class="line">			case &apos;A&apos;:</span><br><span class="line">				add(a, b);</span><br><span class="line">				break;</span><br><span class="line">			case &apos;S&apos;:</span><br><span class="line">				add(a, -b);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 2089的类似题（62换成了38） 数位dp解释</title>
    <url>/blog/15/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.nowcoder.com/acm/contest/74/G" target="_blank" rel="noopener">链接</a><br>来源：牛客网</p>
<p>杭州人称傻乎乎的人为62，而嘟嘟家这里没有这样的习俗。</p>
<p>相比62，他那里的人更加讨厌数字38，当然啦，还有4这个</p>
<p>数字！所以啊，嘟嘟不点都不想见到包含38或者4的数字。</p>
<p>每次给出一个区间[n，m],你能找到所有令人讨厌的数字吗？</p>
<p>输入描述:</p>
<p>多组输入输出；<br>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），<br>如果遇到都是0的整数对，则输入结束。</p>
<p>输出描述:</p>
<p>对于每次的输入<br>输出全部令人讨厌的数的个数</p>
<p>示例1<br>输入</p>
<p>1 100<br>0 0</p>
<p>输出</p>
<p>20</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std ;</span><br><span class="line">const int len = 7 ;</span><br><span class="line">int dp[8][10] , bit[8] ;//全局变量初始为0，dp[x][y]数组表示长为x的以y打头的所有数中“合法”数的个数，</span><br><span class="line">// 注意首位为0的数也看作x位，例如0123看作4位数，</span><br><span class="line">// 原因：如果不考虑以0开头的数那么dp[3][3] = dp[2][9] + dp[2][8] + ...+ dp[2][2] + dp [2][1] + dp[1][9] + dp[1][8] + ... + dp[1][2] + dp[1][1]</span><br><span class="line">// 若把所有一位数看作以0开头的2位数则实际上dp[3][3] = dp[2][9] + dp[2][8] + ...+ dp[2][2] + dp [2][1] + dp[2][0]</span><br><span class="line">// 所以认为dp[x][0] = dp[x-1][0...9]</span><br><span class="line">// 我们只需要把dp[2][0...9]这些加起来就好了</span><br><span class="line">int n , m ;</span><br><span class="line"></span><br><span class="line">void Get_dp() &#123;</span><br><span class="line">	dp[0][0] = 1 ;</span><br><span class="line">	for ( int i = 1 ; i &lt;= len ; ++i )//长度i从1到7</span><br><span class="line">		for ( int j = 0 ; j &lt;= 9 ; ++j )//数值j从0到9</span><br><span class="line">			if ( j != 4 )//排除j等于4的情况</span><br><span class="line">				for ( int k = 0 ; k &lt;= 9 ; ++k )//第二个数值k从0到9</span><br><span class="line">					if ( !( j == 3 &amp;&amp; k == 8 ) )//排除j，k为3，8的情况</span><br><span class="line">						dp[i][j] += dp[i - 1][k] ;//i从1开始所以i-1不会越界且由于是全局变量默认值为0，所以免去了对i-1是否越界的讨论</span><br><span class="line"></span><br><span class="line">					/**</span><br><span class="line">					* 从长为1位的数，开头的数从0到9，填表</span><br><span class="line">					* 状态转移方程：</span><br><span class="line">					* dp[x][y] = 0;	若y==4</span><br><span class="line">					* 			dp[x-1][0...9];	若y!=3（相当于在所有x-1位的合法数前面加了个不是3的数，肯定也是合法数）</span><br><span class="line">					* 			dp[x-1][0...9] - dp[x-1][8];	若y==3则要排除掉第二位为8的情况</span><br><span class="line">					*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int solve( int n ) &#123;//根据表来得出从1到n（实际上没有包括n，因为下面有一句for ( int j = 0 ; j &lt; bit[i] ; ++j )用的小于号，我们先不考虑这细节）的所有合法数的个数</span><br><span class="line">	memset( bit , 0 , sizeof( bit ) ) ;//将n分解放入bit数组中</span><br><span class="line">	int top = 0 ;//（从n的底位到高位倒序放入）</span><br><span class="line">	while ( n ) &#123;</span><br><span class="line">		bit[++top] = n % 10 ;</span><br><span class="line">		n /= 10 ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int ans = 0 ;//保存所有合法数个数</span><br><span class="line">	for ( int i = len ; i &gt;= 1 ; --i ) &#123;//i从数的最高位开始向下</span><br><span class="line">		for ( int j = 0 ; j &lt; bit[i] ; ++j )</span><br><span class="line">			if ( !( bit[i + 1] == 3 &amp;&amp; j == 8 ) )</span><br><span class="line">				ans += dp[i][j] ;//排除上一位是3且这一位以8开头的情况</span><br><span class="line">		if ( bit[i] == 4 || ( bit[i + 1] == 3 &amp;&amp; bit[i] == 8 ) )</span><br><span class="line">			break ;//若这一位是4则跳出循环</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	* 这里举个例子解释一下：</span><br><span class="line">	* 假设输入n为243</span><br><span class="line">	* 那么我们应该将1...243分解成		000...199		200...239 		240...242				243</span><br><span class="line">	* 对应一下其实就是				dp[3][0...1]	dp[2][0...3]	dp[1][0...2]			dp[0][]恒为0（所以代码中不管数字n是否合法都没有考虑到，最终返回值其实是1...n-1的所有合法数个数）</span><br><span class="line">	* 注解							(1)				(2)				(3)不合法，之后的也是		(4)不合法</span><br><span class="line">	* </span><br><span class="line">	* (1)从最高位开始</span><br><span class="line">	* (2)00...39中的所有合法数前面加一个2还是合法数</span><br><span class="line">	* (3)0...2的前面加上一个4出问题了！！，所有的0...2中的合法数变得不合法,应该排除,接下来所以位的分解前面也会加上4，所以直接跳出循环</span><br><span class="line">	*	if ( bit[i] == 4 || ( bit[i + 1] == 3 &amp;&amp; bit[i] == 8 ) )</span><br><span class="line">	* 		break ;//若这一位是4则跳出循环</span><br><span class="line">	* (4)这里为什么单独分开来？提示：“小于”号“&lt;”</span><br><span class="line">	* </span><br><span class="line">	* 其实这些分法都是受到了上面的：</span><br><span class="line">	* for ( int j = 0 ; j &lt; bit[i] ; ++j )</span><br><span class="line">	* 的影响（注意小于号），也就是按照这条语句来分的</span><br><span class="line">	* 需要仔细想想</span><br><span class="line">	*/</span><br><span class="line">	return ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Get_dp() ;//打表</span><br><span class="line">	while ( cin &gt;&gt; n &gt;&gt; m &amp;&amp; ( n || m ) )</span><br><span class="line">		cout &lt;&lt; m - n + 1 - ( solve( m + 1 ) - solve( n ) ) &lt;&lt; endl ;</span><br><span class="line">	return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 2577 How To Type 动态规划</title>
    <url>/blog/16/</url>
    <content><![CDATA[<blockquote>
<p>How to Type</p>
<p>  Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p>
<p>  Total Submission(s): 7448    Accepted Submission(s): 3374</p>
<p>  Problem Description</p>
<p>  Pirates have finished developing the typing software. He called Cathy to test his typing software. She is good at thinking. After testing for several days, she finds that if she types a string by some ways, she will type the key at least. But she has a bad habit that if the caps lock is on, she must turn off it, after she finishes typing. Now she wants to know the smallest times of typing the key to finish typing a string.</p>
<p>  Input</p>
<p>  The first line is an integer t (t&lt;=100), which is the number of test case in the input file. For each test case, there is only one string which consists of lowercase letter and upper case letter. The length of the string is at most 100.</p>
<p>  Output</p>
<p>  For each test case, you must output the smallest times of typing the key to finish typing this string.</p>
<p>  Sample Input</p>
<p>  3</p>
<p>  Pirates</p>
<p>  HDUacm</p>
<p>  HDUACM</p>
<p>  Sample Output</p>
<p>  8</p>
<p>  8</p>
<p>  8</p>
<p>  Hint</p>
<p>  The string “Pirates”, can type this way, Shift, p, i, r, a, t, e, s, the answer is 8.</p>
<p>  The string “HDUacm”, can type this way, Caps lock, h, d, u, Caps lock, a, c, m, the answer is 8</p>
<p>  The string “HDUACM”, can type this way Caps lock h, d, u, a, c, m, Caps lock, the answer is 8</p>
<p>  Author</p>
<p>  Dellenge</p>
<p>  Source</p>
<p>  HDU 2009-5 Programming Contest</p>
<p>  Recommend</p>
<p>  lcy</p>
</blockquote>
<p><strong>输入每个字符前的状态是：</strong><br><strong>大小写锁开启on或者关闭off</strong></p>
<p><strong><em>注意开启锁时按shift可以输入小写</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isup</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &amp;gt;= <span class="string">'A'</span> &amp;amp;&amp;amp; a &amp;lt;= <span class="string">'Z'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">int</span> off[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">int</span> on[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> capsLock = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, data);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">// 每次输入之前锁有两种状态</span></span><br><span class="line">        off[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//表示输入第i个字符前状态为off/on的按键最少次数</span></span><br><span class="line">        on[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; data[i] != <span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isup(data[i])) &#123;</span><br><span class="line">                <span class="comment">// 输入大写字母以后锁：on</span></span><br><span class="line">                <span class="comment">// 直接输入，按下caps再输入（原先锁off）</span></span><br><span class="line">                on[i + <span class="number">1</span>] = min(on[i] + <span class="number">1</span>, off[i] + <span class="number">2</span>);</span><br><span class="line">                <span class="comment">// 输入大写字母以后锁：off</span></span><br><span class="line">                <span class="comment">// 按下caps再输入（原先锁on）,按shift输入</span></span><br><span class="line">                off[i + <span class="number">1</span>] = min(on[i] + <span class="number">2</span>, off[i] + <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                on[i + <span class="number">1</span>] = min(on[i] + <span class="number">2</span>, off[i] + <span class="number">2</span>);</span><br><span class="line">                off[i + <span class="number">1</span>] = min(on[i] + <span class="number">2</span>, off[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(on[i] + <span class="number">1</span>, off[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 2586 How far away ？——树上节点最短距离，LCA， 双亲表示法+暴力从下至上追溯，孩子链表示法+（Tarjan 或 欧拉环游RMQ+（ST 或 SegmentTree））</title>
    <url>/blog/17/</url>
    <content><![CDATA[<p>标题真长。。。</p>
<p>HDU 2586 How far away ？——树上节点最短距离，LCA， 双亲表示法+暴力从下至上追溯，孩子链表示法+（Tarjan 或 欧拉环游RMQ+（ST 或 SegmentTree））</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2586" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2586</a></p>
<h2 id="四种解法："><a href="#四种解法：" class="headerlink" title="四种解法："></a>四种解法：</h2><p>- 双亲表示法+暴力从下至上追溯<br>- 孩子链表示法+Tarjan<br>- 孩子链表示法+欧拉环游RMQ+ST<br>- 孩子链表示法+欧拉环游RMQ+SegmentTree</p>
<h2 id="对于建树的问题，要解决父节点和子节点的问题："><a href="#对于建树的问题，要解决父节点和子节点的问题：" class="headerlink" title="对于建树的问题，要解决父节点和子节点的问题："></a>对于建树的问题，要解决父节点和子节点的问题：</h2><p>- 第一种解法中，双亲表示法，用一个一维数组houses来储存所有节点，houses[x].fa表示该节点的父节点，当两个子树被合并造成冲突时，将其中一棵树倒置</p>
<p>如：</p>
<blockquote>
<p>1    2<br>↑    ↑<br>3    4<br>↑    ↑<br>5    6</p>
</blockquote>
<p>此时要连接3和4，必定会造成冲突，因为，若将3作为4的父节点（3 → 4），4就会有两个父节点，于是把4 ← 6这一支倒置成 4 → 6<br>于是：</p>
<blockquote>
<p>1    2<br>↑    ↑<br>3  → 4<br>↑    ↓<br>5    6<br>（5成为合并以后的根元素）</p>
</blockquote>
<p>- 剩下三种解法则利用孩子链表示法，记录所有与目标节点相连接的节点（包括一个父节点和一个子节点），然后随便选取一个节点作为父节点，用dfs遍历这些连接的节点，同时用visited数组来跳过其中的父节点</p>
<h1 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//31ms</span><br><span class="line"></span><br><span class="line">//双亲表示法</span><br><span class="line"></span><br><span class="line">//当建树遇到冲突时，将冲突的一支树倒置</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">	int disToFa;</span><br><span class="line">	int fa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node houses[40005];</span><br><span class="line">int visited[40005];</span><br><span class="line"></span><br><span class="line">void add(int x, int y, int z) &#123;</span><br><span class="line">	if (!houses[x].fa) &#123;//若x还没有父元素</span><br><span class="line">		//把x挂在y下</span><br><span class="line">		houses[x].fa = y;</span><br><span class="line">		houses[x].disToFa = z;</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line"></span><br><span class="line">		if (!houses[y].fa) &#123; //若y还没有父元素</span><br><span class="line">			//把y挂在x下</span><br><span class="line">			houses[y].fa = x;</span><br><span class="line">			houses[y].disToFa = z;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			//x和y都有父元素了</span><br><span class="line"></span><br><span class="line">			//将x的父元素向上追溯全部变成子元素（将这一支箭头全部倒置）</span><br><span class="line"></span><br><span class="line">			//修改前的副本</span><br><span class="line">			Node temp_x = houses[x];</span><br><span class="line">			Node temp_x_fa = houses[temp_x.fa];</span><br><span class="line"></span><br><span class="line">			//把x挂在y下</span><br><span class="line">			houses[x].fa = y;</span><br><span class="line">			houses[x].disToFa = z;</span><br><span class="line"></span><br><span class="line">			while (temp_x_fa.fa) &#123;</span><br><span class="line"></span><br><span class="line">				houses[temp_x.fa].disToFa = temp_x.disToFa;</span><br><span class="line">				houses[temp_x.fa].fa = x;</span><br><span class="line"></span><br><span class="line">				x = temp_x.fa;</span><br><span class="line">				temp_x = houses[x];</span><br><span class="line">				temp_x_fa = houses[temp_x.fa];</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cal(int x, int y) &#123;</span><br><span class="line">//先从x开始一直追溯到根节点，沿途标记所有经过的节点（visited数组两个作用，一是用来标记是否访问过，二是用来记录从x节点出发以后走过的距离）</span><br><span class="line">	int sum_x = 0;</span><br><span class="line">	visited[x] = -1;</span><br><span class="line"></span><br><span class="line">	sum_x += houses[x].disToFa;</span><br><span class="line">	x = houses[x].fa;</span><br><span class="line"></span><br><span class="line">	while (houses[x].fa) &#123;//当未到树顶时</span><br><span class="line">		visited[x] = sum_x;</span><br><span class="line">		sum_x += houses[x].disToFa;</span><br><span class="line">		x = houses[x].fa;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//此时x是树顶</span><br><span class="line">	if (visited[x] != -1) &#123;</span><br><span class="line">		visited[x] = sum_x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//接下来从y开始向上追溯</span><br><span class="line">	int sum_y = 0;</span><br><span class="line">	while (!visited[y]) &#123;</span><br><span class="line">		sum_y += houses[y].disToFa;</span><br><span class="line">		y = houses[y].fa;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//根据之前留下的-1判断原始的x是否为y的父元素</span><br><span class="line">	if (visited[y] == -1) &#123;//这种情况表明y向上追溯的过程中遇到了x</span><br><span class="line">		return sum_y;//直接返回y向上追溯到x的距离</span><br><span class="line">	&#125; else &#123;//这种情况表明y追溯到了x的某一个祖先元素</span><br><span class="line">		return sum_y + visited[y];//返回y向上追溯到x的距离 + 从x到这个祖先元素的距离</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int T, n, m, cp_n, a1, a2, a3;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">		cp_n = n;</span><br><span class="line"></span><br><span class="line">		memset(houses, 0, sizeof(Node) * (n + 1));</span><br><span class="line"></span><br><span class="line">		while (--n) &#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;a2, &amp;a3);</span><br><span class="line"></span><br><span class="line">			add(a1, a2, a3);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		while (m--) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a1, &amp;a2);</span><br><span class="line"></span><br><span class="line">			memset(visited, 0, sizeof(int) * (cp_n + 1));//每处理一个问题前刷新一次</span><br><span class="line"></span><br><span class="line">			printf(&quot;%d\n&quot;, cal(a1, a2));</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//31ms</span><br><span class="line">//Tarjan</span><br><span class="line"></span><br><span class="line">//孩子链表示法(链表)</span><br><span class="line">//这里的孩子不一定是子节点，可能还有一个父节点，但是可以用visited数组来区别</span><br><span class="line">//随便选取一个hand作为根节点，就可以建成一棵树</span><br><span class="line"></span><br><span class="line">int hand[40005];//保存第x号房子的所有孩子节点链表的起始节点编号</span><br><span class="line"></span><br><span class="line">struct Node//链表节点</span><br><span class="line">&#123;</span><br><span class="line">	int distance;//权值</span><br><span class="line">	int to;</span><br><span class="line">	int next;//保存下一个Node的位置（并非指房子的编号，是节点的编号），即孩子组成的链表中的下一个节点的位置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node nodes[40005 &lt;&lt; 1];//需要两倍空间</span><br><span class="line">int pos;//pos为nodes的当前可用的Node的位置编号</span><br><span class="line">int disToRoot[40005];//代表到根节点的距离</span><br><span class="line">// 结果 = disToRoot[x] + disToRoot[y] - 2 * disToRoot[LCA(x, y)]</span><br><span class="line"></span><br><span class="line">//Tarjan</span><br><span class="line">int fa[40005];</span><br><span class="line">int visited[40005];</span><br><span class="line">int qhand[40005];</span><br><span class="line">Node ques[40005 &lt;&lt; 1];</span><br><span class="line">int qpos;</span><br><span class="line"></span><br><span class="line">void addToTree(int x, int y, int z) &#123;//表示为x号房子添加一个子节点 y ,距离为z</span><br><span class="line">	//为pos号节点写入数据</span><br><span class="line">	nodes[pos].to = y;</span><br><span class="line">	nodes[pos].distance = z;</span><br><span class="line">	nodes[pos].next = hand[x];</span><br><span class="line">	hand[x] = pos;</span><br><span class="line"></span><br><span class="line">	pos++;//当前可用的节点编号+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addToQue(int x, int y) &#123;</span><br><span class="line">	ques[qpos].to = y;</span><br><span class="line">	ques[qpos].distance = 0;</span><br><span class="line">	ques[qpos].next = qhand[x];</span><br><span class="line">	qhand[x] = qpos;</span><br><span class="line"></span><br><span class="line">	qpos++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int tarjanFind(int x) &#123;//并查集查找（非递归压缩路径）</span><br><span class="line">	int cp_x = x;</span><br><span class="line">	while (fa[x] != x) &#123;</span><br><span class="line">		x = fa[x];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (fa[cp_x] != cp_x) &#123;</span><br><span class="line">		cp_x = fa[cp_x];</span><br><span class="line">		fa[cp_x] = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tarjan(int which) &#123;</span><br><span class="line"></span><br><span class="line">	visited[which] = 1;</span><br><span class="line"></span><br><span class="line">	fa[which] = which;</span><br><span class="line"></span><br><span class="line">	int childPos = hand[which];</span><br><span class="line"></span><br><span class="line">	while (childPos) &#123;</span><br><span class="line"></span><br><span class="line">		if (visited[nodes[childPos].to]) &#123;//跳过父元素</span><br><span class="line">			childPos = nodes[childPos].next;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		disToRoot[nodes[childPos].to] = disToRoot[which] + nodes[childPos].distance;//写入到根节点的距离</span><br><span class="line">		tarjan(nodes[childPos].to);</span><br><span class="line"></span><br><span class="line">		fa[nodes[childPos].to] = which;</span><br><span class="line"></span><br><span class="line">		childPos = nodes[childPos].next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//处理询问</span><br><span class="line">	int quesPos = qhand[which];</span><br><span class="line"></span><br><span class="line">	while (quesPos) &#123;</span><br><span class="line"></span><br><span class="line">		if (visited[ques[quesPos].to]) &#123;</span><br><span class="line">			ques[quesPos].distance = disToRoot[which] + disToRoot[ques[quesPos].to] - 2 * disToRoot[tarjanFind(ques[quesPos].to)];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		quesPos = ques[quesPos].next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int T, n, m, a1, a2, a3;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">		memset(hand, 0, sizeof(int) * (n + 1));</span><br><span class="line">		memset(qhand, 0, sizeof(int) * (n + 1));</span><br><span class="line">		memset(visited, 0, sizeof(int) * (n + 1));</span><br><span class="line"></span><br><span class="line">		pos = 1;</span><br><span class="line"></span><br><span class="line">		while (--n) &#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;a2, &amp;a3);</span><br><span class="line"></span><br><span class="line">			addToTree(a1, a2, a3);</span><br><span class="line">			addToTree(a2, a1, a3);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		qpos = 1;</span><br><span class="line"></span><br><span class="line">		//离线算法（先收集所有问题，然后统一遍历）</span><br><span class="line">		while (m--) &#123;</span><br><span class="line"></span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a1, &amp;a2);</span><br><span class="line"></span><br><span class="line">			//建立链表的方法和上面建树的方法类似</span><br><span class="line">			addToQue(a1, a2);</span><br><span class="line">			addToQue(a2, a1);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		disToRoot[1] = 0;</span><br><span class="line">		tarjan(1);</span><br><span class="line"></span><br><span class="line">		for (int i = 1; i &lt; qpos; i += 2) &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, ques[i].distance ? ques[i].distance : ques[i + 1].distance);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解法3："><a href="#解法3：" class="headerlink" title="解法3："></a>解法3：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//46ms</span><br><span class="line">//转化为RMQ问题_ST</span><br><span class="line">//在线算法</span><br><span class="line"></span><br><span class="line">//孩子链表示法(链表)</span><br><span class="line">//这里的孩子不一定是子节点，可能还有一个父节点，但是可以用visited数组来区别</span><br><span class="line">//随便选取一个hand作为根节点，就可以建成一棵树</span><br><span class="line"></span><br><span class="line">int hand[40005];//保存第x号房子的所有孩子节点链表的起始节点编号</span><br><span class="line"></span><br><span class="line">struct Node//链表节点</span><br><span class="line">&#123;</span><br><span class="line">	int distance;//权值</span><br><span class="line">	int to;</span><br><span class="line">	int next;//保存下一个Node的位置（并非指房子的编号，是节点的编号），即孩子组成的链表中的下一个节点的位置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node nodes[40005 &lt;&lt; 1];//需要两倍空间</span><br><span class="line"></span><br><span class="line">int pos;//pos为nodes的当前可用的Node的位置编号</span><br><span class="line">int disToRoot[40005];//代表到根节点的距离</span><br><span class="line">// 结果 = disToRoot[x] + disToRoot[y] - 2 * disToRoot[LCA(x, y)]</span><br><span class="line"></span><br><span class="line">//RMQ</span><br><span class="line">int rmq_which[40005 &lt;&lt; 1];//RMQ数组长度约为节点数的两倍（实际上是2n-1），储存欧拉环游经过的所有节点号</span><br><span class="line">int rmq_deep[40005 &lt;&lt; 1];//储存环游中节点的深度</span><br><span class="line">int rmq_first[40005];//储存循环中 x 号节点（房子）第一次出现的位置</span><br><span class="line">int rmq_pos;</span><br><span class="line"></span><br><span class="line">int visited[40005];//排除父节点</span><br><span class="line"></span><br><span class="line">//ST</span><br><span class="line">int st[40005 &lt;&lt; 1][18]; //2的17次方大于 40005</span><br><span class="line">// st[x][y] = 代表rmq_deep数组中从x开始持续长为（2的y次方）长的区间范围内的最小deep 的位置</span><br><span class="line"></span><br><span class="line">void addToTree(int x, int y, int z) &#123;//表示为x号房子添加一个子节点 y ,距离为z</span><br><span class="line">	//为pos号节点写入数据</span><br><span class="line">	nodes[pos].to = y;</span><br><span class="line">	nodes[pos].distance = z;</span><br><span class="line">	nodes[pos].next = hand[x];</span><br><span class="line">	hand[x] = pos;</span><br><span class="line"></span><br><span class="line">	pos++;//当前可用的节点编号+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* rmq函数用欧拉环游生成了rmq_which 和 rmq_deep 和 rmq_first 和 disToRoot 四个数组</span><br><span class="line">*/</span><br><span class="line">void rmq(int which, int deep) &#123;</span><br><span class="line">	visited[which] = 1;</span><br><span class="line"></span><br><span class="line">	rmq_which[rmq_pos] = which;</span><br><span class="line">	rmq_deep[rmq_pos] = deep;</span><br><span class="line">	rmq_first[which] = rmq_pos;</span><br><span class="line">	rmq_pos++;</span><br><span class="line"></span><br><span class="line">	int childPos = hand[which];</span><br><span class="line"></span><br><span class="line">	while (childPos) &#123;</span><br><span class="line">		if (visited[nodes[childPos].to]) &#123;</span><br><span class="line">			childPos = nodes[childPos].next;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		disToRoot[nodes[childPos].to] = disToRoot[which] + nodes[childPos].distance;</span><br><span class="line"></span><br><span class="line">		rmq(nodes[childPos].to, deep + 1);</span><br><span class="line"></span><br><span class="line">		rmq_which[rmq_pos] = which;</span><br><span class="line">		rmq_deep[rmq_pos] = deep;</span><br><span class="line">		rmq_pos++;</span><br><span class="line"></span><br><span class="line">		childPos = nodes[childPos].next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化st数组</span><br><span class="line">void init_st() &#123;</span><br><span class="line">	for (int i = 0; i &lt; rmq_pos; ++i) &#123;//根据st的定义，y为0时，st[i][0] = i;</span><br><span class="line">		st[i][0] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int y = 1 ; y &lt; 18; ++y) &#123;</span><br><span class="line">		for (int i = 0; i + (1 &lt;&lt; y) - 1 &lt; rmq_pos; ++i) &#123;</span><br><span class="line">			st[i][y] =	rmq_deep[st[i][y - 1]] &lt; rmq_deep[st[i + (1 &lt;&lt; (y - 1))][y - 1]] ? st[i][y - 1] : st[i + (1 &lt;&lt; (y - 1))][y - 1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回rmq_deep数组区间[x, y]之间的最小元素的位置</span><br><span class="line">int min_st(int x, int y) &#123;</span><br><span class="line"></span><br><span class="line">	if (x &gt; y) &#123;//保证输入的x &lt;= y;若不满足，则反过来</span><br><span class="line">		return min_st(y, x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 17; i &gt;= 0; --i) &#123;</span><br><span class="line">		if (x + (1 &lt;&lt; i) - 1 &gt; y) &#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (x + (1 &lt;&lt; i) - 1 == y) &#123;</span><br><span class="line">			return st[x][i];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			int temp = min_st(x + (1 &lt;&lt; i), y);</span><br><span class="line">			return rmq_deep[st[x][i]] &lt; rmq_deep[temp] ? st[x][i] : temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int T, n, m, a1, a2, a3, first = 1;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">		memset(hand, 0, sizeof(int) * (n + 1));</span><br><span class="line">		memset(visited, 0, sizeof(int) * (n + 1));</span><br><span class="line"></span><br><span class="line">		pos = 1;</span><br><span class="line"></span><br><span class="line">		while (--n) &#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;a2, &amp;a3);</span><br><span class="line"></span><br><span class="line">			addToTree(a1, a2, a3);</span><br><span class="line">			addToTree(a2, a1, a3);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		disToRoot[1] = 0;</span><br><span class="line"></span><br><span class="line">		//在线算法（逐个回答问题）</span><br><span class="line"></span><br><span class="line">		rmq_pos = 0;</span><br><span class="line"></span><br><span class="line">		rmq(1, 1);</span><br><span class="line"></span><br><span class="line">		init_st();</span><br><span class="line"></span><br><span class="line">		if (first) &#123;</span><br><span class="line">			first = 0;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// for (int i = 0; i &lt; rmq_pos; i++) &#123;</span><br><span class="line">		// 	printf(&quot;%d &quot;, rmq_which[i]);</span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line">		// for (int i = 0; i &lt; rmq_pos; i++) &#123;</span><br><span class="line">		// 	printf(&quot;%d &quot;, rmq_deep[i]);</span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line">		// for (int i = 1; i &lt;= 6; i++) &#123;</span><br><span class="line">		// 	printf(&quot;%d &quot;, rmq_first[i]);</span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">		// for (int x = 0; x &lt; 18; x++) &#123;</span><br><span class="line">		// 	for (int i = 0; i &lt; rmq_pos; i++) &#123;</span><br><span class="line">		// 		printf(&quot;%d &quot;, st[i][x]);</span><br><span class="line">		// 	&#125;</span><br><span class="line">		// 	printf(&quot;\n&quot;);</span><br><span class="line">		// &#125;</span><br><span class="line"></span><br><span class="line">		while (m--) &#123;</span><br><span class="line"></span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a1, &amp;a2);</span><br><span class="line"></span><br><span class="line">			printf(&quot;%d\n&quot;, disToRoot[a1] + disToRoot[a2] - 2 * disToRoot[rmq_which[min_st(rmq_first[a1], rmq_first[a2])]]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解法4："><a href="#解法4：" class="headerlink" title="解法4："></a>解法4：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//31ms</span><br><span class="line">//转化为RMQ问题_Segment_Tree</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*	注意线段树需要4倍空间</span><br><span class="line">*	注意线段树需要4倍空间</span><br><span class="line">*	注意线段树需要4倍空间</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//在线算法</span><br><span class="line"></span><br><span class="line">//孩子链表示法(链表)</span><br><span class="line">//这里的孩子不一定是子节点，可能还有一个父节点，但是可以用visited数组来区别</span><br><span class="line">//随便选取一个hand作为根节点，就可以建成一棵树</span><br><span class="line"></span><br><span class="line">int hand[40005];//保存第x号房子的所有孩子节点链表的起始节点编号</span><br><span class="line"></span><br><span class="line">struct Node//链表节点</span><br><span class="line">&#123;</span><br><span class="line">	int distance;//权值</span><br><span class="line">	int to;</span><br><span class="line">	int next;//保存下一个Node的位置（并非指房子的编号，是节点的编号），即孩子组成的链表中的下一个节点的位置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node nodes[40005 &lt;&lt; 1];//需要两倍空间</span><br><span class="line"></span><br><span class="line">int pos;//pos为nodes的当前可用的Node的位置编号</span><br><span class="line">int disToRoot[40005];//代表到根节点的距离</span><br><span class="line">// 结果 = disToRoot[x] + disToRoot[y] - 2 * disToRoot[LCA(x, y)]</span><br><span class="line"></span><br><span class="line">//RMQ</span><br><span class="line">int rmq_which[40005 &lt;&lt; 1];//RMQ数组长度约为节点数的两倍（实际上是2n-1），储存欧拉环游经过的所有节点号</span><br><span class="line">int rmq_deep[40005 &lt;&lt; 1];//储存环游中节点的深度</span><br><span class="line">int rmq_first[40005];//储存循环中 x 号节点（房子）第一次出现的位置</span><br><span class="line">int rmq_pos;</span><br><span class="line"></span><br><span class="line">int visited[40005];//排除父节点</span><br><span class="line"></span><br><span class="line">//Segment_Tree</span><br><span class="line">struct SegNode</span><br><span class="line">&#123;</span><br><span class="line">	int left;</span><br><span class="line">	int right;</span><br><span class="line">	int minPos;//储存[left, right]区间内deep最小值所处的位置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//线段树需要原基础数组长度四倍的空间</span><br><span class="line">SegNode segs[40005 &lt;&lt; 3];//从1开始</span><br><span class="line"></span><br><span class="line">void addToTree(int x, int y, int z) &#123;//表示为x号房子添加一个子节点 y ,距离为z</span><br><span class="line">	//为pos号节点写入数据</span><br><span class="line">	nodes[pos].to = y;</span><br><span class="line">	nodes[pos].distance = z;</span><br><span class="line">	nodes[pos].next = hand[x];</span><br><span class="line">	hand[x] = pos;</span><br><span class="line"></span><br><span class="line">	pos++;//当前可用的节点编号+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* rmq函数用欧拉环游生成了rmq_which 和 rmq_deep 和 rmq_first 和 disToRoot 四个数组</span><br><span class="line">*/</span><br><span class="line">void rmq(int which, int deep) &#123;</span><br><span class="line">	visited[which] = 1;</span><br><span class="line"></span><br><span class="line">	rmq_which[rmq_pos] = which;</span><br><span class="line">	rmq_deep[rmq_pos] = deep;</span><br><span class="line">	rmq_first[which] = rmq_pos;</span><br><span class="line">	rmq_pos++;</span><br><span class="line"></span><br><span class="line">	int childPos = hand[which];</span><br><span class="line"></span><br><span class="line">	while (childPos) &#123;</span><br><span class="line">		if (visited[nodes[childPos].to]) &#123;</span><br><span class="line">			childPos = nodes[childPos].next;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		disToRoot[nodes[childPos].to] = disToRoot[which] + nodes[childPos].distance;</span><br><span class="line"></span><br><span class="line">		rmq(nodes[childPos].to, deep + 1);</span><br><span class="line"></span><br><span class="line">		rmq_which[rmq_pos] = which;</span><br><span class="line">		rmq_deep[rmq_pos] = deep;</span><br><span class="line">		rmq_pos++;</span><br><span class="line"></span><br><span class="line">		childPos = nodes[childPos].next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化segment数组</span><br><span class="line">void build_seg(int spos, int left, int right) &#123;</span><br><span class="line">	// printf(&quot;spos -&gt; %d\n&quot;, spos);</span><br><span class="line">	segs[spos].left = left;</span><br><span class="line">	segs[spos].right = right;</span><br><span class="line"></span><br><span class="line">	if (left == right) &#123;</span><br><span class="line">		segs[spos].minPos = left;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	build_seg(spos &lt;&lt; 1, left, (left + right) / 2);</span><br><span class="line">	build_seg((spos &lt;&lt; 1) | 1, ((left + right) / 2) + 1, right);</span><br><span class="line"></span><br><span class="line">	segs[spos].minPos = rmq_deep[segs[spos &lt;&lt; 1].minPos] &lt; rmq_deep[segs[(spos &lt;&lt; 1) | 1].minPos] ? segs[spos &lt;&lt; 1].minPos : segs[(spos &lt;&lt; 1) | 1].minPos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回rmq_deep数组区间[x, y]之间的最小元素的位置</span><br><span class="line">int min_seg(int pos, int x, int y) &#123;</span><br><span class="line">	if (x == segs[pos].left &amp;&amp; y == segs[pos].right) &#123;</span><br><span class="line">		return segs[pos].minPos;</span><br><span class="line">	&#125; else if (y &lt;= ((segs[pos].left + segs[pos].right) / 2)) &#123;</span><br><span class="line">		return min_seg(pos &lt;&lt; 1, x, y);</span><br><span class="line">	&#125; else if (x &gt; ((segs[pos].left + segs[pos].right) / 2)) &#123;</span><br><span class="line">		return min_seg((pos &lt;&lt; 1) | 1, x, y);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		int temp1, temp2;</span><br><span class="line">		temp1 = min_seg(pos &lt;&lt; 1, x, (segs[pos].left + segs[pos].right) / 2);</span><br><span class="line">		temp2 = min_seg((pos &lt;&lt; 1) | 1, ((segs[pos].left + segs[pos].right) / 2) + 1, y);</span><br><span class="line"></span><br><span class="line">		return rmq_deep[temp1] &lt; rmq_deep[temp2] ? temp1 : temp2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int T, n, m, a1, a2, a3, first = 1;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">		memset(hand, 0, sizeof(int) * (n + 1));</span><br><span class="line">		memset(visited, 0, sizeof(int) * (n + 1));</span><br><span class="line"></span><br><span class="line">		pos = 1;</span><br><span class="line"></span><br><span class="line">		while (--n) &#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;a2, &amp;a3);</span><br><span class="line"></span><br><span class="line">			addToTree(a1, a2, a3);</span><br><span class="line">			addToTree(a2, a1, a3);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		disToRoot[1] = 0;</span><br><span class="line"></span><br><span class="line">		//在线算法（逐个回答问题）</span><br><span class="line"></span><br><span class="line">		rmq_pos = 0;</span><br><span class="line"></span><br><span class="line">		rmq(1, 1);</span><br><span class="line"></span><br><span class="line">		// printf(&quot;rmq_pos -&gt; %d\n&quot;, rmq_pos);</span><br><span class="line"></span><br><span class="line">		build_seg(1, 0, rmq_pos - 1);</span><br><span class="line"></span><br><span class="line">		if (first) &#123;//好像没有空行也能过</span><br><span class="line">			first = 0;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// for (int i = 0; i &lt; rmq_pos; i++) &#123;</span><br><span class="line">		// 	printf(&quot;%d &quot;, rmq_which[i]);</span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line">		// for (int i = 0; i &lt; rmq_pos; i++) &#123;</span><br><span class="line">		// 	printf(&quot;%d &quot;, rmq_deep[i]);</span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line">		// for (int i = 1; i &lt;= 6; i++) &#123;</span><br><span class="line">		// 	printf(&quot;%d &quot;, rmq_first[i]);</span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">		while (m--) &#123;</span><br><span class="line"></span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a1, &amp;a2);</span><br><span class="line"></span><br><span class="line">			if (rmq_first[a1] &lt; rmq_first[a2]) &#123;</span><br><span class="line"></span><br><span class="line">				printf(&quot;%d\n&quot;, disToRoot[a1] + disToRoot[a2] - 2 * disToRoot[rmq_which[min_seg(1, rmq_first[a1], rmq_first[a2])]]);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				printf(&quot;%d\n&quot;, disToRoot[a1] + disToRoot[a2] - 2 * disToRoot[rmq_which[min_seg(1, rmq_first[a2], rmq_first[a1])]]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 1711 Number Sequence ——KMP</title>
    <url>/blog/18/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1711" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1711</a></p>
<blockquote>
<p>##Problem Description</p>
<p>Given two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2], …… , b[M] (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one.</p>
<p>Input<br>The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). The second line contains N integers which indicate a[1], a[2], …… , a[N]. The third line contains M integers which indicate b[1], b[2], …… , b[M]. All integers are in the range of [-1000000, 1000000].</p>
<p>Output<br>For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead.</p>
<p>Sample Input</p>
<p>2<br>13 5<br>1 2 1 2 3 1 2 3 1 3 2 1 2<br>1 2 3 1 3<br>13 5<br>1 2 1 2 3 1 2 3 1 3 2 1 2<br>1 2 3 2 1</p>
<p>Sample Output</p>
<p>6<br>-1</p>
</blockquote>
<h3 id="KMP的使用"><a href="#KMP的使用" class="headerlink" title="KMP的使用"></a>KMP的使用</h3><p>从头到尾彻底理解KMP：<br><a href="https://www.cnblogs.com/zhangtianq/p/5839909.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangtianq/p/5839909.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//KMP</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> sub[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> nextsub[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> t, n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, q + i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, sub + i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nextsub[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> cpi = i;</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cpi == <span class="number">0</span>) &#123;</span><br><span class="line">					nextsub[i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (sub[nextsub[cpi]] == sub[cpi]) &#123;</span><br><span class="line">					nextsub[i + <span class="number">1</span>] = nextsub[cpi] + <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					cpi = nextsub[cpi];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, find = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (q[i] == sub[j]) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">					find = <span class="number">1</span>;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - m + <span class="number">1</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">					i++;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				j = nextsub[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!find) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Java Thread的一些误区</title>
    <url>/blog/20/</url>
    <content><![CDATA[<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h3><blockquote>
<p>1.这个方法只会给线程设置一个为true的中断标志。<br>2.该方法可在需要中断的线程内自己调用，也可在其他线程中调用需要中断的线程对象的这个方法。</p>
</blockquote>
<blockquote>
<p>Java doc:</p>
<p>public void interrupt()Interrupts this thread.<br>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown. </p>
<p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException. </p>
<p>If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a ClosedByInterruptException. </p>
<p>If this thread is blocked in a Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked. </p>
<p>If none of the previous conditions hold then this thread’s interrupt status will be set. </p>
<p>Interrupting a thread that is not alive need not have any effect.</p>
<p>Throws:<br>SecurityException - if the current thread cannot modify this thread </p>
</blockquote>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><blockquote>
<p>调用“目标Thread对象”的join方法，把当前线程加入到该对象对应的线程中，等该对象对应的线程执行完毕再执行后加入的线程。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void join()</span><br><span class="line">                throws InterruptedExceptionWaits for this thread to die. </span><br><span class="line">An invocation of this method behaves in exactly the same way as the invocation </span><br><span class="line"></span><br><span class="line">join(0) </span><br><span class="line">Throws: </span><br><span class="line">InterruptedException - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown.</span><br></pre></td></tr></table></figure>
<h3 id="static-sleep"><a href="#static-sleep" class="headerlink" title="static sleep()"></a>static sleep()</h3><blockquote>
<p>此方法的“调用者”所在线程进入休眠，谁调用谁睡觉。 </p>
</blockquote>
<blockquote>
<p>与wait()的区别：<br>1.sleep来自Thread类，和wait来自Object类。<br>2.sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br>3.wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void sleep(long millis)</span><br><span class="line">                  throws InterruptedExceptionCauses the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors.</span><br><span class="line">Parameters: </span><br><span class="line">millis - the length of time to sleep in milliseconds </span><br><span class="line">Throws: </span><br><span class="line">IllegalArgumentException - if the value of millis is negative </span><br><span class="line">InterruptedException - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>HYSBZ 1216: [HNOI2003]操作系统</title>
    <url>/blog/19/</url>
    <content><![CDATA[<p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1216" target="_blank" rel="noopener">题目链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1216: [HNOI2003]操作系统</span><br><span class="line">Time Limit: 10 Sec  Memory Limit: 162 MB</span><br><span class="line">Submit: 1045  Solved: 565</span><br><span class="line">[Submit][Status][Discuss]</span><br><span class="line">Description</span><br><span class="line"></span><br><span class="line">写一个程序来模拟操作系统的进程调度。假设该系统只有一个CPU，每一个进程的到达时间，执行时间和运行优先级都是已知的。其中运行优先级用自然数表示，数字越大，则优先级越高。如果一个进程到达的时候CPU是空闲的，则它会一直占用CPU直到该进程结束。除非在这个过程中，有一个比它优先级高的进程要运行。在这种情况下，这个新的（优先级更高的）进程会占用CPU，而老的只有等待。如果一个进程到达时，CPU正在处理一个比它优先级高或优先级相同的进程，则这个（新到达的）进程必须等待。一旦CPU空闲，如果此时有进程在等待，则选择优先级最高的先运行。如果有多个优先级最高的进程，则选择到达时间最早的。</span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">输入文件包含若干行，每一行有四个自然数（均不超过108），分别是进程号，到达时间，执行时间和优先级。不同进程有不同的编号，不会有两个相同优先级的进程同时到达。输入数据已经按到达时间从小到大排序。输入数据保证在任何时候，等待队列中的进程不超过15000个。</span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">按照进程结束的时间输出每个进程的进程号和结束时间</span><br><span class="line">Sample Input</span><br><span class="line">1 1 5 3</span><br><span class="line"></span><br><span class="line">2 10 5 1</span><br><span class="line"></span><br><span class="line">3 12 7 2</span><br><span class="line"></span><br><span class="line">4 20 2 3</span><br><span class="line"></span><br><span class="line">5 21 9 4</span><br><span class="line"></span><br><span class="line">6 22 2 4</span><br><span class="line"></span><br><span class="line">7 23 5 2</span><br><span class="line"></span><br><span class="line">8 24 2 4</span><br><span class="line">Sample Output</span><br><span class="line">1 6</span><br><span class="line"></span><br><span class="line">3 19</span><br><span class="line"></span><br><span class="line">5 30</span><br><span class="line"></span><br><span class="line">6 32</span><br><span class="line"></span><br><span class="line">8 34</span><br><span class="line"></span><br><span class="line">4 35</span><br><span class="line"></span><br><span class="line">7 40</span><br><span class="line"></span><br><span class="line">2 42</span><br></pre></td></tr></table></figure>
<p>这题利用了优先队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">#define iinf 0x7FFFFFFF</span><br><span class="line"></span><br><span class="line">// AC</span><br><span class="line">// 优先队列</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int proCount;</span><br><span class="line"></span><br><span class="line">struct Pro &#123;</span><br><span class="line">	int id;</span><br><span class="line">	int comeTime;</span><br><span class="line">	int runTime;</span><br><span class="line">	int priority;</span><br><span class="line">	Pro(int a, int b, int c, int d): id(a), comeTime(b), runTime(c), priority(d) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cmp &#123;//判断“一个元素是否小于另一个元素”的结构体</span><br><span class="line">// 重载operator ()必须是某个类的成员函数。</span><br><span class="line">// 当某个类重载了()方法，这个类就可以成为函数对象。</span><br><span class="line">	bool operator() (Pro*&amp; p0, Pro*&amp; p1) const &#123;//关于这里的参数最前是否需要加const关键字，我的应对策略是：先试着加上，如果有错的话，编译器会回答找不到对应的方法，比如，加了const提示 ： error: no match for call to ‘(cmp) (Pro*&amp;, Pro*&amp;)’，可知这里不用加const</span><br><span class="line">		if (p0-&gt;priority == p1-&gt;priority) &#123;//若优先级相同，则更早来的在前面（优先队列中最前的元素，即top()，是比较之后值最大的那个元素，要让时间更前的元素排得越前，则它在这个自定义比较函数里面的“值”越大越好，即：优先级相同的两个元素，时间更前的元素反而更大）</span><br><span class="line">			return p0-&gt;comeTime &gt; p1-&gt;comeTime;//若第一个参数指向的元素来到时间比第二个元素的早，则表达式返回 false，代表第一个参数指向的元素大于第二个元素，排的更前。</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return p0-&gt;priority &lt; p1-&gt;priority;//若优先级不同，则优先级高的在前面</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*	为什么我不直接在Pro结构体内部重载 &lt; 操作符，因为我这个queue存的是指针变量，并不是实际的元素，重载Pro结构体的 &lt; 操作符不会有作用，因为这时候queue里面比较的是Pro*类型的元素，我们要想办法为Pro*类型的元素适配比较函数</span><br><span class="line">*	所以我写了上面那个比较函数，后来看了别人的代码发现，上面这个自定义的比较函数其实可以不用这么麻烦</span><br><span class="line">*	我们要想办法让 &lt; 操作符支持 Pro* 类型和 Pro* 类型之间的比较，所以我们可以在全局方范围内重载 &lt; 操作符</span><br><span class="line">*	例如：</span><br><span class="line">*	</span><br><span class="line">*	bool operator &lt; (Pro p0, Pro*&amp; p1) &#123;</span><br><span class="line">*		if (p0-&gt;priority == p1-&gt;priority) &#123;</span><br><span class="line">*			return p0-&gt;comeTime &gt; p1-&gt;comeTime;</span><br><span class="line">*		&#125; else &#123;</span><br><span class="line">*			return p0-&gt;priority &lt; p1-&gt;priority;</span><br><span class="line">*		&#125;</span><br><span class="line">*	&#125;</span><br><span class="line">*	同时下面的waitQu改成</span><br><span class="line">*	priority_queue &lt;Pro*&gt; waitQu;</span><br><span class="line">*	可是，编译报错</span><br><span class="line">*	 error: ‘bool operator&lt;(Pro*&amp;, Pro*&amp;)’ must have an argument of class or enumerated type</span><br><span class="line">*	 bool operator &lt; (Pro*&amp; p0, Pro*&amp; p1) &#123;</span><br><span class="line">*	                                    ^</span><br><span class="line">*	原来c++有些操作符在某些情况下是不能重载的，比如对两个指针的比较的小于号操作符，这个操作符已经有具体实现了，我们不能重载它，否则那些库里面用到用&lt;比较指针的操作都变成了我们自定义的操作了，岂不是乱了套</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">queue&lt;Pro*&gt; allPro;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;Pro*, vector&lt;Pro*&gt;, cmp&gt; waitQu; //存放排队等候中的进程</span><br><span class="line">//									^这里在模板中传入比较函数的类型，相当于自己实现一个 &lt; 函数</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int a, b, c, d;</span><br><span class="line">	Pro* t;</span><br><span class="line">	while (~scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d)) &#123;</span><br><span class="line">		t = new Pro(a, b, c, d);//这里是手动在堆上申请内存，让queue和priority_queue维护指针，实际上不用这样，可以直接在栈上建立一个Pro元素，queue和priority_queue会进行拷贝操作，在堆上形成一份原来栈内存上的元素的拷贝</span><br><span class="line">		allPro.push(t);//先读取放到allPro这个队列中</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int nowTime = 0;</span><br><span class="line">	int stepTime;//一次步进多长时间</span><br><span class="line"></span><br><span class="line">	for (; (!waitQu.empty()) || (!allPro.empty());) &#123;//当等待队列waitQu和allPro队列都为空时就退出</span><br><span class="line"></span><br><span class="line">		stepTime = iinf;</span><br><span class="line"></span><br><span class="line">		if (!waitQu.empty()) &#123; //若等待队列中还有元素</span><br><span class="line">			stepTime = min(stepTime, waitQu.top()-&gt;runTime);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!allPro.empty()) &#123;//若未加入的任务队列中还有元素</span><br><span class="line">			stepTime = min(stepTime, allPro.front()-&gt;comeTime - nowTime);</span><br><span class="line">		&#125;</span><br><span class="line">		//至此步进时长确定完成</span><br><span class="line"></span><br><span class="line">		nowTime += stepTime;</span><br><span class="line"></span><br><span class="line">		if (!waitQu.empty()) &#123;</span><br><span class="line">			//每次处理等待队列中的第一个元素</span><br><span class="line">			waitQu.top()-&gt;runTime -= stepTime;//等待队列中的第一个元素的剩余运行时间减去步进时间</span><br><span class="line">			if (waitQu.top()-&gt;runTime == 0) &#123;//若任务执行完毕</span><br><span class="line">				printf(&quot;%d %d\n&quot;, waitQu.top()-&gt;id, nowTime);</span><br><span class="line">				delete waitQu.top();//记得释放内存</span><br><span class="line">				waitQu.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!allPro.empty()) &#123;</span><br><span class="line">			if (nowTime == allPro.front()-&gt;comeTime) &#123;//若第一个未加入的任务时机已到，则加入任务到等待队列中</span><br><span class="line">				waitQu.push(allPro.front());</span><br><span class="line">				allPro.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Java继承的覆盖与隐藏</title>
    <url>/blog/21/</url>
    <content><![CDATA[<p>参考：<br><a href="https://www.cnblogs.com/it12345/p/5221673.html" target="_blank" rel="noopener">https://www.cnblogs.com/it12345/p/5221673.html</a></p>
<h3 id="隐藏和覆盖的区别"><a href="#隐藏和覆盖的区别" class="headerlink" title="隐藏和覆盖的区别"></a>隐藏和覆盖的区别</h3><p><strong>隐藏：将类型转换为父类的类型 即可解除 隐藏<br>覆盖：将类型转换为父类的类型也 不能 解除覆盖</strong></p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p><strong>只可能被隐藏，不存在覆盖一说</strong></p>
<p>父类的成员变量静态或非静态都可能被子类中同名的成员变量 隐藏 （不一定要匹配类型，同名即可隐藏）</p>
<h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><p><strong>直接用圆点运算符父类中的成员变量的办法：将类型转换为父类的类型。</strong><br><strong>在子类的方法中调用父类中被隐藏的成员变量的办法：在子类方法中使用super关键字配合圆点运算符取父类中的成员变量。</strong></p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>可以被隐藏，也可以被覆盖<br>同名的实例方法被覆盖 ，同名的静态方法被隐藏</p>
<h4 id="补充：继承规则"><a href="#补充：继承规则" class="headerlink" title="补充：继承规则"></a>补充：继承规则</h4><p>子类中与父类同名同参的方法才会发生重写，<br>重写时：<br>1.要求重写的方法的静态与非静态属性相同，<br>2.要求重写的方法的返回值类型相同，<br>3.重写后方法的可访问性必须更开放或不变，例如：private-&gt;public<br>不满足这三条的程序将报错无法通过编译</p>
<p><strong>若重写了实例方法，则发生覆盖</strong><br><strong> 若重写了静态方法，则发生隐藏</strong></p>
<h4 id="处理-1"><a href="#处理-1" class="headerlink" title="处理"></a>处理</h4><p><strong>通过反射能直接调用被“覆盖”的父类的方法的目的</strong><br><strong>无法在外部调用被“覆盖”的父类方法，只能在子类的内部使用super关键字配合圆点运算符调用父类的方法</strong><br><strong>无法通过转换类型达到调用被“覆盖”的父类的方法的目的</strong></p>
<h3 id="关于方法中使用到成员变量的问题"><a href="#关于方法中使用到成员变量的问题" class="headerlink" title="关于方法中使用到成员变量的问题"></a>关于方法中使用到成员变量的问题</h3><p><strong>所取用的成员变量是子类中的还是父类中的取决于实际被调用的方法是在父类中还是子类中，以实际被调用的方法所在位置来观察可以判断出使用的是哪里的成员变量。</strong></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		Ch ch = new Ch();</span><br><span class="line">		ch.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Su&#123;</span><br><span class="line">	int a = 3;//被隐藏</span><br><span class="line">	String b =&quot;what&quot;;//被隐藏</span><br><span class="line">	void show() &#123;//被覆盖</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Ch extends Su&#123;</span><br><span class="line">	float a = 1.23f;//发生隐藏</span><br><span class="line">	boolean b = false;//发生隐藏</span><br><span class="line"></span><br><span class="line">	void show() &#123;//发生覆盖</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">		super.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 输出：</span><br><span class="line"> * 1.23</span><br><span class="line"> * false</span><br><span class="line"> * 3</span><br><span class="line"> * what</span><br><span class="line"> * </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Xposed模块开发——在hook之后使用module的drawable资源</title>
    <url>/blog/22/</url>
    <content><![CDATA[<p>在xposed开发过程中遇到了直接使用模块内置资源失效的问题，而且这个问题很诡异，有时候失效，有时候有效果，没效果的时候一般是显示一把叉叉</p>
<p>在上网搜索后发现，hook函数是在被hook应用内部执行的，环境不一样，所以直接用R.drawable.xxx的方式使用会出现问题。</p>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p><a href="https://forum.xda-developers.com/xposed/access-resources-module-t2805276" target="_blank" rel="noopener">https://forum.xda-developers.com/xposed/access-resources-module-t2805276</a></p>
<p>参考了rovo89大神在xda上面的回复，改用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static String MODULE_PATH = null;</span><br><span class="line">private int mFakeId = 0;</span><br><span class="line"></span><br><span class="line">public void initZygote(StartupParam startupParam) throws Throwable &#123;</span><br><span class="line">	MODULE_PATH = startupParam.modulePath;//获取模块apk文件在储存中的位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void handleInitPackageResources(InitPackageResourcesParam resparam) throws Throwable &#123;</span><br><span class="line">	if (!resparam.packageName.equals(&quot;your.target.app&quot;))</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">	XModuleResources modRes = XModuleResources.createInstance(MODULE_PATH, resparam.res);</span><br><span class="line">	mFakeId = resparam.res.addResource(modRes, R.drawable.ic_launcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://api.xposed.info/reference/android/content/res/XResources.html#addResource" target="_blank" rel="noopener">http://api.xposed.info/reference/android/content/res/XResources.html#addResource</a>(android.content.res.Resources, int)</p>
<p>获得<code>mFakeld</code>变量，它储存的是在被hook应用内植入的一个假id，这个id对应的是module里面的<code>R.drawable.ic_launcher</code>这个资源，通过这个假id就可以使用到我们的module内的drawable资源。</p>
<h3 id="再次遇到问题"><a href="#再次遇到问题" class="headerlink" title="再次遇到问题"></a>再次遇到问题</h3><p>在实际使用中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view.setBackgroundResource(mFakeId);</span><br><span class="line">//导致异常</span><br><span class="line">//No known package when getting value for resource number 0x7e73c7c7&lt;/pre&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="再次解决"><a href="#再次解决" class="headerlink" title="再次解决"></a>再次解决</h3><p>搜索到一段代码</p>
<p><a href="https://github.com/neverweep/xStatusbarLunarDate/blob/master/src/de/xiaoxia/xstatusbarlunardate/Main.java" target="_blank" rel="noopener">https://github.com/neverweep/xStatusbarLunarDate/blob/master/src/de/xiaoxia/xstatusbarlunardate/Main.java</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void handleInitPackageResources(InitPackageResourcesParam resparam)&#123;</span><br><span class="line"></span><br><span class="line">	if (!resparam.packageName.equals(PACKAGE_NAME))</span><br><span class="line"></span><br><span class="line">	return; //如果不是UI则跳过</span><br><span class="line"></span><br><span class="line">	//这里将自带的图标资源插入到systemui中，并获取到一个资源id</span><br><span class="line"></span><br><span class="line">	XModuleResources modRes = XModuleResources.createInstance(MODULE_PATH, resparam.res); //创建一个插入资源的实例</span><br><span class="line"></span><br><span class="line">	ic_toast_bg_fest = resparam.res.addResource(modRes, R.drawable.ic_toast_bg_fest);</span><br><span class="line"></span><br><span class="line">	ic_toast_bg = resparam.res.addResource(modRes, R.drawable.ic_toast_bg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(_notify_icon)&#123;</span><br><span class="line"></span><br><span class="line">	//为Toast加入背景</span><br><span class="line">	</span><br><span class="line">	toastView.setBackground((context.getResources().getDrawable(isFest ? ic_toast_bg_fest : ic_toast_bg)));</span><br><span class="line">	</span><br><span class="line">	toastView.setGravity(Gravity.CENTER);</span><br><span class="line">	</span><br><span class="line">	if(toastTextView != null)&#123;</span><br><span class="line">	</span><br><span class="line">	toastTextView.setTextColor(0xFF000000);</span><br><span class="line">	</span><br><span class="line">	toastTextView.setPadding(0, 15, 0, 0);</span><br><span class="line">	</span><br><span class="line">	toastTextView.setShadowLayer(0, 0, 0, 0X00FFFFFF);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码里面使用的是配合<code>context</code>获得<code>drawable</code>，使用<code>setBackground()</code>方法</p>
<p>经过检验，这种写法正确。</p>
]]></content>
      <categories>
        <category>Xposed</category>
      </categories>
  </entry>
  <entry>
    <title>转载_各种文件头信息</title>
    <url>/blog/23/</url>
    <content><![CDATA[<p>源:<a href="http://blog.csdn.net/txgc0/article/details/17246625" target="_blank" rel="noopener">http://blog.csdn.net/txgc0/article/details/17246625</a></p>
<h1 id="0x00-从Ultraedit中提取出来的文件头信息，两个字符算一字节-十六进制"><a href="#0x00-从Ultraedit中提取出来的文件头信息，两个字符算一字节-十六进制" class="headerlink" title="0x00 从Ultraedit中提取出来的文件头信息，两个字符算一字节(十六进制)"></a><strong>0x00 从Ultraedit中提取出来的文件头信息，两个字符算一字节(十六进制)</strong></h1><table>
<thead>
<tr>
<th>文件格式</th>
<th>文件头</th>
</tr>
</thead>
<tbody>
<tr>
<td>JPEG (jpg)</td>
<td>FFD8FF</td>
</tr>
<tr>
<td>PNG (png)</td>
<td>89504E47</td>
</tr>
<tr>
<td>GIF (gif)</td>
<td>47494638</td>
</tr>
<tr>
<td>TIFF (tif)</td>
<td>49492A00</td>
</tr>
<tr>
<td>Windows Bitmap (bmp)</td>
<td>424D</td>
</tr>
<tr>
<td>CAD (dwg)</td>
<td>41433130</td>
</tr>
<tr>
<td>Adobe Photoshop (psd)</td>
<td>38425053</td>
</tr>
<tr>
<td>Rich Text Format (rtf)</td>
<td>7B5C727466</td>
</tr>
<tr>
<td>XML (xml)</td>
<td>3C3F786D6C</td>
</tr>
<tr>
<td>HTML (html)</td>
<td>68746D6C3E</td>
</tr>
<tr>
<td>Email (eml)</td>
<td>44656C69766572792D646174653A</td>
</tr>
<tr>
<td>Outlook Express (dbx)</td>
<td>CFAD12FEC5FD746F</td>
</tr>
<tr>
<td>Outlook (pst)</td>
<td>2142444E</td>
</tr>
<tr>
<td>MS Word/Excel (xls.or.doc)</td>
<td>D0CF11E0</td>
</tr>
<tr>
<td>MS Access (mdb)</td>
<td>5374616E64617264204A</td>
</tr>
<tr>
<td>WordPerfect (wpd)</td>
<td>FF575043</td>
</tr>
<tr>
<td>Postscript (eps.or.ps)</td>
<td>252150532D41646F6265</td>
</tr>
<tr>
<td>Adobe Acrobat (pdf)</td>
<td>255044462D312E</td>
</tr>
<tr>
<td>Quicken (qdf)</td>
<td>AC9EBD8F</td>
</tr>
<tr>
<td>Windows Password (pwl)</td>
<td>E3828596</td>
</tr>
<tr>
<td>ZIP Archive (zip)</td>
<td>504B0304</td>
</tr>
<tr>
<td>RAR Archive (rar)</td>
<td>52617221</td>
</tr>
<tr>
<td>Wave (wav)</td>
<td>57415645</td>
</tr>
<tr>
<td>AVI (avi)</td>
<td>41564920</td>
</tr>
<tr>
<td>Real Audio (ram)</td>
<td>2E7261FD</td>
</tr>
<tr>
<td>Real Media (rm)</td>
<td>2E524D46</td>
</tr>
<tr>
<td>MPEG (mpg)</td>
<td>000001BA</td>
</tr>
<tr>
<td>MPEG (mpg)</td>
<td>000001B3</td>
</tr>
<tr>
<td>Quicktime (mov)</td>
<td>6D6F6F76</td>
</tr>
<tr>
<td>Windows Media (asf)</td>
<td>3026B2758E66CF11</td>
</tr>
<tr>
<td>MIDI (mid)</td>
<td>4D546864</td>
</tr>
</tbody>
</table>
<h1 id="0x01-从winhex中取出的文件头列表"><a href="#0x01-从winhex中取出的文件头列表" class="headerlink" title="0x01 从winhex中取出的文件头列表"></a><strong>0x01 从winhex中取出的文件头列表</strong></h1><table>
<thead>
<tr>
<th>文件类型</th>
<th>后缀</th>
<th>文件头</th>
</tr>
</thead>
<tbody>
<tr>
<td>JPEG</td>
<td>jpg;jpeg</td>
<td>0xFFD8FF</td>
</tr>
<tr>
<td>PNG</td>
<td>png</td>
<td>0x89504E470D0A1A0A</td>
</tr>
<tr>
<td>GIF</td>
<td>gif</td>
<td>GIF8</td>
</tr>
<tr>
<td>TIFF</td>
<td>tif;tiff</td>
<td>0x49492A00</td>
</tr>
<tr>
<td>TIFF</td>
<td>tif;tiff</td>
<td>0x4D4D002A</td>
</tr>
<tr>
<td>Bit map</td>
<td>bmp</td>
<td>BM</td>
</tr>
<tr>
<td>AOL ART</td>
<td>art</td>
<td>0x4A47040E000000</td>
</tr>
<tr>
<td>AOL ART</td>
<td>art</td>
<td>0x4A47030E000000</td>
</tr>
<tr>
<td>PC Paintbrush</td>
<td>pcx</td>
<td>0x0A050108</td>
</tr>
<tr>
<td>Graphics Metafile</td>
<td>wmf</td>
<td>0xD7CDC69A</td>
</tr>
<tr>
<td>Graphics Metafile</td>
<td>wmf</td>
<td>0x01000900</td>
</tr>
<tr>
<td>Graphics Metafile</td>
<td>wmf</td>
<td>0x02000900</td>
</tr>
<tr>
<td>Enhanced Metafile</td>
<td>emf</td>
<td>0x0100000058000000</td>
</tr>
<tr>
<td>Corel Draw</td>
<td>cdr</td>
<td>CDR</td>
</tr>
<tr>
<td>CAD</td>
<td>dwg</td>
<td>0x41433130</td>
</tr>
<tr>
<td>Adobe Photoshop</td>
<td>psd</td>
<td>8BPS</td>
</tr>
<tr>
<td>Rich Text Format</td>
<td>rtf</td>
<td>rtf</td>
</tr>
<tr>
<td>XML</td>
<td>xml</td>
</tr>
<tr>
<td>HTML</td>
<td>html;htm;php;php3;php4;phtml;shtml</td>
<td>type</td>
</tr>
<tr>
<td>Email</td>
<td>eml</td>
<td>Delivery-date:</td>
</tr>
<tr>
<td>Outlook Express</td>
<td>dbx</td>
<td>0xCFAD12FE</td>
</tr>
<tr>
<td>Outlookpst!BDN</td>
</tr>
<tr>
<td>MS Office/OLE2</td>
<td>doc;xls;dot;ppt;xla;ppa;pps;pot;msi;sdw;db</td>
<td>0xD0CF11E0A1B11AE1</td>
</tr>
<tr>
<td>MS Access</td>
<td>mdb;mda;mde;mdt</td>
<td>Standard J</td>
</tr>
<tr>
<td>WordPerfect</td>
<td>wpd</td>
<td>0xFF575043</td>
</tr>
<tr>
<td>OpenOffice Writer</td>
<td>sxw</td>
<td>writer</td>
</tr>
<tr>
<td>OpenOffice Calc</td>
<td>sxc</td>
<td>calc</td>
</tr>
<tr>
<td>OpenOffice Math</td>
<td>sxm</td>
<td>math</td>
</tr>
<tr>
<td>OpenOffice Impress</td>
<td>sxi</td>
<td>impress</td>
</tr>
<tr>
<td>OpenOffice Draw</td>
<td>sxd</td>
<td>draw</td>
</tr>
<tr>
<td>Adobe FrameMaker</td>
<td>fm</td>
<td>&lt;MAKERFILE</td>
</tr>
<tr>
<td>PostScript</td>
<td>eps.or.ps;ps;eps</td>
<td>%!PS-Adobe</td>
</tr>
<tr>
<td>Adobe Acrobat</td>
<td>pdf</td>
<td>%PDF-1.</td>
</tr>
<tr>
<td>Quicken</td>
<td>qdf</td>
<td>0xAC9EBD8F</td>
</tr>
<tr>
<td>QuickBooks Backup</td>
<td>qbb</td>
<td>0x458600000600</td>
</tr>
<tr>
<td>Sage</td>
<td>sly.or.srt.or.slt;sly;srt;slt</td>
<td>0x53520100</td>
</tr>
<tr>
<td>Sage Backup</td>
<td>1</td>
<td>SAGEBACKUP</td>
</tr>
<tr>
<td>Lotus WordPro v9</td>
<td>lwp</td>
<td>0x576F726450726F</td>
</tr>
<tr>
<td>Lotus 123 v9</td>
<td>123</td>
<td>0x00001A00051004</td>
</tr>
<tr>
<td>Lotus 123 v5</td>
<td>wk4</td>
<td>0x00001A0002100400</td>
</tr>
<tr>
<td>Lotus 123 v3</td>
<td>wk3</td>
<td>0x00001A0000100400</td>
</tr>
<tr>
<td>Lotus 123 v1</td>
<td>wk1</td>
<td>0x2000604060</td>
</tr>
<tr>
<td>Windows Password</td>
<td>pwl</td>
<td>0xE3828596</td>
</tr>
<tr>
<td>ZIP Archive</td>
<td>zip;jar</td>
<td>0x504B0304</td>
</tr>
<tr>
<td>ZIP Archive (outdated)</td>
<td>zip</td>
<td>0x504B3030</td>
</tr>
<tr>
<td>RAR Archive</td>
<td>rar</td>
<td>Rar!</td>
</tr>
<tr>
<td>GZ Archive</td>
<td>gz;tgz</td>
<td>0x1F8B08</td>
</tr>
<tr>
<td>BZIP Archive</td>
<td>bz2</td>
<td>BZh</td>
</tr>
<tr>
<td>ARJ Archive</td>
<td>arj</td>
<td>0x60EA</td>
</tr>
<tr>
<td>7－ZIP Archive</td>
<td>7z</td>
<td>7z集’</td>
</tr>
<tr>
<td>Wave</td>
<td>wav</td>
<td>WAVE</td>
</tr>
<tr>
<td>AVI</td>
<td>avi</td>
<td>AVI</td>
</tr>
<tr>
<td>Real Audio</td>
<td>ram;ra</td>
<td>.ra?0</td>
</tr>
<tr>
<td>Real Media</td>
<td>rm</td>
<td>.RMF</td>
</tr>
<tr>
<td>MPEG</td>
<td>mpg;mpeg</td>
<td>0x000001BA</td>
</tr>
<tr>
<td>MPEG</td>
<td>mpg;mpeg</td>
<td>0x000001B3</td>
</tr>
<tr>
<td>Quicktime</td>
<td>mov</td>
<td>moov</td>
</tr>
<tr>
<td>Windows Media</td>
<td>asf</td>
<td>0x3026B2758E66CF11</td>
</tr>
<tr>
<td>MIDI</td>
<td>mid</td>
<td>MThd</td>
</tr>
<tr>
<td>Win32 Executable(pe文件即可执行文件)</td>
<td>exe;dll;drv;vxd;sys;ocx;vbx</td>
<td>MZ</td>
</tr>
<tr>
<td>Win16 Executable (pe文件即可执行文件)</td>
<td>exe;dll;drv;vxd;sys;ocx;vbx</td>
<td>MZ</td>
</tr>
<tr>
<td>ELF Executable</td>
<td>elf;;</td>
<td>0x7F454C4601010100</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>闲时研究</category>
      </categories>
  </entry>
  <entry>
    <title>一道抓小偷的OJ题，不用数组实现，遗憾位移以后没有赋值，在此记下</title>
    <url>/blog/24/</url>
    <content><![CDATA[<p>输入一串字符串’\n’结尾，X代表小偷，#代表普通人，数字代表警察，其数字是警察能巡视到的范围。<br>输出小偷个数，换行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int printBin(unsigned long num)&#123;</span><br><span class="line">	while(num != 0)&#123;</span><br><span class="line">		printf(&quot;%d &quot;, num % 2);</span><br><span class="line">		num = num &gt;&gt; 1; </span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	unsigned long line = 0,rangeLine = 0;</span><br><span class="line">	int index = 0,range,count = 0;</span><br><span class="line">	char tmp;</span><br><span class="line"></span><br><span class="line">	scanf(&quot;%c&quot;,&amp;tmp);</span><br><span class="line">	while(tmp != &apos;\n&apos;)&#123;</span><br><span class="line"></span><br><span class="line">		if(index &lt; 20)&#123;</span><br><span class="line">			if(tmp == &apos;X&apos;)&#123;</span><br><span class="line">				line = line | (1 &lt;&lt; index);</span><br><span class="line">			&#125;else if(tmp == &apos;#&apos;)&#123;		</span><br><span class="line"></span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				range = tmp - &apos;0&apos;;</span><br><span class="line"></span><br><span class="line">				for(int i = 0; i &lt;= range; i++)&#123;</span><br><span class="line"></span><br><span class="line">					rangeLine = rangeLine | (1 &lt;&lt; index + i);</span><br><span class="line">					rangeLine = rangeLine | (1 &lt;&lt; index - i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// printBin(line);</span><br><span class="line">			// printBin(rangeLine);</span><br><span class="line"></span><br><span class="line">			index++;</span><br><span class="line">			scanf(&quot;%c&quot;,&amp;tmp);</span><br><span class="line"></span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			while(index &gt;= 10)&#123;</span><br><span class="line"></span><br><span class="line">				if(rangeLine &amp; 1)&#123;</span><br><span class="line">					if(line &amp; 1)&#123;</span><br><span class="line">						count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				index--;</span><br><span class="line">				line = line &gt;&gt; 1;</span><br><span class="line">				rangeLine = rangeLine &gt;&gt; 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	index--;</span><br><span class="line"></span><br><span class="line">	while(index &gt;= 0)&#123;</span><br><span class="line"></span><br><span class="line">//		printf(&quot;%d %d\n&quot;,line &amp; 1,rangeLine &amp; 1);</span><br><span class="line">		if(rangeLine &amp; 1)&#123;</span><br><span class="line">			if(line &amp; 1)&#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		index--;</span><br><span class="line">		line = line &gt;&gt; 1;</span><br><span class="line">		rangeLine = rangeLine &gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d&quot;,count);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>两大LCS问题</title>
    <url>/blog/25/</url>
    <content><![CDATA[<h2 id="0x00-相同子序：（不要求连续）"><a href="#0x00-相同子序：（不要求连续）" class="headerlink" title="0x00 相同子序：（不要求连续）"></a>0x00 相同子序：（不要求连续）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">// // #define DEBUG</span><br><span class="line">// #ifdef DEBUG</span><br><span class="line">// #define SHOW</span><br><span class="line">// #else</span><br><span class="line">// #define SHOW /##/</span><br><span class="line">// #endif</span><br><span class="line">// 不可行，注释先于预处理指令被处理</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// LCS共同子序不要求连续</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	string s1, s2;</span><br><span class="line">	while (cin &gt;&gt; s1 &gt;&gt; s2) &#123;</span><br><span class="line">		int len1 = s1.length();//不包括末尾的&apos;\0&apos;</span><br><span class="line">		int len2 = s2.length();</span><br><span class="line">		int ans = 0;</span><br><span class="line">		int dp[len1 + 5][len2 + 5] = &#123;&#125;;//初始化为0避免边界讨论</span><br><span class="line"></span><br><span class="line">		// printf(&quot;\t\t&quot;);</span><br><span class="line">		// for (int y = 0; y &lt; len2; y++) &#123;</span><br><span class="line">		// 	printf(&quot;%c\t&quot;, s2[y]);</span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n\t&quot;);</span><br><span class="line"></span><br><span class="line">		// for (int y = 0; y &lt;= len2; y++) &#123;</span><br><span class="line">		// 	printf(&quot;%d\t&quot;, dp[0][y]);</span><br><span class="line"></span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">		for (int x = 1; x &lt;= len1; x++) &#123;</span><br><span class="line">			// printf(&quot;%c\t&quot;, s1[x - 1]);</span><br><span class="line">			// printf(&quot;%d\t&quot;, dp[x][0]);</span><br><span class="line">			for (int y = 1; y &lt;= len2; y++) &#123;</span><br><span class="line">				if (s1[x - 1] == s2[y - 1]) &#123;//之所以减一是由于循环变量从1开始</span><br><span class="line">					dp[x][y] = dp[x - 1][y - 1] + 1;// 等于左上方格子加一</span><br><span class="line">					// printf(&quot;↖%d\t&quot;, dp[x][y]);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					dp[x][y] = max(dp[x - 1][y], dp[x][y - 1]);// 向左上方的所有格子取最大值(实际上只需要从左边和上边选取最大值)</span><br><span class="line">					// if (dp[x][y] == dp[x - 1][y]) &#123;</span><br><span class="line">					// 	printf(&quot;↑%d\t&quot;, dp[x][y]);</span><br><span class="line">					// &#125; else &#123;</span><br><span class="line">					// 	printf(&quot;←%d\t&quot;, dp[x][y]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		*	abcfbc abfcab</span><br><span class="line">		*	dp数组:</span><br><span class="line">		*</span><br><span class="line">		*			a	b	f	c	a	b</span><br><span class="line">		*		0	0	0	0	0	0	0</span><br><span class="line">		*	a	0	↖1	←1	←1	←1	↖1	←1</span><br><span class="line">		*	b	0	↑1	↖2	←2	←2	←2	↖2</span><br><span class="line">		*	c	0	↑1	↑2	↑2	↖3	←3	←3</span><br><span class="line">		*	f	0	↑1	↑2	↖3	↑3	↑3	↑3</span><br><span class="line">		*	b	0	↑1	↖2	↑3	↑3	↑3	↖4</span><br><span class="line">		*	c	0	↑1	↑2	↑3	↖4	←4	↑4</span><br><span class="line">		*	</span><br><span class="line">		*	out:4</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">		for (int x = 1; x &lt;= len1; x++) &#123;</span><br><span class="line">			for (int y = 1; y &lt;= len2; y++) &#123;</span><br><span class="line">				ans = max(ans, dp[x][y]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x01-相同子列（连续）"><a href="#0x01-相同子列（连续）" class="headerlink" title="0x01 相同子列（连续）"></a>0x01 相同子列（连续）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// LCS共同连续子列</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	string s1, s2;</span><br><span class="line">	while (cin &gt;&gt; s1 &gt;&gt; s2) &#123;</span><br><span class="line">		int len1 = s1.length();//不包括末尾的&apos;\0&apos;</span><br><span class="line">		int len2 = s2.length();</span><br><span class="line">		int ans = 0;</span><br><span class="line">		int dp[len1 + 5][len2 + 5] = &#123;&#125;;//初始化为0避免边界讨论</span><br><span class="line"></span><br><span class="line">		// printf(&quot;\t\t&quot;);</span><br><span class="line">		// for (int y = 0; y &lt; len2; y++) &#123;</span><br><span class="line">		// 	printf(&quot;%c\t&quot;, s2[y]);</span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n\t&quot;);</span><br><span class="line"></span><br><span class="line">		// for (int y = 0; y &lt;= len2; y++) &#123;</span><br><span class="line">		// 	printf(&quot;%d\t&quot;, dp[0][y]);</span><br><span class="line"></span><br><span class="line">		// &#125;</span><br><span class="line">		// printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">		for (int x = 1; x &lt;= len1; x++) &#123;</span><br><span class="line">			// printf(&quot;%c\t&quot;, s1[x - 1]);</span><br><span class="line">			// printf(&quot;%d\t&quot;, dp[x][0]);</span><br><span class="line">			for (int y = 1; y &lt;= len2; y++) &#123;</span><br><span class="line">				if (s1[x - 1] == s2[y - 1]) &#123;//之所以减一是由于循环变量从1开始</span><br><span class="line">					dp[x][y] = dp[x - 1][y - 1] + 1;// 等于左上方格子加一</span><br><span class="line">					// printf(&quot;↖%d\t&quot;, dp[x][y]);</span><br><span class="line">				&#125;//不相等则无需处理</span><br><span class="line">				// else &#123;</span><br><span class="line">				// 	printf(&quot;%d\t&quot;, dp[x][y]);</span><br><span class="line">				// &#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		*	abcfbc abfcab</span><br><span class="line">		*	dp数组:</span><br><span class="line">		*</span><br><span class="line">		*			a	b	f	c	a	b</span><br><span class="line">		*		0	0	0	0	0	0	0</span><br><span class="line">		*	a	0	↖1	0	0	0	↖1	0</span><br><span class="line">		*	b	0	0	↖2	0	0	0	↖2</span><br><span class="line">		*	c	0	0	0	0	↖1	0	0</span><br><span class="line">		*	f	0	0	0	↖1	0	0	0</span><br><span class="line">		*	b	0	0	↖1	0	0	0	↖1</span><br><span class="line">		*	c	0	0	0	0	↖1	0	0</span><br><span class="line">		*</span><br><span class="line">		*	out:2</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">		for (int x = 1; x &lt;= len1; x++) &#123;</span><br><span class="line">			for (int y = 1; y &lt;= len2; y++) &#123;</span><br><span class="line">				ans = max(ans, dp[x][y]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>关于scanf的误区</title>
    <url>/blog/26/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	int a, b;</span><br><span class="line">	while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b) == EOF)&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, a + b);	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>scanf()</code> 遇到文件末尾时，如果什么都没有读取到，就返回EOF(-1)，<br>如果有变量已经赋值那就返回赋值了的变量个数，而不会是EOF。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>最长递增子列的另一种思路（转化为LCS问题）</title>
    <url>/blog/28/</url>
    <content><![CDATA[<h2 id="利用LCS的解题思路可以解决最长递增子列的问题顺便求出该递增序列"><a href="#利用LCS的解题思路可以解决最长递增子列的问题顺便求出该递增序列" class="headerlink" title="利用LCS的解题思路可以解决最长递增子列的问题顺便求出该递增序列"></a>利用LCS的解题思路可以解决最长递增子列的问题顺便求出该递增序列</h2><blockquote>
<p>例如<br>list1 = [1, 2, 3, 1, -1, 0, 4, 5]<br>将其排序得<br>list2 = [-1, 0, 1, 1, 2, 3, 4, 5]<br>则问题转化为<br>求list1和list2的最长的不要求连续的公共子列及其长度</p>
</blockquote>
<p>资料：<br><a href="http://blog.csdn.net/u013178472/article/details/54926531" target="_blank" rel="noopener">http://blog.csdn.net/u013178472/article/details/54926531</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派指令集合</title>
    <url>/blog/29/</url>
    <content><![CDATA[<h2 id="获取温度："><a href="#获取温度：" class="headerlink" title="获取温度："></a>获取温度：</h2><blockquote>
<p>cat /sys/class/thermal/thermal_zone0/temp<br>温度要除以1000</p>
</blockquote>
]]></content>
      <categories>
        <category>raspberry pi</category>
      </categories>
  </entry>
  <entry>
    <title>[笔记]读Android中Service的Binder跨进程通信机制</title>
    <url>/blog/31/</url>
    <content><![CDATA[<p>今天拜读了姜维大神的<code>Android系统篇之----Binder机制和远程服务调用机制分析</code></p>
<p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/52467919" target="_blank" rel="noopener">Android系统篇之—-Binder机制和远程服务调用机制分析</a></p>
<p>读完有一个疑惑，就是<br>文中</p>
<blockquote>
<p>6、最后返回的对象其实就是这个<code>Proxy</code>对象，而这个对象内部使用了静态代理方式，内部有一个来自远端的<code>mRemote</code>变量即<code>IBinder</code>对象。然后直接调用方法其实就是调用<code>mRemote</code>的<code>transact</code>方法进行通信了。</p>
</blockquote>
<p><code>IBinder</code>是一个接口，具体的实现类没有说明，一开始以为是<code>Binder</code>，看了一下<code>Binder</code>的<code>transact</code>方法实现，发现直接调用了<code>Stub</code>的<code>onTransact</code>，真是简直了，一脸懵逼啊，这不是就在自己的进程执行了嘛，<code>native</code>呢？后来上网查发现这里的<code>mRemote</code>实际上是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class BinderProxy implements IBinder</span><br></pre></td></tr></table></figure></p>
<p>但在as里面搜不到这个类，于是取出<code>framework.jar</code>用jadx开，果然看到<code>android.os.BinderProxy</code><br>其中有：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">    return transactNative(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native boolean transactNative(int i, Parcel parcel, Parcel parcel2, int i2) throws RemoteException;</span><br></pre></td></tr></table></figure>
<p><img src="/images/blog/31_0.png" alt="jadx反编译的framework.jar"></p>
<p>这里<code>Proxy</code>类中的<code>mRemote</code>类型是<code>BinderProxy</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mRemote.transact(Stub.TRANSACTION_getData, _data, _reply, 0);</span><br></pre></td></tr></table></figure></p>
<p>这句实际上调用了<code>BinderProxy</code>的<code>transact</code>方法，上面看到它转而调用了一个<code>transactNative</code>的native方法实现和内核通信</p>
<p>猜想这个因为是系统的实现，所以as里面搜不到这个类，真的是找了好久。终于明白了</p>
<p><strong><code>BinderProxy</code>源码(Android 6.0.1)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package android.os;</span><br><span class="line"></span><br><span class="line">import android.os.IBinder.DeathRecipient;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import java.io.FileDescriptor;</span><br><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line">/* compiled from: Binder */</span><br><span class="line">final class BinderProxy implements IBinder &#123;</span><br><span class="line">    private long mObject;</span><br><span class="line">    private long mOrgue;</span><br><span class="line">    private final WeakReference mSelf = new WeakReference(this);</span><br><span class="line"></span><br><span class="line">    private final native void destroy();</span><br><span class="line"></span><br><span class="line">    public native String getInterfaceDescriptor() throws RemoteException;</span><br><span class="line"></span><br><span class="line">    public native boolean isBinderAlive();</span><br><span class="line"></span><br><span class="line">    public native void linkToDeath(DeathRecipient deathRecipient, int i) throws RemoteException;</span><br><span class="line"></span><br><span class="line">    public native boolean pingBinder();</span><br><span class="line"></span><br><span class="line">    public native boolean transactNative(int i, Parcel parcel, Parcel parcel2, int i2) throws RemoteException;</span><br><span class="line"></span><br><span class="line">    public native boolean unlinkToDeath(DeathRecipient deathRecipient, int i);</span><br><span class="line"></span><br><span class="line">    public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line">        return transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dump(FileDescriptor fd, String[] args) throws RemoteException &#123;</span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        Parcel reply = Parcel.obtain();</span><br><span class="line">        data.writeFileDescriptor(fd);</span><br><span class="line">        data.writeStringArray(args);</span><br><span class="line">        try &#123;</span><br><span class="line">            transact(IBinder.DUMP_TRANSACTION, data, reply, 0);</span><br><span class="line">            reply.readException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            data.recycle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException &#123;</span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        Parcel reply = Parcel.obtain();</span><br><span class="line">        data.writeFileDescriptor(fd);</span><br><span class="line">        data.writeStringArray(args);</span><br><span class="line">        try &#123;</span><br><span class="line">            transact(IBinder.DUMP_TRANSACTION, data, reply, 1);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            data.recycle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinderProxy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            super.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final void sendDeathNotice(DeathRecipient recipient) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            recipient.binderDied();</span><br><span class="line">        &#125; catch (RuntimeException exc) &#123;</span><br><span class="line">            Log.w(&quot;BinderNative&quot;, &quot;Uncaught exception from death notification&quot;, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<br>Android系统篇之—-Binder机制和远程服务调用机制分析<br><a href="https://blog.csdn.net/jiangwei0910410003/article/details/52467919" target="_blank" rel="noopener">https://blog.csdn.net/jiangwei0910410003/article/details/52467919</a><br>Android系统进程间通信Binder机制在应用程序框架层的Java接口源代码分析<br><a href="https://www.linuxidc.com/Linux/2011-07/39620p9.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2011-07/39620p9.htm</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
        <tag>Binder</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>对比学习Java和C++时关于方法覆盖Override后外部调用父类方法的区别</title>
    <url>/blog/27/</url>
    <content><![CDATA[<p>以Java语法示范：</p>
<p><img src="/images/blog/27_0.png" alt=""></p>
<p>面向对象中，B extends A</p>
<blockquote>
<p>// Java中</p>
<p>B objectB = new B();</p>
<p>objectB.foo();//输出 from Child Class</p>
<p>A objectA = new B();</p>
<p>objectA.foo();//依然输出 from Child Class</p>
<p>//类型转换不会导致父类方法被调用</p>
<p>//而，C++中，通过类型转换，可以达到调用父类被覆盖的方法的效果</p>
</blockquote>
<p>参考：<a href="http://bbs.csdn.net/wap/topics/390171251" target="_blank" rel="noopener">http://bbs.csdn.net/wap/topics/390171251</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法词汇</title>
    <url>/blog/33/</url>
    <content><![CDATA[<hr>
<p><a href="https://segmentfault.com/a/1190000002641054" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002641054</a></p>
<blockquote>
<p><strong>LCS</strong><br><em>Longest Common Subsequence</em><br>最长公共子列</p>
</blockquote>
<blockquote>
<p><strong>LIS</strong><br><em>Longest Increasing Subsequence</em><br>最长上升子列</p>
</blockquote>
<hr>
<p><a href="https://segmentfault.com/a/1190000002646526" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002646526</a></p>
<blockquote>
<p><strong>LRS</strong><br><em>Longest Repeated Substring</em><br>重复子串</p>
</blockquote>
<hr>
<p><a href="https://www.cnblogs.com/JVxie/p/4854719.html" target="_blank" rel="noopener">https://www.cnblogs.com/JVxie/p/4854719.html</a></p>
<blockquote>
<p><strong>LCA</strong><br><em>Least Common Ancestors</em><br>最近的公共祖先</p>
</blockquote>
<hr>
<p><a href="http://blog.csdn.net/ywcpig/article/details/52336496" target="_blank" rel="noopener">http://blog.csdn.net/ywcpig/article/details/52336496</a></p>
<blockquote>
<p><strong>RMQ</strong><br><em>Range Maximum/Minimm Query</em><br>区间最值查询</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法文章收集</title>
    <url>/blog/32/</url>
    <content><![CDATA[<h3 id="0x00-OJ网站"><a href="#0x00-OJ网站" class="headerlink" title="0x00 OJ网站"></a>0x00 OJ网站</h3><p>projecteuler<br><a href="https://projecteuler.net/archives" target="_blank" rel="noopener">https://projecteuler.net/archives</a></p>
<h3 id="0x01-算法集合"><a href="#0x01-算法集合" class="headerlink" title="0x01 算法集合"></a>0x01 算法集合</h3><p><a href="http://blog.51cto.com/ahalei/p2" target="_blank" rel="noopener">http://blog.51cto.com/ahalei/p2</a></p>
<h3 id="0x02-动态规划"><a href="#0x02-动态规划" class="headerlink" title="0x02 动态规划"></a>0x02 动态规划</h3><h4 id="题集"><a href="#题集" class="headerlink" title="题集"></a>题集</h4><p><a href="http://blog.csdn.net/eagle_or_snail/article/details/50987044" target="_blank" rel="noopener">http://blog.csdn.net/eagle_or_snail/article/details/50987044</a><br>最长公共子序列（LCS）问题<br><a href="http://blog.csdn.net/lisonglisonglisong/article/details/4154855" target="_blank" rel="noopener">http://blog.csdn.net/lisonglisonglisong/article/details/4154855</a><br><a href="http://blog.csdn.net/lisonglisonglisong/article/details/41596309" target="_blank" rel="noopener">http://blog.csdn.net/lisonglisonglisong/article/details/41596309</a><br>最长递增子序列<br><a href="http://blog.csdn.net/u013074465/article/details/45442067" target="_blank" rel="noopener">http://blog.csdn.net/u013074465/article/details/45442067</a></p>
<h3 id="0x03-图算法"><a href="#0x03-图算法" class="headerlink" title="0x03 图算法"></a>0x03 图算法</h3><p>图算法之最短路径（Dijkstra）<br><a href="https://www.cnblogs.com/nigang/p/3658990.html" target="_blank" rel="noopener">https://www.cnblogs.com/nigang/p/3658990.html</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>重拾Python之旅</title>
    <url>/blog/34/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#coding:utf-8</span><br><span class="line"></span><br><span class="line"># http://www.he11oworld.com/course/54</span><br><span class="line"></span><br><span class="line"># linux上必须写 #!/usr/bin/env python 它能够引导程序找到python的解析器，也就是说，不管你这个文件保存在什么地方，这个程序都能执行，而不用制定Python的安装路径。</span><br><span class="line"># 如果是Windows操作系统，则不必写。</span><br><span class="line"># #coding:utf-8</span><br><span class="line"></span><br><span class="line"># #单行注释</span><br><span class="line"># </span><br><span class="line"># &apos;&apos;&apos;</span><br><span class="line"># 多行注释</span><br><span class="line"># &apos;&apos;&apos;</span><br><span class="line"># </span><br><span class="line"># &quot;&quot;&quot;</span><br><span class="line"># 或多行注释</span><br><span class="line"># &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># python3:</span><br><span class="line"></span><br><span class="line">python支持&amp;|^位运算</span><br><span class="line"></span><br><span class="line"># bool运算符</span><br><span class="line">and #&amp;&amp;</span><br><span class="line">or #||</span><br><span class="line">not #!</span><br><span class="line"></span><br><span class="line">3//2	#1		直接去掉小数</span><br><span class="line">3/2		#1.5	不管是否整除都输出小数</span><br><span class="line">4/2		#1.0</span><br><span class="line">2**8	#256</span><br><span class="line"># python没有++和--</span><br><span class="line"></span><br><span class="line">type(10**100)</span><br><span class="line">#&lt;type &apos;long&apos;&gt;	py2</span><br><span class="line">#&lt;class &apos;int&apos;&gt;	py3</span><br><span class="line">#两个版本有区别，在Python 3中，不再有long类型对象了，都归类为int类型。</span><br><span class="line"></span><br><span class="line">id(233)</span><br><span class="line"># Help on built-in function id in module builtins:</span><br><span class="line"></span><br><span class="line"># id(obj, /)</span><br><span class="line">#     Return the identity of an object.</span><br><span class="line"></span><br><span class="line">#     This is guaranteed to be unique among simultaneously existing objects.</span><br><span class="line">#     (CPython uses the object&apos;s memory address.)</span><br><span class="line"></span><br><span class="line"># 除了使用%求余数，还有内建函数divmod()——返回的是商和余数。</span><br><span class="line">divmod(5, 2)	#表示5除以2，返回了商和余数</span><br><span class="line"># (2, 1)</span><br><span class="line">divmod(9, 2)</span><br><span class="line"># (4, 1)</span><br><span class="line">divmod(5.0, 2)</span><br><span class="line"># (2.0, 1.0)</span><br><span class="line"># Help on built-in function divmod in module builtins:</span><br><span class="line"></span><br><span class="line"># divmod(x, y, /)</span><br><span class="line">#     Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.</span><br><span class="line"></span><br><span class="line"># round</span><br><span class="line"># adj. 	圆形的; 弧形的; 丰满的，肥胖的; 整数的;</span><br><span class="line"># adv. 	到处; 在周围; 迂回地; 朝反方向;</span><br><span class="line"># prep. 	大约; 绕过，环绕; （表示位置） 在…四周; 附近;</span><br><span class="line">round(1.22222,2)	#四舍五入，但有时由于十进制转二进制的问题导致结果不准确</span><br><span class="line">#1.22</span><br><span class="line">round(2.235, 2)</span><br><span class="line"># 2.23                #应该是：2.24</span><br><span class="line"># Help on built-in function round in module builtins:</span><br><span class="line"></span><br><span class="line"># round(...)</span><br><span class="line">#     round(number[, ndigits]) -&gt; number</span><br><span class="line"></span><br><span class="line">#     Round a number to a given precision in decimal digits (default 0 digits).</span><br><span class="line">#     This returns an int when called with one argument, otherwise the</span><br><span class="line">#     same type as the number. ndigits may be negative.</span><br><span class="line"></span><br><span class="line">math.pow(4, 2)</span><br><span class="line"># 16</span><br><span class="line">#	math.pow(x,y)等价于x ** y</span><br><span class="line"># Help on built-in function pow in module builtins:</span><br><span class="line"></span><br><span class="line"># pow(x, y, z=None, /)</span><br><span class="line">#     Equivalent to x**y (with two arguments) or x**y % z (with three arguments)</span><br><span class="line"></span><br><span class="line">#     Some types, such as ints, are able to use a more efficient algorithm when</span><br><span class="line">#     invoked using the three argument form.</span><br><span class="line"></span><br><span class="line">print(&quot;123\b123&quot;)#&apos;\b&apos;等于backspace键，会在光标处删去一个字符并前移</span><br><span class="line">#12123</span><br><span class="line">print(&quot;123\000123&quot;)</span><br><span class="line">#123 123</span><br><span class="line"># 转义字符描述</span><br><span class="line"># \(在行尾时) 续行符</span><br><span class="line"># \反斜杠符号</span><br><span class="line"># \&apos;单引号</span><br><span class="line"># \&quot;双引号</span><br><span class="line"># \a响铃</span><br><span class="line"># \b退格(Backspace)</span><br><span class="line"># \e转义</span><br><span class="line"># \000空</span><br><span class="line"># \n换行</span><br><span class="line"># \v纵向制表符</span><br><span class="line"># \t横向制表符</span><br><span class="line"># \r回车</span><br><span class="line"># \f换页</span><br><span class="line"># \oyy八进制数，yy代表的字符，例如：\o12代表换行</span><br><span class="line"># \xyy十六进制数，yy代表的字符，例如：\x0a代表换行</span><br><span class="line"># \other其它的字符以普通格式输出，如\q输出\q</span><br><span class="line"></span><br><span class="line"># str类型切片[x:y:z]	z步长,z不可为0,z不写默认为1</span><br><span class="line">lang = &quot;012345678&quot;</span><br><span class="line"># 从x开始以z为步长,满足在x与y直接且不等于y的位置的所有元素</span><br><span class="line">lang[:1]</span><br><span class="line"># &apos;0&apos;</span><br><span class="line"># 若什么都没截取到，返回 &apos;&apos;</span><br><span class="line">lang[:0]</span><br><span class="line"># &apos;&apos;</span><br><span class="line">lang[:9]</span><br><span class="line"># &apos;012345678&apos;</span><br><span class="line"># 若x或y的值为正数或零，则“边界指针”从字符串的左边数起，</span><br><span class="line"># 若为负数，则先按绝对值从右边数起转换为对应的正数</span><br><span class="line">lang = &quot;012345678&quot;</span><br><span class="line"># 		012345678 正数索引</span><br><span class="line"># 		-9-8-7-6-5-4-3-2-1 负数索引</span><br><span class="line"># 当x或者y不写时,看z,</span><br><span class="line"># 若z为正,则x默认为0,y默认为总长度,</span><br><span class="line"># 若z为负,则y默认为 -1 (不转换为正数),x默认为 总长度 - 1.</span><br><span class="line">lang[-1:]	# == lang[8:]</span><br><span class="line"># &apos;8&apos;</span><br><span class="line">lang[:-1]	# == lang[:8]</span><br><span class="line"># &apos;01234567&apos;</span><br><span class="line">lang[1:7:2]</span><br><span class="line"># &apos;135&apos;</span><br><span class="line">lang[1:7:-2]</span><br><span class="line"># &apos;&apos;</span><br><span class="line">lang[7:1:-2]</span><br><span class="line"># &apos;753&apos;</span><br><span class="line">lang[:7:2]	# == lang[0:7:2]</span><br><span class="line"># &apos;0246&apos;</span><br><span class="line">lang[:5:-2]</span><br><span class="line"># &apos;86&apos;</span><br><span class="line">lang[-1::-2]	#== lang[8::-2]</span><br><span class="line"># &apos;86420&apos;</span><br><span class="line"></span><br><span class="line">ord(&apos;a&apos;)</span><br><span class="line"># 97	#&apos;a&apos;的Unicode码(与ascii一致)</span><br><span class="line">ord(&apos; &apos;)</span><br><span class="line"># 32	#&apos; &apos;的Unicode码(与ascii一致)</span><br><span class="line"># Help on built-in function ord in module builtins:</span><br><span class="line"></span><br><span class="line"># ord(c, /)</span><br><span class="line">#     Return the Unicode code point for a one-character string.</span><br><span class="line"></span><br><span class="line">chr(97)</span><br><span class="line"># &apos;a&apos;</span><br><span class="line"># Help on built-in function chr in module builtins:</span><br><span class="line"></span><br><span class="line"># chr(i, /)</span><br><span class="line">#     Return a Unicode string of one character with ordinal i; 0 &lt;= i &lt;= 0x10ffff.</span><br><span class="line"></span><br><span class="line">cmp()</span><br><span class="line"># py3取消了 cmp() 内建函数，改用 &gt; &lt; ==比较字符串</span><br><span class="line"></span><br><span class="line"># is == 的区别</span><br><span class="line"># is比较的是id，比较判断的是对象间的唯一身份标识</span><br><span class="line"># ==比较的是值value是否相等，取决于__eq__()</span><br><span class="line"></span><br><span class="line">#关于 bool 类型</span><br><span class="line"># python 没有 ! 运算符，改用 not 运算符，对 bool 类型取反</span><br><span class="line">!True</span><br><span class="line">#   File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">#     !True</span><br><span class="line">#     ^</span><br><span class="line"># SyntaxError: invalid syntax</span><br><span class="line">not True</span><br><span class="line"># False</span><br><span class="line"></span><br><span class="line"># 在python中 None,  False, 空字符串&quot;&quot;, 0, 空列表[], 空字典&#123;&#125;, 空元组()都相当于False</span><br><span class="line"></span><br><span class="line"># 格式化字符串 %</span><br><span class="line">&quot;I like %s&quot; % &quot;python&quot;</span><br><span class="line"># &apos;I like python&apos;</span><br><span class="line">&quot;%s like %s&quot; % (&quot;imlk&quot;,&quot;python&quot;)</span><br><span class="line"># &apos;imlk like python&apos;</span><br><span class="line"># 多个参数时使用 tuple (元组)</span><br><span class="line">&quot;%(name)s like %(what)s&quot; % &#123;&apos;name&apos;:&apos;imlk&apos;, &apos;what&apos;:&apos;python&apos;&#125;</span><br><span class="line"># &apos;imlk like python&apos;</span><br><span class="line"># &quot;%(name)s like %(what)s&quot; % &#123;&apos;name&apos;:&apos;imlk&apos;, &apos;what&apos;:&apos;python&apos;&#125;</span><br><span class="line">#		  ^				^</span><br><span class="line"># 配合字典使用注意标注参数类型</span><br><span class="line"></span><br><span class="line"># 格式化字符串 format</span><br><span class="line"># 占位符</span><br><span class="line"># &#123;[序号或唯一标识符][若该占位符参数为列表,此处可索引列表中元素,如[1]]:[填充字符][对齐方式 &lt;^&gt;(&lt;是字符默认,&gt;是整数和浮点数默认)][宽度][.n若明确参数类型f,则表示小数点后精度n,若不明确,对于str,截取前n个字符,对于浮点型,用科学记数法表示并把e以前的数字个数限制为n个][参数类型,如f,d,b二进制,o八进制,x十六进制]&#125;</span><br><span class="line">&quot;&#123;&#125; like &#123;&#125;&quot; .format(&quot;imlk&quot;,&quot;python&quot;)</span><br><span class="line"># &apos;imlk like python&apos;</span><br><span class="line">&quot;&#123;1&#125; like &#123;0&#125;&quot; .format(&quot;python&quot;,&quot;imlk&quot;)#指定序号</span><br><span class="line"># &apos;imlk like python&apos;</span><br><span class="line">&quot;&#123;name&#125;s like &#123;what&#125;&quot; .format(name =&apos;imlk&apos;, what=&apos;python&apos;)#这样写,函数内部得到的是一个字典&#123;&apos;name&apos;:&apos;imlk&apos;, &apos;what&apos;:&apos;python&apos;&#125;</span><br><span class="line"># &apos;imlks like python&apos;</span><br><span class="line">&apos;&#123;0[0]&#125; like &#123;0[1]&#125;&apos;.format(l)</span><br><span class="line"># &apos;imlk like python&apos;</span><br><span class="line">&apos;&#123;:20&#125;&apos;.format(111)</span><br><span class="line"># &apos;                 111&apos;</span><br><span class="line">&apos;&#123;:20&#125;&apos;.format(111.0)</span><br><span class="line"># &apos;               111.0&apos;</span><br><span class="line">&apos;&#123;:20&#125;&apos;.format(&apos;111&apos;)</span><br><span class="line"># &apos;111                 &apos;</span><br><span class="line">&apos;&#123;:20.2&#125;&apos;.format(111.0)</span><br><span class="line"># &apos;             1.1e+02&apos;</span><br><span class="line">&apos;&#123;:20.3&#125;&apos;.format(111.1111)</span><br><span class="line"># &apos;            1.11e+02&apos;</span><br><span class="line">&apos;&#123;:20.2f&#125;&apos;.format(111.1111)</span><br><span class="line"># &apos;              111.11&apos;</span><br><span class="line">&apos;&#123;:20.4&#125;&apos;.format(&apos;111.1111&apos;)</span><br><span class="line"># &apos;111\.                &apos;</span><br><span class="line"></span><br><span class="line"># Help on method_descriptor:</span><br><span class="line"></span><br><span class="line"># format(...)</span><br><span class="line">#     S.format(*args, **kwargs) -&gt; str</span><br><span class="line"></span><br><span class="line">#     Return a formatted version of S, using substitutions from args and kwargs.</span><br><span class="line">#     The substitutions are identified by braces (&apos;&#123;&apos; and &apos;&#125;&apos;).</span><br><span class="line"></span><br><span class="line"># 可变长度函数参数</span><br><span class="line"># *args 表示任何多个无名参数，它是一个 tuple (元组)</span><br><span class="line"># **kwargs 表示关键字参数，它是一个dict,字典中的 key 是传入参数的名称的 字符串 ,value 是传入参数等号后的值</span><br><span class="line"># 同时使用*args和**kwargs时，必须*args参数列要在**kwargs前</span><br><span class="line"></span><br><span class="line"># 可将元组作为参数列表传入</span><br><span class="line"># 例如:</span><br><span class="line">t = (&quot;python&quot;,&quot;imlk&quot;)</span><br><span class="line">&quot;&#123;1&#125; like &#123;0&#125;&quot; .format(*t)	# *接元组表示把元组解开作为参数传入</span><br><span class="line"># &apos;imlk like python&apos;</span><br><span class="line"># 同理可将字典作为参数列表传入</span><br><span class="line"># 例如:</span><br><span class="line">d = &#123;&apos;name&apos;:&apos;imlk&apos;, &apos;what&apos;:&apos;python&apos;&#125;</span><br><span class="line">&quot;&#123;name&#125; like &#123;what&#125;&quot; .format(**d)# **接字典表示把字典解开作为参数传入</span><br><span class="line"># &apos;imlk like python&apos;</span><br><span class="line"></span><br><span class="line"># 参考:</span><br><span class="line"># https://www.cnblogs.com/fengmk2/archive/2008/04/21/1163766.html</span><br><span class="line"># https://www.cnblogs.com/benric/p/4965224.html</span><br><span class="line"></span><br><span class="line"># 去除字符串两端的空格,返回去除后的字符串,源串不变,同类有lstrip()左,rstrip()右</span><br><span class="line"># str.strip()</span><br><span class="line"># Help on method_descriptor:</span><br><span class="line"></span><br><span class="line"># strip(...)</span><br><span class="line">#     S.strip([chars]) -&gt; str</span><br><span class="line"></span><br><span class="line">#     Return a copy of the string S with leading and trailing</span><br><span class="line">#     whitespace removed.</span><br><span class="line">#     If chars is given and not None, remove characters in chars instead.</span><br><span class="line"></span><br><span class="line"># [] list 列表</span><br><span class="line"># 类型不限 元素类型可异 有序 元素可重复 内容可变(原地改变,id不变)(append,insert,pop,extend等) 不可做为dic的key</span><br><span class="line">list = [1,&apos;233&apos;,&apos;imlk&apos;,True]</span><br><span class="line">bool(list)	#判断是否空列表若列表为空则返回False</span><br><span class="line">int(list)	#不合法！！！！！</span><br><span class="line"></span><br><span class="line"># 长度</span><br><span class="line">len(list)</span><br><span class="line"></span><br><span class="line"># +，连接两个序列</span><br><span class="line"># *，重复列表中的所有元素</span><br><span class="line"># in 判断是否在列表中</span><br><span class="line"></span><br><span class="line"># 最大最小</span><br><span class="line">max(list)</span><br><span class="line">min(list)</span><br><span class="line"></span><br><span class="line"># 列表比较</span><br><span class="line"># 同 str 中一样 cmp()在py3已经废弃,改用 &lt; == &gt;</span><br><span class="line"># 按元素序号从左到右依次比较,若遇到类型不符则报错</span><br><span class="line">list1 = [1,2]</span><br><span class="line">list2 = [1,1]</span><br><span class="line">list1 &lt; list2</span><br><span class="line"># False</span><br><span class="line">list2 = [1,&apos;1&apos;]</span><br><span class="line">list1 &lt; list2</span><br><span class="line"># Traceback (most recent call last):</span><br><span class="line">#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line"># TypeError: unorderable types: int() &lt; str()</span><br><span class="line">list2 = [2,&apos;1&apos;]</span><br><span class="line">list1 &lt; list2</span><br><span class="line"># True</span><br><span class="line"></span><br><span class="line"># 列表反转</span><br><span class="line">list[::-1]</span><br><span class="line"># 或</span><br><span class="line">reversed(list)#返回一个迭代器</span><br><span class="line"></span><br><span class="line"># list 中的每一个位置实际上维护的是对对象的引用</span><br><span class="line">l</span><br><span class="line"># [&apos;imlk&apos;, &apos;python&apos;]</span><br><span class="line">l.append(l)</span><br><span class="line">l</span><br><span class="line"># [&apos;imlk&apos;, &apos;python&apos;, [...]]</span><br><span class="line">l[2]</span><br><span class="line"># [&apos;imlk&apos;, &apos;python&apos;, [...]]</span><br><span class="line">l[2]</span><br><span class="line"># [&apos;imlk&apos;, &apos;python&apos;, [...]]</span><br><span class="line">l[2][2][2][2]</span><br><span class="line"># [&apos;imlk&apos;, &apos;python&apos;, [...]]</span><br><span class="line">li = [&apos;emmmm&apos;]</span><br><span class="line">l.append(li)</span><br><span class="line">l</span><br><span class="line"># [&apos;imlk&apos;, &apos;python&apos;, [...], [&apos;emmmm&apos;]]</span><br><span class="line">li.append(&apos;233&apos;)</span><br><span class="line">l</span><br><span class="line"># [&apos;imlk&apos;, &apos;python&apos;, [...], [&apos;emmmm&apos;, &apos;233&apos;]]</span><br><span class="line">l.extend(l)	#将一共可迭代的对象的全体内容加到该列表中</span><br><span class="line">l</span><br><span class="line"># [&apos;imlk&apos;, &apos;python&apos;, [...], [&apos;emmmm&apos;, &apos;233&apos;], &apos;imlk&apos;, &apos;python&apos;, [...], [&apos;emmmm&apos;, &apos;233&apos;]]</span><br><span class="line"># Help on method_descriptor:</span><br><span class="line"></span><br><span class="line"># extend(...)</span><br><span class="line">#     L.extend(iterable) -&gt; None -- extend list by appending elements from the iterable</span><br><span class="line"></span><br><span class="line">l.count(&apos;imlk&apos;)	#找出某个元素出现的次数</span><br><span class="line"># 2</span><br><span class="line"></span><br><span class="line"># attribute</span><br><span class="line"># vt.	认为…是; 把…归于; 把…品质归于某人; 认为某事[物]属于某人[物];</span><br><span class="line"># n.	属性; （人或物的） 特征; 价值; [语法学] 定语;</span><br><span class="line">hasattr(lang, &apos;__iter__&apos;)</span><br><span class="line"># 判断某个类或者对象,模块(module)是否有某种属性,函数</span><br><span class="line"># Help on built-in function hasattr in module builtins:</span><br><span class="line"></span><br><span class="line"># hasattr(obj, name, /)</span><br><span class="line">#     Return whether the object has an attribute with the given name.</span><br><span class="line"></span><br><span class="line">#     This is done by calling getattr(obj, name) and catching AttributeError.</span><br><span class="line"></span><br><span class="line"># 查看语言保留字</span><br><span class="line">import keyword</span><br><span class="line">keyword.kwlist</span><br><span class="line"></span><br><span class="line"># whitespace</span><br><span class="line"># 网络 	空白符; 空白字符; 空格; 白空格; 白空间;</span><br><span class="line"># separator</span><br><span class="line"># n. 	分离器，分离装置; 防胀器; </span><br><span class="line">s = &quot;I am, writing\npython\tbook on line&quot; #这个字符串中有空格，逗号，换行\n，tab缩进\t 符号</span><br><span class="line">print s #输出之后的样式</span><br><span class="line"># I am, writing</span><br><span class="line"># python book on line</span><br><span class="line">s.split() #用split(),但是括号中不输入任何参数</span><br><span class="line"># [&apos;I&apos;, &apos;am,&apos;, &apos;writing&apos;, &apos;python&apos;, &apos;book&apos;, &apos;on&apos;, &apos;line&apos;]</span><br><span class="line"># 如果split()不输入任何参数，显示就是见到任何空白符号，就用其分割了。</span><br><span class="line"></span><br><span class="line"># Help on method_descriptor:</span><br><span class="line"></span><br><span class="line"># split(...)</span><br><span class="line">#     S.split(sep=None, maxsplit=-1) -&gt; list of strings</span><br><span class="line"></span><br><span class="line">#     Return a list of the words in S, using sep as the</span><br><span class="line">#     delimiter string.  If maxsplit is given, at most maxsplit</span><br><span class="line">#     splits are done. If sep is not specified or is None, any</span><br><span class="line">#     whitespace string is a separator and empty strings are</span><br><span class="line">#     removed from the result.</span><br><span class="line"></span><br><span class="line"># () tuple 元组</span><br><span class="line"># 类型不限 元素类型可异 有序 长度不可变 元素可重复 速度快 相当于常量 可以作为dic的key 可用在字符串的格式化中</span><br><span class="line">t = 1,&quot;23&quot;,[123,&quot;abc&quot;],(&quot;python&quot;,&quot;learn&quot;)   #元素多样性，近list</span><br><span class="line">t</span><br><span class="line"># (1, &apos;23&apos;, [123, &apos;abc&apos;], (&apos;python&apos;, &apos;learn&apos;))</span><br><span class="line"># 元组中只有一个元素时，应该加上逗号,以免造成误解	</span><br><span class="line">t = (3)</span><br><span class="line">type(t)</span><br><span class="line"># &lt;class &apos;int&apos;&gt;</span><br><span class="line">t = (3,)</span><br><span class="line">type(t)</span><br><span class="line"># &lt;class &apos;tuple&apos;&gt;</span><br><span class="line"></span><br><span class="line"># &#123;&#125; dict 字典</span><br><span class="line"># 键/值对 原地修改 key不可重复 内容可变 键key必须是不可改变的数据类型，值value可以是任意类型</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"># 利用元组建构字典</span><br><span class="line">name = ([&quot;first&quot;, &quot;Google&quot;], [&quot;second&quot;, &quot;Yahoo&quot;])</span><br><span class="line">website = dict(name)</span><br><span class="line">website</span><br><span class="line"># &#123;&apos;second&apos;: &apos;Yahoo&apos;, &apos;first&apos;: &apos;Google&apos;&#125;</span><br><span class="line"># 增加键值对</span><br><span class="line">d[&apos;name&apos;] = &apos;imlk&apos;</span><br><span class="line">d</span><br><span class="line"># &#123;&apos;name&apos;: &apos;imlk&apos;&#125;</span><br><span class="line"># 删除键值对</span><br><span class="line">del d[&apos;name&apos;]</span><br><span class="line"># 清空dict</span><br><span class="line">d.clear()</span><br><span class="line">d</span><br><span class="line"># &#123;&#125;</span><br><span class="line"># 检查字典中是否含有某个key</span><br><span class="line">&apos;name&apos; in d</span><br><span class="line"># False</span><br><span class="line">d[&apos;name&apos;] = &apos;imlk&apos;</span><br><span class="line"># 通过key获取字典中的value</span><br><span class="line">d[&apos;name&apos;]</span><br><span class="line">&apos;imlk&apos;</span><br><span class="line"># 或者</span><br><span class="line">d.get(&apos;name&apos;)	#若不存在则返回None</span><br><span class="line"># Help on method_descriptor:</span><br><span class="line"></span><br><span class="line"># get(...)</span><br><span class="line">#     D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</span><br><span class="line"></span><br><span class="line"># Help on method_descriptor:</span><br><span class="line"></span><br><span class="line"># setdefault(...)</span><br><span class="line">#     D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</span><br><span class="line"></span><br><span class="line"># Python只存储基本类型的数据，比如int、str，对于不是基础类型的，比如刚才字典的值是列表，Python不会在被复制的那个对象中重新存储，而是用引用的方式，指向原来的值。</span><br><span class="line"># 可变集合都是unhashable类型的。</span><br><span class="line"></span><br><span class="line"># 数据类型的拷贝</span><br><span class="line">l = [&apos;imlk&apos;,&apos;python&apos;]</span><br><span class="line">li = l.copy() #list,dict支持copy，tuple不支持</span><br><span class="line">(1,).copy()</span><br><span class="line"># Traceback (most recent call last):</span><br><span class="line">#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line"># AttributeError: &apos;tuple&apos; object has no attribute &apos;copy&apos;</span><br><span class="line"></span><br><span class="line"># 深拷贝</span><br><span class="line">import copy</span><br><span class="line">li = copy.deepcopy(l)</span><br><span class="line"></span><br><span class="line"># set([]) 集合 元素必须是hashable的(不能含有list dict set等。。。) 元素类型可异 不可重复 无序，不可索引，内容可变(unhashable) 原地修改</span><br><span class="line"># &#123;&#125; #代表空字典，要建立空集合，不得不使用set()。</span><br><span class="line"></span><br><span class="line"># frozenset([]) 不可变集合 与 set([]) 区别是hashable，不可变</span><br><span class="line"></span><br><span class="line"># 集合运算</span><br><span class="line">a = set(&apos;python&apos;)</span><br><span class="line">b = set(&apos;python3&apos;)</span><br><span class="line">a</span><br><span class="line"># &#123;&apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;p&apos;, &apos;o&apos;, &apos;n&apos;&#125;</span><br><span class="line">b</span><br><span class="line"># &#123;&apos;y&apos;, &apos;t&apos;, &apos;3&apos;, &apos;h&apos;, &apos;p&apos;, &apos;o&apos;, &apos;n&apos;&#125;</span><br><span class="line"># 集合相等</span><br><span class="line">a == b</span><br><span class="line"># False</span><br><span class="line"># 子集</span><br><span class="line">a &lt; b</span><br><span class="line"># True</span><br><span class="line"># 超集</span><br><span class="line">a &gt; b</span><br><span class="line"># False</span><br><span class="line"># 并集</span><br><span class="line">a | b</span><br><span class="line"># &#123;&apos;y&apos;, &apos;t&apos;, &apos;3&apos;, &apos;h&apos;, &apos;p&apos;, &apos;o&apos;, &apos;n&apos;&#125;</span><br><span class="line"># 交集</span><br><span class="line">a &amp; b</span><br><span class="line"># &#123;&apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;p&apos;, &apos;o&apos;, &apos;n&apos;&#125;</span><br><span class="line"># A相对B的差（补）</span><br><span class="line">a - b</span><br><span class="line"># set()</span><br><span class="line">b - a</span><br><span class="line"># &#123;&apos;3&apos;&#125;</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"># Help on built-in function print in module builtins:</span><br><span class="line"></span><br><span class="line"># print(...)</span><br><span class="line">#     print(value, ..., sep=&apos; &apos;, end=&apos;\n&apos;, file=sys.stdout, flush=False)</span><br><span class="line"></span><br><span class="line">#     Prints the values to a stream, or to sys.stdout by default.</span><br><span class="line">#     Optional keyword arguments:</span><br><span class="line">#     file:  a file-like object (stream); defaults to the current sys.stdout.</span><br><span class="line">#     sep:   string inserted between values, default a space.</span><br><span class="line">#     end:   string appended after the last value, default a newline.</span><br><span class="line">#     flush: whether to forcibly flush the stream.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>[笔记]JavaScript入门啦</title>
    <url>/blog/36/</url>
    <content><![CDATA[<p>参考资料：<br>ECMAScript 6 入门:<br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p>
<p><strong>以下所有代码示例均为在nodejs交互模式下进行的，环境：Linux</strong></p>
<ul>
<li>JavaScript不区分整数和浮点数，统一用Number表示;</li>
<li><p>js注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>js等号比较运算符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">== <span class="comment">// 会自动转换数据类型再比较，很多时候会得到非常诡异的结果</span></span><br><span class="line"></span><br><span class="line">=== <span class="comment">// 不会自动转换数据类型，如果数据类型不一致，直接返回false，一致的话再比较</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实际时常用<code>===</code>而不用<code>==</code></p>
</li>
<li>使用<code>isNaN()</code>函数判断是否为<code>NaN</code></li>
<li>浮点数运算有误差</li>
<li><code>%</code>求余运算</li>
<li><code>node</code>交互模式中，<code>_</code>表示上一次语句执行成功后的结果</li>
<li><p><code>null</code>不等于<code>0</code>也不等于<code>&#39;&#39;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; null == 0</span><br><span class="line">false</span><br><span class="line">&gt; null === 0</span><br><span class="line">false</span><br><span class="line">&gt; null == &apos;&apos;</span><br><span class="line">false</span><br><span class="line">&gt; null === &apos;&apos;</span><br><span class="line">false</span><br><span class="line">&gt; null == null</span><br><span class="line">true</span><br><span class="line">&gt; null === null</span><br><span class="line">true</span><br><span class="line">&gt; 0 == &apos;&apos;</span><br><span class="line">true</span><br><span class="line">&gt; 0 === &apos;&apos;</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
</li>
<li><p>js中还有一个特殊的元素<code>undefined</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; undefined === undefined</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
</li>
<li><p>js中<code>var</code>与不加<code>var</code>的区别：<a href="https://www.cnblogs.com/liuna/p/6140901.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuna/p/6140901.html</a></p>
</li>
<li>js中<code>typeof</code>关键字的使用：<a href="https://blog.csdn.net/z18842589113/article/details/53315910" target="_blank" rel="noopener">https://blog.csdn.net/z18842589113/article/details/53315910</a></li>
<li><p><code>typeof</code>运算符把类型信息当作字符串返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; i = 1</span><br><span class="line">1</span><br><span class="line">&gt; typeof(i)</span><br><span class="line">&apos;number&apos;</span><br><span class="line"></span><br><span class="line">&gt; i = &quot;imlk&quot;</span><br><span class="line">&apos;imlk&apos;</span><br><span class="line">&gt; typeof(i)</span><br><span class="line">&apos;string&apos;</span><br><span class="line"></span><br><span class="line">&gt; i = true</span><br><span class="line">true</span><br><span class="line">&gt; typeof(i)</span><br><span class="line">&apos;boolean&apos;</span><br><span class="line"></span><br><span class="line">&gt; typeof(this)</span><br><span class="line">&apos;object&apos;</span><br><span class="line"></span><br><span class="line">&gt; i = function()&#123;</span><br><span class="line">... this.console.log(&quot;imlk&quot;);</span><br><span class="line">... &#125;</span><br><span class="line">[Function: i]</span><br><span class="line">&gt; typeof(i)</span><br><span class="line">&apos;function&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Javascript的<code>delete</code>与C++不同，它不会删除i指向的对象，而是删除i这个属性本身。</p>
</li>
<li>Javascript中的对象都有一个方法<code>toString()</code>。</li>
<li><p>对类型为<code>Function</code>的对象执行<code>toString()</code>方法将打印函数的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; i = function(e)&#123;</span><br><span class="line">... console.log(e)</span><br><span class="line">... &#125;</span><br><span class="line">[Function: i]</span><br><span class="line">&gt; i</span><br><span class="line">[Function: i]</span><br><span class="line">&gt; i.toString()</span><br><span class="line">&apos;function (e)&#123;\nconsole.log(e)\n&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>js中的函数对象本身代表一个函数</p>
</li>
<li><p>js中构造一个函数对象（函数）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; function f1()&#123;&#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; var f2 = function()&#123;&#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);//anonymous匿名函数</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&gt; f1</span><br><span class="line">[Function: f1]</span><br><span class="line">&gt; f2</span><br><span class="line">[Function: f2]</span><br><span class="line">&gt; f3</span><br><span class="line">[Function: anonymous]</span><br><span class="line"></span><br><span class="line">&gt; f1.toString()</span><br><span class="line">&apos;function f1()&#123;&#125;&apos;</span><br><span class="line">&gt; f2.toString()</span><br><span class="line">&apos;function ()&#123;&#125;&apos;</span><br><span class="line">&gt; f3.toString()</span><br><span class="line">&apos;function anonymous(str\n/*``*/) &#123;\nconsole.log(str)\n&#125;&apos;</span><br><span class="line"></span><br><span class="line">&gt; f1.name</span><br><span class="line">&apos;f1&apos;</span><br><span class="line">&gt; f2.name</span><br><span class="line">&apos;f2&apos;</span><br><span class="line">&gt; f3.name</span><br><span class="line">&apos;anonymous&apos;</span><br><span class="line"></span><br><span class="line">&gt; f1.prototype</span><br><span class="line">f1 &#123;&#125;</span><br><span class="line">&gt; f2.prototype</span><br><span class="line">f2 &#123;&#125;</span><br><span class="line">&gt; f3.prototype</span><br><span class="line">anonymous &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JS所有内置对象属性和方法汇总：<a href="https://segmentfault.com/a/1190000011467723" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011467723</a></p>
</li>
<li><p>JavaScript 的 valueOf() 方法，返回<code>对象</code>的<code>原始值</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; b = new Boolean(true)</span><br><span class="line">[Boolean: true]</span><br><span class="line">&gt; typeof b</span><br><span class="line">&apos;object&apos;</span><br><span class="line">&gt; b.valueOf()</span><br><span class="line">true</span><br><span class="line">&gt; typeof b.valueOf()</span><br><span class="line">&apos;boolean&apos;</span><br><span class="line"></span><br><span class="line">&gt; s = new String(&apos;imlk&apos;)</span><br><span class="line">[String: &apos;imlk&apos;]</span><br><span class="line">&gt; typeof s</span><br><span class="line">&apos;object&apos;</span><br><span class="line">&gt; s.valueOf()</span><br><span class="line">&apos;imlk&apos;</span><br><span class="line">&gt; typeof s.valueOf()</span><br><span class="line">&apos;string&apos;</span><br><span class="line"></span><br><span class="line">&gt; n = new Number(2333)</span><br><span class="line">[Number: 2333]</span><br><span class="line">&gt; typeof n</span><br><span class="line">&apos;object&apos;</span><br><span class="line">&gt; n.valueOf()</span><br><span class="line">2333</span><br><span class="line">&gt; typeof n.valueOf()</span><br><span class="line">&apos;number&apos;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li><p>与<code>valueOf()</code>之相反的则是<code>new Object(obj)</code>，它将原始值转化为对应的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; a = 1;</span><br><span class="line">1</span><br><span class="line">&gt; b = new Object(a)</span><br><span class="line">[Number: 1]</span><br><span class="line">&gt; a == b</span><br><span class="line">true</span><br><span class="line">&gt; a === b</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>js中没有类</strong></p>
</li>
<li>js中创建对象的7种方式：<a href="http://www.jb51.net/article/106325.htm" target="_blank" rel="noopener">http://www.jb51.net/article/106325.htm</a><br>  1.工厂模式(在函数中构造对象并返回)<br>  2.构造函数模式(对函数使用<code>new</code>操作符，生成的对象的<code>constructor</code>属性指向构造函数)<br>  3.原型模式(每一个函数都有一个<code>prototype</code>(原型)属性，它指向一个<strong>对象</strong>，可以理解为共享的一个对象，这个对象是与构造函数挂钩的，所有实例共享它所包含的属性和方法，注意此时所有生成的对象所访问的原型中定义的对象都是同一个东西)<br>  4.组合使用构造函数模式和原型模式<br>  5.动态原型模式<br>  6.寄生构造函数模式<br>  7.稳妥构造函数模式</li>
<li><p>js中的对象,我们可以把ECMAScript的对象想象成散列表：无非就是一组名对值，其中值可以是数据或函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; b = &#123;&apos;one&apos;: &apos;emmm&apos;,&apos;t&apos;:23333&#125;</span><br><span class="line">&#123; one: &apos;emmm&apos;, t: 23333 &#125;</span><br><span class="line">&gt; for (var key in b)&#123;</span><br><span class="line">... console.log(key);</span><br><span class="line">... console.log(b[key]);</span><br><span class="line">... &#125;</span><br><span class="line">one</span><br><span class="line">emmm</span><br><span class="line">t</span><br><span class="line">23333</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>js的函数中有一个特殊的关键字<code>arguments</code>，因此可以支持可变长参数传递，这个<code>arguments</code>变量只可在函数中使用，是一个特殊的对象，与一个普通的对象相比，可以读取<code>arguments.length</code>属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; f1 = function(e)&#123;</span><br><span class="line">... console.log(typeof arguments);</span><br><span class="line">... console.log(arguments.length);</span><br><span class="line">... console.log(arguments);</span><br><span class="line">... &#125;</span><br><span class="line">[Function: f1]</span><br><span class="line">&gt; f1(1,2);</span><br><span class="line">object</span><br><span class="line">2</span><br><span class="line">&#123; &apos;0&apos;: 1, &apos;1&apos;: 2 &#125;</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>js中的<code>instanceof</code>关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; c = new f1(1,2);</span><br><span class="line">object</span><br><span class="line">2</span><br><span class="line">&#123; &apos;0&apos;: 1, &apos;1&apos;: 2 &#125;</span><br><span class="line">f1 &#123;&#125;</span><br><span class="line">&gt; c.constructor</span><br><span class="line">[Function: f1]</span><br><span class="line">&gt; c.constructor === f1</span><br><span class="line">true</span><br><span class="line">&gt; c instanceof f1</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
</li>
<li><p>exports 和 module.exports 的区别<br><a href="http://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="noopener">http://cnodejs.org/topic/5231a630101e574521e45ef8</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports 初始值为一个空对象 &#123;&#125;</span><br><span class="line">exports 是指向的 module.exports 的引用</span><br><span class="line">require() 返回的是 module.exports 而不是 exports</span><br></pre></td></tr></table></figure>
</li>
<li><p>exports 快捷方式<br><a href="http://nodejs.cn/api/modules.html#modules_exports_shortcut" target="_blank" rel="noopener">http://nodejs.cn/api/modules.html#modules_exports_shortcut</a><br><code>exports</code>变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋予<code>module.exports</code>的值。</p>
</li>
<li><p>js定义常量语法糖<code>const { PI }</code><br><a href="https://segmentfault.com/q/1010000011190967" target="_blank" rel="noopener">https://segmentfault.com/q/1010000011190967</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; PI &#125; = Math;</span><br><span class="line">实际上是语法糖，等价于：</span><br><span class="line">const PI = Math.PI</span><br></pre></td></tr></table></figure>
</li>
<li><p>js模块包装器<br><a href="http://nodejs.cn/api/modules.html#modules_the_module_wrapper" target="_blank" rel="noopener">http://nodejs.cn/api/modules.html#modules_the_module_wrapper</a><br>在执行模块代码之前，Node.js 会使用一个如下的函数包装器将其包装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">// 模块的代码实际上在这里</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>export<br>模块是独立的文件，该文件内部的所有的变量外部都无法获取。如果希望获取某个变量，必须通过export输出，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export var firstName = &apos;Michael&apos;;</span><br><span class="line">export var lastName = &apos;Jackson&apos;;</span><br><span class="line">export var year = 1958;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]读Android系统篇之----免root实现Hook系统服务拦截方法</title>
    <url>/blog/35/</url>
    <content><![CDATA[<p>第二篇读书笔记</p>
<p>拜读姜维大神的<a href="https://blog.csdn.net/jiangwei0910410003/article/details/52523679" target="_blank" rel="noopener">Android系统篇之—-免root实现Hook系统服务拦截方法</a></p>
<p>梳理了下思路，解决了疑惑</p>
<p>我们使用剪切板服务的时候是调用了<code>ContextImpl</code>的<code>getSystemService</code>方法</p>
<h4 id="ContextImpl的getSystemService方法"><a href="#ContextImpl的getSystemService方法" class="headerlink" title="ContextImpl的getSystemService方法"></a><code>ContextImpl</code>的<code>getSystemService</code>方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getSystemService(String name) &#123;</span><br><span class="line">    return SystemServiceRegistry.getSystemService(this, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法将返回<code>Object</code>类型对象，我们将它强制转换为一个<code>ClipboardManager</code>，也就是说它返回了一个<code>ClipboardManager</code>供我们使用。而这个方法最终将构造一个<code>ClipboardManager</code>，在<code>ClipboardManager</code>构造的过程中，将获取远端<code>Binder</code>并调用<code>IClipboard.Stub</code>的<code>asInterface</code>方法转化为<strong>本地代理对象</strong>保存在其中，</p>
<h4 id="ClipboardManager的一个构造函数"><a href="#ClipboardManager的一个构造函数" class="headerlink" title="ClipboardManager的一个构造函数"></a><code>ClipboardManager</code>的一个构造函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** &#123;@hide&#125; */</span><br><span class="line">public ClipboardManager(Context context, Handler handler) throws ServiceNotFoundException &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mService = IClipboard.Stub.asInterface(</span><br><span class="line">            ServiceManager.getServiceOrThrow(Context.CLIPBOARD_SERVICE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取远端<code>Binder</code>的操作其实是调用了<code>ServiceManager</code>中的<code>getService</code>方法，它返回的是一个远端<code>Binder</code>，实际上也就是一个<code>BinderProxy</code>（当然<code>ServiceManager</code>会把这个远端对象缓存到<code>sCache</code>中以应对频繁调用），姜维的文章里就是从这里切入，第一步先动态代理了这个<code>BinderProxy</code>。</p>
<blockquote>
<p>这里需要铭记一点，远端<code>Binder</code>需要调用<code>Stub</code>的<code>asInterface</code>方法转化为<strong>本地代理对象</strong>才能使用(上面说到在<code>ClipboardManager</code>的构造函数中，这一步骤<code>ClipboardManager</code>帮我们封装了这一操作)</p>
</blockquote>
<h4 id="ServiceManager中的getService方法"><a href="#ServiceManager中的getService方法" class="headerlink" title="ServiceManager中的getService方法"></a><code>ServiceManager</code>中的<code>getService</code>方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a reference to a service with the given name.</span><br><span class="line"> * </span><br><span class="line"> * @param name the name of the service to get</span><br><span class="line"> * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn&apos;t exist</span><br><span class="line"> */</span><br><span class="line">public static IBinder getService(String name) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        IBinder service = sCache.get(name);</span><br><span class="line">        if (service != null) &#123;</span><br><span class="line">            return service;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Binder.allowBlocking(getIServiceManager().getService(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;error in getService&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面继续解析姜维的文章中hook的流程，在上一步的动态代理之后，拦截了被代理对象（<code>BinderProxy</code>对象）的<code>queryLocalInterface</code>方法，下面是</p>
<h4 id="BinderProxy中queryLocalInterface的实现"><a href="#BinderProxy中queryLocalInterface的实现" class="headerlink" title="BinderProxy中queryLocalInterface的实现"></a><code>BinderProxy</code>中<code>queryLocalInterface</code>的实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public IInterface queryLocalInterface(String descriptor) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看见它直接返回了<code>null</code>，而这个方法是在哪里被调用的呢，反编译<code>framework.jar</code>发现，是在<code>IClipboard.Stub</code>中，这里<code>IClipboard</code>就是用<code>aidl</code>生成的，和我们自己生成的差不多<br>看看</p>
<h4 id="IClipboard-Stub的asInterface方法"><a href="#IClipboard-Stub的asInterface方法" class="headerlink" title="IClipboard.Stub的asInterface方法"></a><code>IClipboard.Stub</code>的<code>asInterface</code>方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static IClipboard asInterface(IBinder obj) &#123;</span><br><span class="line">    if (obj == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    if (iin == null || !(iin instanceof IClipboard)) &#123;</span><br><span class="line">        return new Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return (IClipboard) iin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到正题，姜维的文章里拦截了<code>queryLocalInterface</code>以后，一开始我以为它又动态代理了一个叫做<code>base</code>的对象，因为这里new了一个<code>HookBinderInvocationHandler</code>，传入的第一个参数就是<code>base</code>突然有点蒙这个<code>base</code>是哪里冒出来的，看看上下文，发现是在第一个动态代理的Handler的构造函数里，传入了一个<code>rawBinder</code>，赋值给了成员变量<code>base</code>了，而这个<code>rawBinder</code>，就是第一次代理中，被代理的那个远端<code>Binder</code>，我就有点纳闷了，代理两次干啥？，仔细想，这只是个构造函数啊，我想传进去什么和我要动态代理什么对象没有关系呀。<br>于是翻回去看，动态代理的接口是<code>this.iinterface</code>，看了下第一次动态代理的Handler的构造函数，看到<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.iinterface = Class.forName(&quot;android.content.IClipboard&quot;)</span><br></pre></td></tr></table></figure></p>
<p>仔细想想，这是要搞出来一个<code>IClipboard</code>啊，其实这个<code>IClipboard</code>我们前文接触过了，这里贴上<code>IClipboard</code>部分源码（主要看结构）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package android.content;</span><br><span class="line">······</span><br><span class="line">public interface IClipboard extends IInterface &#123;</span><br><span class="line"></span><br><span class="line">    public static abstract class Stub extends Binder implements IClipboard &#123;</span><br><span class="line">······</span><br><span class="line">        private static class Proxy implements IClipboard &#123;</span><br><span class="line">······</span><br></pre></td></tr></table></figure>
<p>梳理一遍，<br>第一次动态代理了远端<code>Binder</code>，Handler是<code>IClipboardHookBinderHandler</code>，<br>在第一次代理的Handler里面，拦截了<code>queryLocalInterface</code>方法，<br>这个方法是在<code>asInterface</code>里面调用的，<br>拦截以后，开始第二次动态代理，<br>用<code>IClipboard</code>这个接口合成了一个代理对象，Handler是<code>HookBinderInvocationHandler</code>，<br>把这个合成的代理对象<code>return</code>了！！！</p>
<p>没错，这里是关键，它直接把它作为<code>queryLocalInterface</code>方法的返回值<code>return</code>了</p>
<p>看一下原来的<a href="#BinderProxy中queryLocalInterface的实现">BinderProxy中queryLocalInterface的实现</a></p>
<p>再看一下<a href="#IClipboard.Stub的asInterface方法">IClipboard.Stub的asInterface方法</a></p>
<p>在<code>asInterface</code>方法里，我们合成的代理对象，赋值给了iin，接下来<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">if (iin == null || !(iin instanceof IClipboard)) &#123; //关键！！！！！</span><br><span class="line">    return new Proxy(obj); //没走这！！！</span><br><span class="line">&#125;</span><br><span class="line">return (IClipboard) iin; //走了这里，我们合成的代理对象被强制转换以后直接返回了，被用来之后进行剪切板的一些操作</span><br></pre></td></tr></table></figure></p>
<p>哇，几乎哭出来，看了那么久终于懂了关键部分，为什么作者不标记一下呢<br>/(ㄒoㄒ)/~~</p>
<p>我们比较一下：</p>
<p>hook前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[调用 getSystemService ]</span><br><span class="line"> --&gt; [ ClipboardManager 的构造函数]</span><br><span class="line"> --&gt; [间接调用了 ServiceManager 中的 getService ]</span><br><span class="line"> --&gt; [获得远端 Binder 对象]</span><br><span class="line"> --&gt; [调用 IClipboard.Stub 的 asInterface 并把远端对象传入]</span><br><span class="line"> --&gt; [获得 IClipboard.Stub.Proxy 对象]</span><br><span class="line"> --&gt; [后续使用]</span><br></pre></td></tr></table></figure>
<p>hook后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Hook开始]</span><br><span class="line"> --&gt; [主动反射调用 ServiceManager 中的 getService 并动态代理远端对象]</span><br><span class="line"> --&gt; [正常调用开始]</span><br><span class="line"> --&gt; [调用 getSystemService ]</span><br><span class="line"> --&gt; [ ClipboardManager 的构造函数]</span><br><span class="line"> --&gt; [间接调用了 ServiceManager 中的 getService ]</span><br><span class="line"> --&gt; [获得第一次动态代理生成的对象]</span><br><span class="line"> --&gt; [调用 IClipboard.Stub 的 asInterface 并把远端对象传入]</span><br><span class="line"> --&gt; [拦截 queryLocalInterface 并合成 IClipboard 接口的代理对象]</span><br><span class="line"> --&gt; [返回合成的代理对象]</span><br><span class="line"> --&gt; [后续使用]</span><br></pre></td></tr></table></figure>
<p>就这样，两次动态代理，第一次代理远端对象，拦截<code>queryLocalInterface</code>方法，第二次动态代理合成了一个实现了<code>IClipboard</code>接口的对象，骗过了<code>ClipboardManager</code>。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
        <tag>Binder</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>[文章集]数据结构</title>
    <url>/blog/37/</url>
    <content><![CDATA[<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>从头到尾彻底理解KMP：<br><a href="https://www.cnblogs.com/zhangtianq/p/5839909.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangtianq/p/5839909.html</a></p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>搜索二叉树的旋转操作和平衡判断：<br><a href="https://www.cnblogs.com/zhanghaiba/p/3537221.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhanghaiba/p/3537221.html</a></p>
<p>数据结构—平衡二叉树，树的平衡旋转：<br><a href="https://www.cnblogs.com/PerkinsZhu/p/5824015.html" target="_blank" rel="noopener">https://www.cnblogs.com/PerkinsZhu/p/5824015.html</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]hexo模块mdjsp的开发心得</title>
    <url>/blog/39/</url>
    <content><![CDATA[<p>第一次写npm插件，有点小激动，下面是写插件的坎坷之路</p>
<h2 id="0x00-开局错误"><a href="#0x00-开局错误" class="headerlink" title="0x00 开局错误"></a>0x00 开局错误</h2><ul>
<li>在<code>node_modules</code>文件夹下新建<code>hexo-mdjsp-util</code>文件夹，</li>
<li>新建<code>package.json</code>和<code>index.jsp</code>并填好内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-mdjsp-util&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这是网上的教程中查到的步骤依葫芦画瓢，好像没啥问题了，执行<code>hexo g</code>，我在<code>index.js</code>中只写了<code>console.log(&quot;mdjsp_loaded&quot;);</code>，但并没有看到任何输出</p>
<p>百度找遍了以后，遂上google<br>找到别人的博客：<br>编写Hexo插件<br><a href="http://xtutu.me/write-hexo-plugin/" target="_blank" rel="noopener">http://xtutu.me/write-hexo-plugin/</a></p>
<p>看了下原来是没在hexo中加依赖。。。</p>
<h2 id="0x01-祸不单行"><a href="#0x01-祸不单行" class="headerlink" title="0x01 祸不单行"></a>0x01 祸不单行</h2><p>加了依赖以后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-mdjsp-util&quot;: &quot;^0.0.1&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>执行<code>hexo</code><br>直接：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Plugin load failed: hexo-mdjsp-util</span><br><span class="line">TypeError: this.log is not a function</span><br><span class="line">    at /mnt/d/hexo/node_modules/hexo-mdjsp-util/index.js:9:6</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>google:</p>
<p>Hexo：如何解决 FATAL Cannot read property ‘code’ of undefined：<br><a href="http://meiweiping.cn/Hexo%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-FATAL-Cannot-read-property-code-of-undefined/" target="_blank" rel="noopener">http://meiweiping.cn/Hexo%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-FATAL-Cannot-read-property-code-of-undefined/</a><br>原来是末尾多了个<code>,</code><br>真恶心的错误啊</p>
<p>接下来的事情就是jsp语句匹配啦！<br>先找几个开源项目看看</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]第一次ZjDroid脱壳实战</title>
    <url>/blog/40/</url>
    <content><![CDATA[<p>看了那么多逆向破解的文章，总得来点实战的了，正所谓实践出真知嘛。</p>
<p>拜读了姜维大神的<a href="https://blog.csdn.net/jiangwei0910410003/article/details/52840602" target="_blank" rel="noopener">「Android中Xposed框架篇—基于Xposed的一款脱壳神器ZjDroid工具原理解析」</a>，准备来个应用动手试试了，想起我自己之前有个应用恰好是大数字加固的，于是想试试破自己的应用。<br>(纯粹是个人黑历史，就不贴应用链接了)。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>我手头的设备是版本是 Android7.1.2 电脑上也有Android4.4版本的模拟器（Android Emulator，已root和刷入Xposed，不知道怎么手动给模拟器刷root的同学参考这个<a href="https://android.stackexchange.com/questions/171442/root-android-virtual-device-with-android-7-1-1" target="_blank" rel="noopener">https://android.stackexchange.com/questions/171442/root-android-virtual-device-with-android-7-1-1</a>）</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先嘛，当然是要下载大名鼎鼎的ZjDroid模块了，这个脱壳工具是基于Xposed模块的，看了下该项目的github，似乎并没有给出ZjDroid现成的apk安装包，网上虽然是有找，但我还是选择自己手动编译了一下，</p>
<p>clone<br>导入AS</p>
<p>在解决了~几个问题~很多个问题以后总算是编译成功了。</p>
<p><strong>主要是为了解决导入库的问题和<code>multidex</code>的问题（为了支持低sdk版本的设备）</strong></p>
<p><strong>也算是学习了</strong></p>
<h3 id="在脱壳的边缘试探"><a href="#在脱壳的边缘试探" class="headerlink" title="在脱壳的边缘试探"></a>在脱壳的边缘试探</h3><p>把编译好的apk装进我的手机（Android 7.1.2），激活模块重启，连上电脑，按照教程里的方法，启动俩<code>cmd</code>一个用来看<code>logcat</code>输出，一个用来发送广播执行指令，</p>
<p>试了一个：<br>查看dex信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">am broadcast -a com.zjdroid.invoke --ei target 18881 --es cmd &apos;&#123;action:dump_dexinfo&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p><code>logcat</code>输出是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">04-27 21:00:19.798 12563 12563 D zjdroid-shell-com.imlk.BlackAndWhite: the cmd = dump_dexinfo</span><br><span class="line">04-27 21:00:19.805 12563 13323 D zjdroid-shell-com.imlk.BlackAndWhite: The DexFile Infomation -&gt;</span><br><span class="line">04-27 21:00:19.805 12563 13323 D zjdroid-shell-com.imlk.BlackAndWhite: filepath:/data/app/com.imlk.BlackAndWhite-1/base.apk mCookie:-1</span><br><span class="line">04-27 21:00:19.807 12563 13323 D zjdroid-shell-com.imlk.BlackAndWhite: End DexFile Infomation</span><br></pre></td></tr></table></figure></p>
<p>似乎有什么奇奇怪怪的地方。。<br><code>mCookie</code>的值是<code>-1</code>，不过看教程里面好像是一串没有规律的数字哇。心想可能是大数字又升级了，这种方案脱壳可能不能奏效。</p>
<p>不管了，继续试试：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">am broadcast -a com.zjdroid.invoke --ei target 8880 --es cmd &apos;&#123;&quot;action&quot;:&quot;backsmali&quot;,&quot;dexpath&quot;:&quot;/data/app/com.imlk.BlackAndWhite-1/base.apk&quot;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>WTF!<br>程序退出了！<br>看下<code>logcat</code>里的输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">04-27 22:16:56.475 18342 18342 D zjdroid-shell-com.imlk.BlackAndWhite: the cmd = backsmali</span><br><span class="line">04-27 22:16:56.487 18342 18734 D zjdroid-shell-com.imlk.BlackAndWhite: start disassemble the mCookie -1</span><br></pre></td></tr></table></figure></p>
<p>？？？？<br>戛然而止？？？</p>
<p>第一时间想到肯定和那个<code>-1</code>有关系，反正手头有<code>ZjDroid</code>的源码，看看到底是哪里崩了。<br>字符串搜索，走起！</p>
<h3 id="在修复的边缘试探"><a href="#在修复的边缘试探" class="headerlink" title="在修复的边缘试探"></a>在修复的边缘试探</h3><p>首先想看看执行<code>dump_dexinfo</code>命令的时候，输出的那个<code>-1</code>究竟是哪里来的，<br>到<code>ZjDroid</code>的源码里搜索<code>mCookie:</code><br>（这里有一个小技巧，到<code>github</code>的项目首页，顶栏可以指定在这个项目里搜索），</p>
<p>果然搜到一处<code>com.android.reverse.request.DumpDexInfoCommandHandler</code>中的<code>doAction()</code>方法输出了这个<code>-1</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DumpDexInfoCommandHandler implements CommandHandler &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void doAction() &#123;</span><br><span class="line">		HashMap&lt;String, DexFileInfo&gt; dexfileInfo = DexFileInfoCollecter.getInstance().dumpDexFileInfo();</span><br><span class="line">		Iterator&lt;DexFileInfo&gt; itor = dexfileInfo.values().iterator();</span><br><span class="line">		DexFileInfo info = null;</span><br><span class="line">		Logger.log(&quot;The DexFile Infomation -&gt;&quot;);</span><br><span class="line">		while (itor.hasNext()) &#123;</span><br><span class="line">			info = itor.next();</span><br><span class="line">			Logger.log(&quot;filepath:&quot;+ info.getDexPath()+&quot; mCookie:&quot;+info.getmCookie()); //这里输出啦</span><br><span class="line">		&#125;</span><br><span class="line">		Logger.log(&quot;End DexFile Infomation&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到as里面定位到这个文件，溯源到<code>com.android.reverse.collecter.DexFileInfoCollecter</code>的<code>dumpDexFileInfo()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public HashMap&lt;String, DexFileInfo&gt; dumpDexFileInfo() &#123;</span><br><span class="line">	HashMap&lt;String, DexFileInfo&gt; dexs = new HashMap&lt;String, DexFileInfo&gt;(dynLoadedDexInfo);</span><br><span class="line">	Object dexPathList = RefInvoke.getFieldOjbect(&quot;dalvik.system.BaseDexClassLoader&quot;, pathClassLoader, &quot;pathList&quot;);</span><br><span class="line">	Object[] dexElements = (Object[]) RefInvoke.getFieldOjbect(&quot;dalvik.system.DexPathList&quot;, dexPathList, &quot;dexElements&quot;);</span><br><span class="line">	DexFile dexFile = null;</span><br><span class="line">	for (int i = 0; i &lt; dexElements.length; i++) &#123;</span><br><span class="line">		dexFile = (DexFile) RefInvoke.getFieldOjbect(&quot;dalvik.system.DexPathList$Element&quot;, dexElements[i], &quot;dexFile&quot;);</span><br><span class="line">		String mFileName = (String) RefInvoke.getFieldOjbect(&quot;dalvik.system.DexFile&quot;, dexFile, &quot;mFileName&quot;);</span><br><span class="line">		int mCookie = RefInvoke.getFieldInt(&quot;dalvik.system.DexFile&quot;, dexFile, &quot;mCookie&quot;); //这里通过反射获取&quot;mCookie&quot;这个int类型的变量</span><br><span class="line">		DexFileInfo dexinfo = new DexFileInfo(mFileName, mCookie, pathClassLoader);</span><br><span class="line">		dexs.put(mFileName, dexinfo);</span><br><span class="line">	&#125;</span><br><span class="line">	return dexs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到：<br>源码中，通过反射获取”mCookie”这个int类型的变量，然后结果得到的是<code>-1</code>，看到这里我也没多想，就想去验证这个变量是否真的是<code>-1</code></p>
<p>想达到这个目的，首先我想到的是用as动态调试一波走起。</p>
<h3 id="尝试用动态调试找出-1"><a href="#尝试用动态调试找出-1" class="headerlink" title="尝试用动态调试找出-1"></a>尝试用动态调试找出-1</h3><p>结合上面的代码，可以总结出，应该是<br>BaseDexClassLoader中的<br>dexElements数组中的元素中的<br>dexFile中的<br>mCookie</p>
<p>随便下个断点，方便起见，我经常下的断点就是<code>OnClickListener</code>接口中的<code>onClick</code>方法，注意给<strong>接口中的方法</strong>下断点的话，所有的实现了这个<strong>接口方法</strong>类的这个方法都能被<code>debug</code>捕捉到，</p>
<p>这样不需要修改源程序，就能轻松的下断点，<br>我们只要点击任意一个可点击的<code>view</code>触发了它的<code>onClick</code>方法，调试器就能捕捉到，之后我们就能任意查看内容了。</p>
<p>调试器中插入代码，查看内容<br><img src="/images/blog/40_0.png" alt="调试器查看内容"></p>
<p>WTF!!!<br><code>mCookie</code>居然是个<code>Long[]</code>，说好的<code>int</code>呢！<br><img src="/images/blog/40_1.png" alt="查看 mCookie 这个成员变量的类型"></p>
<p>居然是Object！</p>
<p>回去看ZjDroid源码，从<code>getFieldInt</code>方法切入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int mCookie = RefInvoke.getFieldInt(&quot;dalvik.system.DexFile&quot;, dexFile, &quot;mCookie&quot;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getFieldInt(String class_name,Object obj, String filedName)&#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		Class obj_class = Class.forName(class_name);</span><br><span class="line">		Field field = obj_class.getDeclaredField(filedName);</span><br><span class="line">		field.setAccessible(true);</span><br><span class="line">		return field.getInt(obj);</span><br><span class="line">	&#125; catch (SecurityException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	return -1; //这里！！！！！！！！！！</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>似乎是调用<code>Field</code>类型的对象的<code>getInt()</code>方法发生了异常（肯定会发生异常啦，这个变量都是个数组，不可能得到<code>int</code>类型，异常也是情理之中的），<br>发生异常以后，只能输出 <code>-1</code> 了，</p>
<p>用同样的动态调试方法，对<code>Android 4.4的模拟器进行测试</code>：<br><img src="/images/blog/40_2.png" alt="调试器查看内容，Android4.4"><br><img src="/images/blog/40_3.png" alt="查看 mCookie 这个成员变量的类型"></p>
<p>看来应该是<code>art</code>虚拟机和<code>dalvik</code>虚拟机的不同造成的，在Android4.4上面这个变量是<code>int</code>类型的，</p>
<p>不过我倒是来了兴趣，想试试能不能修复这个问题，不过这就要对<code>mCookie</code>深入研究研究了。</p>
<h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>起床搜了搜资料，网上也有好多人遇到了这个问题。</p>
<p>不过关于<code>mCookie</code>的详细叙述倒是没多少</p>
<p>退回原点，看看崩溃时的异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    --------- beginning of crash</span><br><span class="line">04-28 10:31:34.468 17165-20179/com.imlk.BlackAndWhite E/AndroidRuntime: FATAL EXCEPTION: Thread-3</span><br><span class="line">    Process: com.imlk.BlackAndWhite, PID: 17165</span><br><span class="line">    java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.android.reverse-1/base.apk&quot;],nativeLibraryDirectories=[/system/lib, /vendor/lib]]] couldn&apos;t find &quot;libdvmnative.so&quot;</span><br><span class="line">        at java.lang.Runtime.loadLibrary0(Runtime.java:984)</span><br><span class="line">        at java.lang.System.loadLibrary(System.java:1562)</span><br><span class="line">        at com.android.reverse.util.NativeFunction.&lt;clinit&gt;(NativeFunction.java:19)</span><br><span class="line">        at com.android.reverse.smali.MemoryBackSmali.disassembleDexFile(MemoryBackSmali.java:76)</span><br><span class="line">        at com.android.reverse.collecter.DexFileInfoCollecter.backsmaliDexFile(DexFileInfoCollecter.java:141)</span><br><span class="line">        at com.android.reverse.request.BackSmaliCommandHandler.doAction(BackSmaliCommandHandler.java:19)</span><br><span class="line">        at com.android.reverse.mod.CommandBroadcastReceiver$1.run(CommandBroadcastReceiver.java:33)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:761)</span><br></pre></td></tr></table></figure>
<p>说找不到这个<code>libdvmnative.so</code></p>
<p>而这个文件是在ZjDroid项目里的，看看编译出的apk</p>
<p>里面是有这个东西的，真是奇了怪了，xposed框架竟然没帮我把so文件加载进去？？？？？？</p>
<p>后面发现是平台的原因，我的模拟器是x86的，apk里只有arm的源码</p>
<h3 id="暂时失败告终"><a href="#暂时失败告终" class="headerlink" title="暂时失败告终"></a>暂时失败告终</h3><p>哇，看了一下，这<code>art</code>和<code>dalvik</code>的区别还是很大的，仅仅是修复这些Java层的代码是行不通的，因为它这里好几个地方用到了so中的<code>native</code>方法，这些是不开源的东西，想修改也修改不了。Android7.1.2上的尝试只好放弃了。</p>
<p>不过这里还是学到了一些东西，也第一次尝试了multidex，但是在Android4.4上好像得自己手动加载余下的dex，还真让人头疼啊。</p>
<h3 id="船新版本"><a href="#船新版本" class="headerlink" title="船新版本"></a>船新版本</h3><p><code>github</code>真的万能啊！！</p>
<p>捞到了<code>native</code>部分的源码！</p>
<p>是从一个叫<code>HeyGirl</code>的项目里捞到的，这个项目貌似是fork的最早版本的ZjDroid，（不知道是什么原因原项目已不存在），总之从里面捞到了native的源码，可以学习一波啦</p>
<p>又找来了<code>luajava</code>的源码，凑在一起基本上就是原版的ZjDroid了。</p>
<p>我为什么要费工夫找这些源码？？？</p>
<p>因为github上面的ZjDroid中只有arm平台的so文件，而我的虚拟机是x86的，没法用，提示找不到so文件。</p>
<h3 id="继续尝试脱"><a href="#继续尝试脱" class="headerlink" title="继续尝试脱"></a>继续尝试脱</h3><p>输入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb logcat -s zjdroid-shell-com.imlk.BlackAndWhite</span><br></pre></td></tr></table></figure></p>
<p>logcat：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------- beginning of /dev/log/system</span><br><span class="line">--------- beginning of /dev/log/main</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the package = com.imlk.BlackAndWhite has hook</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the app target id = 3717</span><br></pre></td></tr></table></figure></p>
<p>输入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">am broadcast -a com.zjdroid.invoke --ei target 3717 --es cmd &apos;&#123;action:dump_dexinfo&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>logcat：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the cmd = dump_dexinfo</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): The DexFile Infomation -&gt;</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): filepath:/data/app/com.imlk.BlackAndWhite-1.apk mCookie:-1204615840</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): End DexFile Infomation</span><br></pre></td></tr></table></figure></p>
<p>输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">am broadcast -a com.zjdroid.invoke --ei target 3717 --es cmd &apos;&#123;&quot;action&quot;:&quot;backsmali&quot;,&quot;dexpath&quot;:&quot;/data/app/com.imlk.BlackAndWhite-1.apk&quot;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the cmd = backsmali</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): start disassemble the mCookie -1203426560</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): dvmnative</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): dvmnative</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the dexfile header item info start--&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the stringStartOffset =112</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the typeStartOffset =2312</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the protoStartOffset =2800</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the fieldStartOffset =4636</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the methodStartOffset =5156</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the classStartOffset =8028</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the classCount =21</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the dexfile header item info end&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;--</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): end disassemble the mCookie: cost time = 3s</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): start build the smali files to dex</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): build the dexfile ok</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): end build the smali files to dex: cost time = 0s</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3717): the dexfile data save to =/data/data/com.imlk.BlackAndWhite/files/dexfile.dex</span><br></pre></td></tr></table></figure></p>
<p>激动！！！<br>似乎是成功了，我们去看看在目标路径下有没有我们要的文件：<br>哇是真的有！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@generic_x86:/data/data/com.imlk.BlackAndWhite/files # ll</span><br><span class="line">-rw------- u0_a60   u0_a60      12920 2018-04-29 10:44 dexfile.dex</span><br></pre></td></tr></table></figure>
<p>快快<code>adb pull</code>出来瞧瞧</p>
<p>先用dex2jar处理，然后用jd-gui查看。。。</p>
<p><img src="/images/blog/40_4.png" alt="脱出来的东西"></p>
<p>我擦这不就是壳子吗？逗我吧！！！</p>
<h3 id="继续研究"><a href="#继续研究" class="headerlink" title="继续研究"></a>继续研究</h3><p>研究发现</p>
<p>加固应用在加载以后会动态加载两个dex，所以加上apk，一共有三个<code>DexFile</code></p>
<p>可以通过用as调试看出来：</p>
<p>这里的dexElements的来源是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassLoader-&gt;pathList-&gt;dexElements</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dexElements = &#123;DexPathList$Element[3]@831564034400&#125; </span><br><span class="line">	0 = &#123;DexPathList$Element@831564034360&#125; &quot;dex file &quot;dalvik.system.DexFile@9d139c78&quot;&quot;</span><br><span class="line">		dexFile = &#123;DexFile@831563996280&#125; </span><br><span class="line">			guard = &#123;CloseGuard@831559184936&#125; </span><br><span class="line">			mFileName = &quot;/data/app/com.imlk.BlackAndWhite-1.apk&quot;</span><br><span class="line">			mCookie = -1192464816</span><br><span class="line">		file = null</span><br><span class="line">		zipFile = null</span><br><span class="line">		zip = null</span><br><span class="line">		isDirectory = false</span><br><span class="line">		initialized = false</span><br><span class="line">	1 = &#123;DexPathList$Element@831564033672&#125; &quot;dex file &quot;dalvik.system.DexFile@9d13a810&quot;&quot;</span><br><span class="line">		dexFile = &#123;DexFile@831563999248&#125; </span><br><span class="line">			guard = &#123;CloseGuard@831559184936&#125; </span><br><span class="line">			mFileName = &quot;/data/app/com.imlk.BlackAndWhite-1.apk&quot;</span><br><span class="line">			mCookie = -1192527312</span><br><span class="line">		file = null</span><br><span class="line">		zipFile = null</span><br><span class="line">		zip = null</span><br><span class="line">		isDirectory = false</span><br><span class="line">		initialized = false</span><br><span class="line">	2 = &#123;DexPathList$Element@831563727296&#125; &quot;zip file &quot;/data/app/com.imlk.BlackAndWhite-1.apk&quot;&quot;</span><br><span class="line">		dexFile = &#123;DexFile@831563726992&#125; </span><br><span class="line">			guard = &#123;CloseGuard@831559184936&#125; </span><br><span class="line">			mFileName = &quot;/data/app/com.imlk.BlackAndWhite-1.apk&quot;</span><br><span class="line">			mCookie = -1193659808</span><br><span class="line">		file = &#123;File@831563726728&#125; &quot;/data/app/com.imlk.BlackAndWhite-1.apk&quot;</span><br><span class="line">		zipFile = null</span><br><span class="line">		zip = &#123;File@831563726728&#125; &quot;/data/app/com.imlk.BlackAndWhite-1.apk&quot;</span><br><span class="line">		isDirectory = false</span><br><span class="line">		initialized = false</span><br></pre></td></tr></table></figure>
<p>但是原版的<code>ZjDroid</code>默认是以文件名称<code>mFileName</code>为键<code>key</code>，在一个<code>map</code>中保存加载了的dex文件的相关信息的，这导致三个文件只被保存了一个信息，于是我魔改了一下，让<code>ZjDroid</code>将<code>mCookie</code>作为键，发送的命令也通过指定<code>mCookie</code>的值来dump我们要的文件，这样就解决了冲突问题。</p>
<p>魔改版本<br>KB5201314/ZjDroid：<br><a href="https://github.com/KB5201314/ZjDroid" target="_blank" rel="noopener">https://github.com/KB5201314/ZjDroid</a></p>
<h3 id="脱！"><a href="#脱！" class="headerlink" title="脱！"></a>脱！</h3><p>到这一步可以说是非常nice了。</p>
<p>启动时的输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3525): the package = com.imlk.BlackAndWhite has hook</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3525): the app target id = 3525</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3525): openDexFileNative() is invoked with filepath:/data/app/com.imlk.BlackAndWhite-1.apk result:-1196414688</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3525): openDexFileNative() is invoked with filepath:/data/app/com.imlk.BlackAndWhite-1.apk result:-1196412000</span><br></pre></td></tr></table></figure></p>
<p>那个<code>result</code>就是<code>mCookie</code></p>
<p>看一下<code>dexinfo</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3525): the cmd = dump_dexinfo</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3525): The DexFile Infomation -&gt;</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3525): filepath:/data/app/com.imlk.BlackAndWhite-1.apk dexElementToString:zip file &quot;/data/app/com.imlk.BlackAndWhite-1.apk&quot; mCookie:-1197778512</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3525): filepath:/data/app/com.imlk.BlackAndWhite-1.apk dexElementToString:dex file &quot;dalvik.system.DexFile@9d19c9d0&quot; mCookie:-1196412000</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3525): filepath:/data/app/com.imlk.BlackAndWhite-1.apk dexElementToString:dex file &quot;dalvik.system.DexFile@9d19d3c0&quot; mCookie:-1196414688</span><br><span class="line">D/zjdroid-shell-com.imlk.BlackAndWhite( 3525): End DexFile Infomation</span><br></pre></td></tr></table></figure></p>
<p>这就是我魔改的版本啦，可以看到<code>dexinfo</code>里还显示了当前文件是dex文件还是zip文件，也给出了<code>mCookie</code></p>
<p>下面对三个文件进行<code>dumpdex</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">am broadcast -a com.zjdroid.invoke --ei target 3525 --es cmd &apos;&#123;&quot;action&quot;:&quot;dump_dexfile&quot;,&quot;mCookie&quot;:&quot;-1197778512&quot;&#125;&apos;</span><br><span class="line">am broadcast -a com.zjdroid.invoke --ei target 3525 --es cmd &apos;&#123;&quot;action&quot;:&quot;dump_dexfile&quot;,&quot;mCookie&quot;:&quot;-1196412000&quot;&#125;&apos;</span><br><span class="line">am broadcast -a com.zjdroid.invoke --ei target 3525 --es cmd &apos;&#123;&quot;action&quot;:&quot;dump_dexfile&quot;,&quot;mCookie&quot;:&quot;-1196414688&quot;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>得到的三个文件大小为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Length Name</span><br><span class="line"> ------ ----</span><br><span class="line"> 359520 dexdump-1197778512.odex</span><br><span class="line">  39652 dexdump-1196412000.odex</span><br><span class="line">1051756 dexdump-1196414688.odex</span><br></pre></td></tr></table></figure></p>
<p>直觉告诉我最大的那个应该是我们要的了</p>
<p>用<code>backsmali.jar</code>工具：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar E:\toolBox\smali_JesusFreke\baksmali-2.2.2.jar deodex -d .\system\framework\ -o out -a 19 .\dexdump-1196414688.odex</span><br></pre></td></tr></table></figure></p>
<ul>
<li>命令是<code>deodex</code></li>
<li>另外，还要指定sdk版本，<code>-a</code>参数后面的就是sdk版本，我的模拟器sdk版本是19。</li>
<li><code>-o</code>是指定输出的文件夹</li>
<li>注意这里需要把系统里面的<code>\system\framework\</code>文件夹里面的东西手动取出来，因为<code>backsmali.jar</code>工具要用到这些东西，<code>-d</code>后面的参数就是<code>framework</code>文件夹的路径<br>比如：<br>我当前文件夹的文件树：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── dexdump-1196412000.odex</span><br><span class="line">├── dexdump-1196414688.odex</span><br><span class="line">├── dexdump-1197778512.odex</span><br><span class="line">└── system</span><br><span class="line">    └── framework</span><br><span class="line">        ├── am.jar</span><br><span class="line">        ├── am.odex</span><br><span class="line">        ...</span><br><span class="line">        ├── wm.jar</span><br><span class="line">        └── wm.odex</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ok，out文件夹下已经是输出的smali文件了，</p>
<p>用<code>smali.jar</code>转成dex文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar E:\toolBox\smali_JesusFreke\smali-2.2.2.jar assemble -a 19 .\out\</span><br></pre></td></tr></table></figure></p>
<p>用jadx开开试试</p>
<p><img src="/images/blog/40_5.png" alt="jadx查看生成的dex文件"></p>
<p>好激动啊！！！可算是幸苦没有白费</p>
<h3 id="改Application"><a href="#改Application" class="headerlink" title="改Application"></a>改Application</h3><p>把dex填回原来的apk里面去，再用<code>apktool</code>反编译，修改<code>AndroidManifest.xml</code>里面的<code>Application</code>字段</p>
<p>回编译时出现error，最后一句是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W: E:\toolBox\resource\dumped\com.imlk.BlackAndWhite\unsigned\res\layout-v26\abc_screen_toolbar.xml:5: error: No resource identifier found for attribute &apos;keyboardNavigationCluster&apos; in package &apos;android&apos;</span><br><span class="line">W:</span><br></pre></td></tr></table></figure>
<p>看看<code>apktool</code>的<code>help</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usage: apktool b[uild] [options] &lt;app_path&gt;</span><br><span class="line"> -f,--force-all          Skip changes detection and build all files.</span><br><span class="line"> -o,--output &lt;dir&gt;       The name of apk that gets written. Default is dist/name.apk</span><br><span class="line"> -p,--frame-path &lt;dir&gt;   Uses framework files located in &lt;dir&gt;.</span><br></pre></td></tr></table></figure></p>
<p>尝试着用<code>-p</code>指定<code>framework</code>文件夹：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar E:\toolBox\apktool\apktool_2.3.1.jar b -p system\framework unsigned</span><br></pre></td></tr></table></figure></p>
<p>居然成功了！<br>签名</p>
<h3 id="去除StubApp"><a href="#去除StubApp" class="headerlink" title="去除StubApp"></a>去除<code>StubApp</code></h3><p>又崩了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">04-30 02:30:34.604 3999-3999/com.imlk.BlackAndWhite E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.imlk.BlackAndWhite, PID: 3999</span><br><span class="line">    java.lang.NoClassDefFoundError: com.stub.StubApp</span><br><span class="line">        at com.imlk.BlackAndWhite.MainActivity.&lt;clinit&gt;(Unknown Source)</span><br><span class="line">        at java.lang.Class.newInstanceImpl(Native Method)</span><br><span class="line">        at java.lang.Class.newInstance(Class.java:1208)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>看来有些东西没清理干净</p>
<p>大数字往里面加了静态代码块啊</p>
<p>在jadx里全局搜索<code>StubApp</code>，去文件里注释掉</p>
<h3 id="native的onCreate方法"><a href="#native的onCreate方法" class="headerlink" title="native的onCreate方法"></a>native的onCreate方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">04-30 02:35:41.484 4151-4151/com.imlk.BlackAndWhite E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.imlk.BlackAndWhite, PID: 4151</span><br><span class="line">    java.lang.UnsatisfiedLinkError: Native method not found: com.imlk.BlackAndWhite.MainActivity.onCreate:(Landroid/os/Bundle;)V</span><br><span class="line">        at com.imlk.BlackAndWhite.MainActivity.onCreate(Native Method)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:5231)</span><br><span class="line">        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1087)</span><br></pre></td></tr></table></figure>
<p>哇，没想到这个<code>onCreate</code>方法居然是<code>native</code>的！！！<br>皮万斤！</p>
<p>看到应用里两个<code>Activity</code>里面上一步的静态代码块有一点区别<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    StubApp.interface11(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    StubApp.interface11(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>猜测是根据参数值来识别是哪个<code>Activity</code>的</p>
<p>看看我们dump出来的其它dex</p>
<p>哇，简直崩溃。。。做不来做不来</p>
<h3 id="告一段落"><a href="#告一段落" class="headerlink" title="告一段落"></a>告一段落</h3><p>所以说完全复原我是搞不来了，不过仅仅是看看源码还是能的</p>
<p>能力有限啊，搞不了，还是先继续学习吧。。。。</p>
<p>2018_04_30</p>
<h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>编译后安装在<code>Android4.4</code>上时偶遇这个问题，<br>安装上以后，XposedInstaller直接就崩溃了，看日志也一头雾水，上网搜才知道是模块的<code>versionCode</code>和<code>versionName</code>没有设置，在<code>gradle.build</code>里加上就好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">04-29 09:29:04.538 5603-5619/de.robv.android.xposed.installer E/AndroidRuntime: FATAL EXCEPTION: RepositoryReload</span><br><span class="line">    Process: de.robv.android.xposed.installer, PID: 5603</span><br><span class="line">    android.database.sqlite.SQLiteConstraintException: installed_modules.version_name may not be NULL (code 19)</span><br><span class="line">        at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(Native Method)</span><br><span class="line">        at android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:782)</span><br><span class="line">        at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:788)</span><br><span class="line">        at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)</span><br><span class="line">        at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1469)</span><br><span class="line">        at android.database.sqlite.SQLiteDatabase.insertOrThrow(SQLiteDatabase.java:1365)</span><br><span class="line">        at de.robv.android.xposed.installer.repo.RepoDb.insertInstalledModule(RepoDb.java:374)</span><br><span class="line">        at de.robv.android.xposed.installer.util.ModuleUtil.getInstance(ModuleUtil.java:52)</span><br><span class="line">        at de.robv.android.xposed.installer.XposedApp.updateProgressIndicator(XposedApp.java:114)</span><br><span class="line">        at de.robv.android.xposed.installer.util.RepoLoader$2.run(RepoLoader.java:210)</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>- Android中Xposed框架篇—基于Xposed的一款脱壳神器ZjDroid工具原理解析：<br><a href="https://blog.csdn.net/jiangwei0910410003/article/details/52840602" target="_blank" rel="noopener">https://blog.csdn.net/jiangwei0910410003/article/details/52840602</a><br>- [原创]安卓逆向之基于Xposed-ZjDroid脱壳：<br><a href="https://bbs.pediy.com/thread-218798.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-218798.htm</a><br>- ZjDroid项目源码（已经停更4年）：<br><a href="https://github.com/halfkiss/ZjDroid" target="_blank" rel="noopener">https://github.com/halfkiss/ZjDroid</a><br>- HeyGirl项目地址<br><a href="https://github.com/mikusjelly/HeyGirl" target="_blank" rel="noopener">https://github.com/mikusjelly/HeyGirl</a><br>- android am命令用法：<br><a href="https://blog.csdn.net/u010164190/article/details/72875865" target="_blank" rel="noopener">https://blog.csdn.net/u010164190/article/details/72875865</a><br>- [原创]360加固逆向脱壳之过反调试：<br><a href="https://bbs.pediy.com/thread-213214.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-213214.htm</a><br>- [原创]360加固逆向脱壳之过反调试–后续：<br><a href="https://bbs.pediy.com/thread-213377.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-213377.htm</a><br>- 360加固保动态脱壳：<br><a href="https://www.cnblogs.com/2014asm/p/4104456.html" target="_blank" rel="noopener">https://www.cnblogs.com/2014asm/p/4104456.html</a><br>- JesusFreke smali:<br><a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="noopener">https://bitbucket.org/JesusFreke/smali/downloads/</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]Android实现Multidex及指定主dex中的class</title>
    <url>/blog/41/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>在编译ZjDroid源码的时候遇到了著名的方法数超出<code>65536</code>个的问题。</p>
<p>我的<code>gradle</code>版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classpath &apos;com.android.tools.build:gradle:3.1.2&apos;</span><br></pre></td></tr></table></figure>
<h3 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h3><ol>
<li><code>Xposed</code>模块中的方法数超过了<code>65536</code>个，需要进行分包操作</li>
<li>分包以后如何在模块被加载执行前尽可能早的把其余的dex加载进来</li>
<li>最后遇到的问题：把模块的入口类指定到第一个dex中</li>
</ol>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>关于分包操作：</p>
<p>搜了半天，搜到的解决办法是：<br><code>gradle.build</code>中在<code>defaultConfig</code>中添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multiDexEnabled true</span><br></pre></td></tr></table></figure></p>
<p>让编译脚本开启分包</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>关于分包后的加载问题：</p>
<p>网上对于一般应用的解决办法是</p>
<p>引入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &apos;com.android.support:multidex:1.0.3&apos;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Application</code>中调用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MultiDex.install(this);</span><br></pre></td></tr></table></figure></p>
<p>来实现分包应用的启动。</p>
<p><strong>但是有一个问题是这个<code>Multidex</code>的<code>install</code>方法需要传入一个<code>Context</code>实例，而<code>Xposed</code>模块的启动是没有<code>Application</code>的，怎么办呢，如果要截获宿主的<code>Application</code>又比较麻烦，能不能直接一句话完成呢？</strong></p>
<p>于是我决定去研究研究<code>MultiDex</code>的源码，尝试魔改出一个适用于<code>Xposed</code>模块的<code>MultiDex.install()</code>。</p>
<h3 id="魔改之旅"><a href="#魔改之旅" class="headerlink" title="魔改之旅"></a>魔改之旅</h3><p>研究了一番发现，传入的<code>Context</code>的主要用途有：</p>
<ol>
<li>传入<code>getApplicationInfo</code>方法获取<code>ApplicationInfo</code></li>
<li>获取应用的私有储存空间路径并往里面解压<code>dex</code>文件</li>
<li>获取<code>SharedPreferences</code>储存一些和<code>dex</code>文件数量以及文件校验相关的信息（考虑的还挺周到）</li>
</ol>
<p>我发现在模块的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable &#123;</span><br></pre></td></tr></table></figure>
<p>这个入口函数的参数<code>lpparam</code>中，能获取到宿主的<code>ApplicationInfo</code>，从而获取到宿主应用的私有文件夹路径</p>
<p>这样我就能往里面解压文件啦</p>
<p>至于文件校验，这个就不做了，（原方案是一次启动的时候解压，然后以后启动的时候就去校验这个文件，再加载进来），我就干脆每次启动的时候都要解压，加载完再删掉就ok了。</p>
<h3 id="魔改完成"><a href="#魔改完成" class="headerlink" title="魔改完成"></a>魔改完成</h3><p>项目地址：<br><a href="https://github.com/KB5201314/XposedModuleMultidex" target="_blank" rel="noopener">https://github.com/KB5201314/XposedModuleMultidex</a></p>
<p>添加依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;top.imlk.xpmodulemultidex:XposedModuleMultidex:1.0.0&apos;</span><br></pre></td></tr></table></figure></p>
<p>删了一大堆，总算是魔改出来了一个，虽然只有两个文件。。。。但还是值得庆幸的！</p>
<p>获取<code>module</code>的安装包路径：</p>
<p>通过给入口类继承<code>IXposedHookZygoteInit</code>并实现<code>initZygote</code>方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void initZygote(StartupParam startupParam) throws Throwable &#123;</span><br><span class="line">    MODULE_PATH = startupParam.modulePath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就能拿到模块的安装包路径啦。</p>
<p>然后在<code>handleLoadPackage</code>中执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    @Override</span><br><span class="line">    public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable &#123;</span><br><span class="line">        XMMultiDex.install(ReverseXposedModule.class.getClassLoader(),MODULE_PATH,lpparam.appInfo);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>其中<code>ReverseXposedModule</code>就是我这个模块的入口类的名称啦。</p>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p><strong>指定主<code>dex</code>中的<code>class</code>文件的问题</strong></p>
<p>这可废了我不少时间啊，网上的方法大多都过时了，唯一一个看着靠谱的插件<code>DexKnifePlugin</code>也用不了，搜了半天，终于找到一位仁兄的方法</p>
<p>在<code>gradle.build</code>的<code>defaultConfig</code>中可以指定一个文件来表示要放在第一个<code>dex</code>中的<code>class</code></p>
<p>加入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multiDexKeepFile file(&apos;maindexlist.txt&apos;)</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>gradle.build</code>的同级目录下新建一个文件<code>maindexlist.txt</code></p>
<p>里面填上要放在第一个<code>dex</code>中的<code>class</code></p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com/android/reverse/mod/ReverseXposedModule.class</span><br><span class="line">top/imlk/xpmodulemultidexer/XMMultiDex.class</span><br></pre></td></tr></table></figure></p>
<p>也可以用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multiDexKeepProguard file(&apos;maindexlist.pro&apos;)</span><br></pre></td></tr></table></figure></p>
<p>然后<br>新建<code>maindexlist.pro</code>文件，这样就可以用<code>proguard</code>语法来写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keep class com.android.reverse.mod.ReverseXposedModule</span><br><span class="line">-keep class top.imlk.xpmodulemultidexer.*</span><br></pre></td></tr></table></figure>
<p>可算是ok了</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>gradle3.0.0分包把指定的class放到maindex里面:<br><a href="https://blog.csdn.net/qq_17265737/article/details/79074494" target="_blank" rel="noopener">https://blog.csdn.net/qq_17265737/article/details/79074494</a><br>理解 Multidex 生成：<br><a href="http://www.jkeabc.com/566905.html" target="_blank" rel="noopener">http://www.jkeabc.com/566905.html</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]Xposed框架加持下的Android应用ClassLoader的结构关系</title>
    <url>/blog/43/</url>
    <content><![CDATA[<p>好久没写东西了，期末终于考完了，想起之前对Xposed开发的一些问题还没有解决，于是搬出来探索了一番。</p>
<h3 id="Android应用ClassLoader再思考"><a href="#Android应用ClassLoader再思考" class="headerlink" title="Android应用ClassLoader再思考"></a>Android应用ClassLoader再思考</h3><p>我们知道，Android应用以<code>apk</code>文件的形式存在于手机储存空间之中，而要运行这些应用，则需要用ClassLoader加载到虚拟机中去。<br>除了应用的apk文件之外，还有一些Android框架层的类在<code>/system/framework/</code>文件夹下以<code>jar</code>包的形式存在着</p>
<p><img src="/images/blog/43_0.png" alt="/system/framework/中的类文件"></p>
<p>对Android中各种类型的ClassLoader的使用的解释，网上已经已经很多了，这里就不再添乱。</p>
<h3 id="未安装Xposed框架时的Android应用中的ClassLoader"><a href="#未安装Xposed框架时的Android应用中的ClassLoader" class="headerlink" title="未安装Xposed框架时的Android应用中的ClassLoader"></a>未安装Xposed框架时的Android应用中的ClassLoader</h3><p>通过调试找出了ClassLoader之间的关系（Sony z5，Android7 arm64）</p>
<p><img src="/images/blog/43_1.png" alt="未安装Xposed框架时的Android应用中的ClassLoader关系图"></p>
<p>可以看到有两个<code>PathClassLoader</code>，它们的<code>parent</code>都是<code>BootClassLoader</code>。</p>
<p>左边那个<code>PathClassLoader</code>加载的就是我们的App，右边那个是<code>ClassLoader.getSystemClassLoader()</code>方法获取到的</p>
<h4 id="ClassLoader-getSystemClassLoader"><a href="#ClassLoader-getSystemClassLoader" class="headerlink" title="ClassLoader.getSystemClassLoader()"></a>ClassLoader.getSystemClassLoader()</h4><p>翻看源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public static ClassLoader getSystemClassLoader() &#123;</span><br><span class="line">    return SystemClassLoader.loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现是一个静态方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    static private class SystemClassLoader &#123;</span><br><span class="line">        public static ClassLoader loader = ClassLoader.createSystemClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这个<code>SystemClassLoader</code>类是<code>ClassLoader</code>的一个静态内部类，并且静态初始化了一个<code>loader</code>成员变量<br>跟入<code>ClassLoader.createSystemClassLoader()</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static ClassLoader createSystemClassLoader() &#123;</span><br><span class="line">    String classPath = System.getProperty(&quot;java.class.path&quot;, &quot;.&quot;);</span><br><span class="line">    String librarySearchPath = System.getProperty(&quot;java.library.path&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    // String[] paths = classPath.split(&quot;:&quot;);</span><br><span class="line">    // URL[] urls = new URL[paths.length];</span><br><span class="line">    // for (int i = 0; i &lt; paths.length; i++) &#123;</span><br><span class="line">    // try &#123;</span><br><span class="line">    // urls[i] = new URL(&quot;file://&quot; + paths[i]);</span><br><span class="line">    // &#125;</span><br><span class="line">    // catch (Exception ex) &#123;</span><br><span class="line">    // ex.printStackTrace();</span><br><span class="line">    // &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    //</span><br><span class="line">    // return new java.net.URLClassLoader(urls, null);</span><br><span class="line"></span><br><span class="line">    // TODO Make this a java.net.URLClassLoader once we have those?</span><br><span class="line">    return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原来这个<code>getSystemClassLoader()</code>返回的<code>ClassLoader</code>就是以系统的属性构建的一个<code>CLassLoader</code>啊</p>
<p>在<code>System.initUnchangeableSystemProperties()</code>中找到了这个属性的初始化过程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static Properties initUnchangeableSystemProperties() &#123;</span><br><span class="line">    VMRuntime runtime = VMRuntime.getRuntime();</span><br><span class="line">    Properties p = new Properties();</span><br><span class="line"></span><br><span class="line">    // Set non-static properties.</span><br><span class="line">    p.put(&quot;java.boot.class.path&quot;, runtime.bootClassPath());</span><br><span class="line">    p.put(&quot;java.class.path&quot;, runtime.classPath());</span><br><span class="line"></span><br><span class="line">    // TODO: does this make any sense? Should we just leave java.home unset?</span><br><span class="line">    String javaHome = getenv(&quot;JAVA_HOME&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>我们这里不去深究这个属性值的产生过程了，我们直接调用去获取属性，发现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.getProperty(&quot;java.class.path&quot;)=&quot;.&quot;</span><br><span class="line">System.getProperty(&quot;java.library.path&quot;)=&quot;/system/lib64:/vendor/lib64&quot;</span><br></pre></td></tr></table></figure></p>
<p>看起来并没有相关的线索，上网搜也没有找到什么有价值的东西，下断点发现在应用程序启动的过程中会被被调用一次。</p>
<h4 id="BootClassLoader"><a href="#BootClassLoader" class="headerlink" title="BootClassLoader"></a>BootClassLoader</h4><p>这个类加载器很特殊了，<br><code>Integer.class.getClassLoader()</code>返回的就是这个<code>BootClassLoader</code>，可见这是基础的<code>ClassLoader</code>，<br>另外，调用<code>android.widget.TextView.class.getClassLoader()</code>得到的也是这个<code>BootClassLoader</code></p>
<p>在<code>/init.rc</code>或<code>/init.environ.rc</code>中一条<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export BOOTCLASSPATH /system/framework/org.dirtyunicorns.utils.jar</span><br><span class="line">					:/system/framework/telephony-ext.jar</span><br><span class="line">					:/system/framework/tcmiface.jar</span><br><span class="line">					:/system/framework/core-oj.jar</span><br><span class="line">					:/system/framework/core-libart.jar</span><br><span class="line">					:/system/framework/conscrypt.jar</span><br><span class="line">					:/system/framework/okhttp.jar</span><br><span class="line">					:/system/framework/core-junit.jar</span><br><span class="line">					:/system/framework/bouncycastle.jar</span><br><span class="line">					:/system/framework/ext.jar</span><br><span class="line">					:/system/framework/framework.jar</span><br><span class="line">					:/system/framework/telephony-common.jar</span><br><span class="line">					:/system/framework/voip-common.jar</span><br><span class="line">					:/system/framework/ims-common.jar</span><br><span class="line">					:/system/framework/apache-xml.jar</span><br><span class="line">					:/system/framework/org.apache.http.legacy.boot.jar</span><br></pre></td></tr></table></figure></p>
<p>从字面意思上看，应该是指定了<code>BootClassLoader</code>加载的一些系统框架类的路径，其中<code>android.widget.TextView</code>这些就是在<code>/system/framework/framework.jar</code>里的。</p>
<h3 id="Xposed框架加持以后"><a href="#Xposed框架加持以后" class="headerlink" title="Xposed框架加持以后"></a>Xposed框架加持以后</h3><p>写过xposed模块的都知道，hook逻辑是是写在宿主app之外的独立的一个app里面的，宿主app启动的时候，这个模块app就会被启动，而在<code>XposedInstaller</code>里能控制模块app的启用或禁用。</p>
<p>既然要加载别的apk，那就意味着一定和ClassLoader有关系啦，<br>这里依然使用调试的方法，（rom：AEX Android7.1.2 arm）</p>
<p><img src="/images/blog/43_2.png" alt="安装Xposed框架后的Android应用中的ClassLoader关系图"></p>
<p>可以看到刷入了Xposed框架以后发生的变化：（这里使用的是Xposed89版）</p>
<p>- <code>BootClassLoader</code>的下面多了一层<code>PathClassLoader</code><br>- 宿主app的<code>ClassLoader</code>和<code>ClassLoader.getSystemClassLoader()</code>的那个一同挂在中间层下面<br>- 各个模块各有独立的<code>PathClassLoader</code>加载，挂在那个<code>ClassLoader.getSystemClassLoader()</code>下面<br>- <code>ClassLoader.getSystemClassLoader()</code>的加载路径里似乎多了个<code>/system/framework/XposedBridge.jar</code></p>
<h4 id="中间层"><a href="#中间层" class="headerlink" title="中间层"></a>中间层</h4><p>把中间层里的那个dex文件pull出来解开，发现里面只有一个类<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package xposed.dummy;</span><br><span class="line"></span><br><span class="line">import android.content.res.Resources;</span><br><span class="line"></span><br><span class="line">public class XResourcesSuperClass extends Resources &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类的作用或许要拜读Xposed的源码才能知道了，看起来和资源加载有一点关系</p>
<h4 id="各模块的ClassLoader"><a href="#各模块的ClassLoader" class="headerlink" title="各模块的ClassLoader"></a>各模块的ClassLoader</h4><p>将各个模块的加载用不同的<code>ClassLoader</code>进行，避免了模块之间类的冲突，<br>这也意味着<strong>模块不能直接用类似于<code>Class.forName()</code>的方式获取宿主app内的类以及成员<code>Member</code></strong>，<br>这是新手（也包括当时的我）容易犯的错误，所以Xposed提供了<code>XposedHelper</code>来提供相关操作，而且为了提高效率，内部会缓存获取到的<code>Member</code>对象。</p>
<h4 id="ClassLoader-getSystemClassLoader-发生的变化"><a href="#ClassLoader-getSystemClassLoader-发生的变化" class="headerlink" title="ClassLoader.getSystemClassLoader()发生的变化"></a>ClassLoader.getSystemClassLoader()发生的变化</h4><p>注意到<code>ClassLoader.getSystemClassLoader()</code>获取到的<code>ClassLoader</code>（我们姑且称之为<code>SystemClassLoader</code>吧）的路径里面多了个<code>/system/framework/XposedBridge.jar</code></p>
<p>另外，执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.getProperty(&quot;java.class.path&quot;)</span><br></pre></td></tr></table></figure></p>
<p>将返回<code>/system/framework/XposedBridge.jar</code>，同样的，拖出来解开看看</p>
<p><img src="/images/blog/43_3.png" alt="/system/framework/XposedBridge.jar"><br>可以看到这里有Xposed开发时我们熟悉的类，也有很多我们不熟悉的类，看起来这个jar里就是Xposed在Java层的一些实现相关的东西了(。・∀・)ノ</p>
<p>让我们看看<code>de.robv.android.xposed.XposedBridge</code>这个我们开发时经常打交道的类是哪里加载来的<br>在调试时输出<code>de.robv.android.xposed.XposedBridge.class.getClassLoader()</code>的值<br>和<code>ClassLoader.getSystemClassLoader()</code>得到的对象进行比较，发现它们是同一个对象，就是那个<code>SystemClassLoader</code>（嘿，醒醒，只是我在这里把它这么叫而已，实际上它也是个<code>PathClassLoader</code>）</p>
<h4 id="小错误"><a href="#小错误" class="headerlink" title="小错误"></a>小错误</h4><p>我写这篇文章之前在在这里犯了一个错误，<br>因为对Android Studio调试时的动态执行语句的环境不是很明确，</p>
<p>在调试时执行<code>de.robv.android.xposed.XposedBridge.class.getClassLoader()</code>不会爆<code>Method threw &#39;java.lang.ClassNotFoundException&#39; exception.</code><br>然后我就以为这个<code>de.robv.android.xposed.XposedBridge</code>类应该是从app这个<code>PathClassLoader</code>向上找到的（根据双亲委托模型），但是app的<code>PathClassLoader</code>和<code>SystemClassLoader</code>没有父子关系，它们属于同一级，然后我就以为存在两个被加载的<code>XposedBridge.jar</code>。</p>
<p>后来发现是Android Studio太聪明了，“帮我找到”了正确的ClassLoader<br>如果调试时改用<code>loadClass</code>的方法或<code>Class.forName</code>都会爆异常</p>
<p><code>Method threw &#39;java.lang.ClassNotFoundException&#39; exception.</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getApplicationContext().getClassLoader().loadClass(&quot;de.robv.android.xposed.XposedBridge&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;de.robv.android.xposed.XposedBridge&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="玩坏Xposed"><a href="#玩坏Xposed" class="headerlink" title="玩坏Xposed"></a>玩坏Xposed</h4><p>根据Xposed加持后的<code>ClassLoader</code>关系图可以看出，<code>XposedBridge.jar</code>被添加到了<code>SystemClassLoader</code>里面加载，那么普通应用可以获取这个<code>SystemClassLoader</code>，进而调用一些方法对自己做一些hook的操作了，能力和Xposed模块已经相当了，只是只能对自己hook而且没法像Xposed模块那样在应用启动之前就进行hook，<br>就我认识的有一位(nv)大(zhuang)佬突发奇想用把aide里Java显示运行输出结果的那个控制台界面hook换成了<code>WebView</code>来播放在线视频。</p>
<p>所以说Xposed还是很好玩的，不仅要会用，还要学会它的原理，希望有一天我也能写出有价值的东西。</p>
]]></content>
      <categories>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>笔记</tag>
        <tag>Xposed</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]ZjDroid适配art虚拟机的尝试</title>
    <url>/blog/42/</url>
    <content><![CDATA[<p>上星期趁着放假玩了玩ZjDroid，自己编译了一个来玩，最终克服万难总算找齐了源码，给编译出来了。<br>上一篇文章:</p>
<p>笔记-第一次ZjDroid脱壳实战<br><a href="https://blog.csdn.net/u010746456/article/details/80150250" target="_blank" rel="noopener">https://blog.csdn.net/u010746456/article/details/80150250</a></p>
<p>虽然，最终拿出来的大数字加固的dex没能恢复onCreate这个native方法（本人实在太菜），但是其他部分还是能看源码的。</p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最近一个朋友给我看了一个爱加密的包，我放到模拟器里面用我的ZjDroid脱，没想到这个包却主动退出了！<br>我以为是检测到了ZjDroid，就卸载了ZjDroid，结果还是崩，后来上网查才发现，爱加密检测到是模拟器环境就会主动退出。</p>
<p>这可让我费脑筋啊！</p>
<p>我手上只有Android7.1.2的设备，而目前的ZjDroid只支持dalvik虚拟机上跑，这可咋办呢，要我刷机？懒得备份。。。</p>
<p>我记得ZjDroid的源码最后是4年前更新的，然后作者就不维护了，于是我想能不能学习ZjDroid的原理去适配art呢？</p>
<p>打开as就开始捣鼓了！</p>
<h3 id="稍微尝试"><a href="#稍微尝试" class="headerlink" title="稍微尝试"></a>稍微尝试</h3><p>尝试在Android7.1.2上面安装ZjDroid，重启，打开上次我拆的应用（就是那个我自己的应用啦）。</p>
<p>看log，除了几个碍眼的异常以外，没什么大状况出现，</p>
<p>嗯，</p>
<p>发送广播执行<code>dump_dexinfo</code>命令，然后一下子就崩了。</p>
<p>这个问题，我在上一篇文章里面就提到过了。<br>ZjDroid在执行<code>dump_dexinfo</code>命令的时候并没有用到native层的函数，只是通过反射获取<code>dalvik.system.DexFile</code>中的<code>mCookie</code>变量打印出来，但是发生了类型强制转换的错误，错误地把<code>long[]</code>类型转换为了<code>int</code>类型。</p>
<p>解决的办法是：<br>查阅<code>Android</code>源码，对这个<code>openDexFileNative</code>分sdk版本适配</p>
<ul>
<li><p>dalvik（Android4.4及以前 sdk &lt;= 19）中的openDexFileNative<br><a href="http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java#301" target="_blank" rel="noopener">http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java#301</a></p>
</li>
<li><p>art （Android5.1.1及以前 19 &lt; sdk &lt;= 22）中的openDexFileNative<br><a href="http://androidxref.com/5.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java#308" target="_blank" rel="noopener">http://androidxref.com/5.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java#308</a></p>
</li>
<li><p>art （Android6.0至今(已测试7.1.2) 22 &lt; sdk）中的openDexFileNative<br><a href="http://androidxref.com/7.1.2_r36/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java#396" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java#396</a></p>
</li>
</ul>
<h3 id="art虚拟机的mCookie"><a href="#art虚拟机的mCookie" class="headerlink" title="art虚拟机的mCookie"></a>art虚拟机的mCookie</h3><p>但是还有一个问题就是，<br>我们要的<code>mCookie</code>究竟是什么样子的呢?</p>
<p>通过对ZjDroid的旧版本代码进行分析发现，在dalvik虚拟机中，<code>mCookie</code>实际上就是一个结构体的内存地址，通过这个结构体可以获得内存中dex文件的地址，然后就能dump出来了。<br>既然如此，在art里面的<code>mCookie</code>时一个<code>long[]</code>类型的，我们就很有必要去了解这个东西是怎么形成的了。</p>
<p>查看Android7.1.2的源码，找到<code>openDexFileNative</code>方法的native层实现：<br><a href="http://androidxref.com/7.1.2_r36/xref/art/runtime/native/dalvik_system_DexFile.cc#156" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/art/runtime/native/dalvik_system_DexFile.cc#156</a></p>
<p>有一些情况下是返回空指针的，我们就只看返回正常值的情况，在第184-194行，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">184  if (!dex_files.empty()) &#123;</span><br><span class="line">185    jlongArray array = ConvertDexFilesToJavaArray(env, oat_file, dex_files);</span><br><span class="line">186    if (array == nullptr) &#123;</span><br><span class="line">187      ScopedObjectAccess soa(env);</span><br><span class="line">188      for (auto&amp; dex_file : dex_files) &#123;</span><br><span class="line">189        if (linker-&gt;FindDexCache(soa.Self(), *dex_file, true) != nullptr) &#123;</span><br><span class="line">190          dex_file.release();</span><br><span class="line">191        &#125;</span><br><span class="line">192      &#125;</span><br><span class="line">193    &#125;</span><br><span class="line">194    return array;</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p>
<p>这个<code>ConvertDexFilesToJavaArray</code>函数应该是很重要的一个函数<br>看看它的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">77static jlongArray ConvertDexFilesToJavaArray(JNIEnv* env,</span><br><span class="line">78                                             const OatFile* oat_file,</span><br><span class="line">79                                             std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt;&amp; vec) &#123;</span><br><span class="line">80  // Add one for the oat file.</span><br><span class="line">81  jlongArray long_array = env-&gt;NewLongArray(static_cast&lt;jsize&gt;(kDexFileIndexStart + vec.size())); //初始化一个long类型的Java数组</span><br><span class="line">82  if (env-&gt;ExceptionCheck() == JNI_TRUE) &#123;//检查是否出现异常</span><br><span class="line">83    return nullptr;</span><br><span class="line">84  &#125;</span><br><span class="line">85</span><br><span class="line">86  jboolean is_long_data_copied;</span><br><span class="line">87  jlong* long_data = env-&gt;GetLongArrayElements(long_array, &amp;is_long_data_copied);//这里应该是获取刚刚生成的Java的long类型数组中元素的原始的指针，熟悉c语言的就知道，c中的数组是一块连续的内存结构，通过指针可以读取数组中的任意一个位置的元素</span><br><span class="line">88  if (env-&gt;ExceptionCheck() == JNI_TRUE) &#123;//检查是否出现异常</span><br><span class="line">89    return nullptr;</span><br><span class="line">90  &#125;</span><br><span class="line">91	// 这里的kOatFileIndex定义在了dalvik_system_DexFile.h文件中：值是0；</span><br><span class="line">	// http://androidxref.com/7.1.2_r36/xref/art/runtime/native/dalvik_system_DexFile.h#25</span><br><span class="line">92  long_data[kOatFileIndex] = reinterpret_cast&lt;uintptr_t&gt;(oat_file);//这里是c++的一种类型转换的方式，把参数转化为了uintptr_t类型，而uintptr_t类型是一种指针类型，就把它看作一个指针吧。</span><br><span class="line">93  for (size_t i = 0; i &lt; vec.size(); ++i) &#123;//可以看到，之前在数组中第一个位置放了oat_file的地址，然后接下来从kDexFileIndexStart（这个值是1，也在上面那个文件里定义了）开始，把vec数组里面的东西填之前生成的数组里。</span><br><span class="line">94    long_data[kDexFileIndexStart + i] = reinterpret_cast&lt;uintptr_t&gt;(vec[i].get());</span><br><span class="line">95  &#125;</span><br><span class="line">96</span><br><span class="line">97  env-&gt;ReleaseLongArrayElements(long_array, long_data, 0);//刷新数组信息（比如长度等）</span><br><span class="line">98  if (env-&gt;ExceptionCheck() == JNI_TRUE) &#123;//检查是否出现异常</span><br><span class="line">99    return nullptr;</span><br><span class="line">100  &#125;</span><br><span class="line">101</span><br><span class="line">102  // Now release all the unique_ptrs.</span><br><span class="line">103  for (auto&amp; dex_file : vec) &#123;</span><br><span class="line">104    dex_file.release();</span><br><span class="line">105  &#125;</span><br><span class="line">106</span><br><span class="line">107  return long_array;</span><br><span class="line">108&#125;</span><br></pre></td></tr></table></figure>
<p>可以大概了解到，第一个位置被赋值为<code>oat_file</code>这个指针（实际上就是把指向的地址存到了第一个位置里），然后依次填充<code>vec</code>这个数组里的东西到之前的<code>long</code>数组里面，看看这个<code>vec</code>：<br>在参数列表里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::unique_ptr&lt;const DexFile&gt;&gt;&amp; vec</span><br></pre></td></tr></table></figure>
<p>不要慌，看起来很复杂，但其实不难理解：</p>
<p><code>vec</code>是一个引用，引用的是一个<code>vector</code>（可变长数组）对象，这个对象里装的都是<code>unique_ptr</code>类型，这也是一种指针，可以看到这个东西指向的类型是<code>DexFile</code>，上面的那段代码应该就是把这些指针指向的<strong>地址</strong>信息填到<code>long</code>数组里面了</p>
<p>最终返回的<code>long</code>类型数组里面，应该全都是地址。</p>
<h3 id="art中的DexFile"><a href="#art中的DexFile" class="headerlink" title="art中的DexFile"></a>art中的DexFile</h3><p>再看看<code>DexFile</code>这个东西：</p>
<p>在</p>
<p><a href="http://androidxref.com/7.1.2_r36/xref/art/runtime/dex_file.h" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/art/runtime/dex_file.h</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DexFile &#123;</span><br></pre></td></tr></table></figure>
<p>是一个class，里面还有结构体比如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Header &#123;</span><br></pre></td></tr></table></figure></p>
<p>之类的，这好像和dex文件的结构有点关联了。</p>
<p>继续往下翻</p>
<p>在第1235行的地方：<a href="http://androidxref.com/7.1.2_r36/xref/art/runtime/dex_file.h#1235" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/art/runtime/dex_file.h#1235</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">1234  // The base address of the memory mapping.</span><br><span class="line">1235  const uint8_t* const begin_;</span><br><span class="line">1236</span><br><span class="line">1237  // The size of the underlying memory allocation in bytes.</span><br><span class="line">1238  const size_t size_;</span><br><span class="line">1239</span><br><span class="line">1240  // Typically the dex file name when available, alternatively some identifying string.</span><br><span class="line">1241  //</span><br><span class="line">1242  // The ClassLinker will use this to match DexFiles the boot class</span><br><span class="line">1243  // path to DexCache::GetLocation when loading from an image.</span><br><span class="line">1244  const std::string location_;</span><br><span class="line">1245</span><br><span class="line">1246  const uint32_t location_checksum_;</span><br><span class="line">1247</span><br><span class="line">1248  // Manages the underlying memory allocation.</span><br><span class="line">1249  std::unique_ptr&lt;MemMap&gt; mem_map_;</span><br><span class="line">1250</span><br><span class="line">1251  // Points to the header section.</span><br><span class="line">1252  const Header* const header_;</span><br><span class="line">1253</span><br><span class="line">1254  // Points to the base of the string identifier list.</span><br><span class="line">1255  const StringId* const string_ids_;</span><br><span class="line">1256</span><br><span class="line">1257  // Points to the base of the type identifier list.</span><br><span class="line">1258  const TypeId* const type_ids_;</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>这个<code>begin_</code>的描述，似乎是什么什么内存映射的基地址，下面还有这个块区域的大小<code>size_</code>，接下来是一些指针，<code>Header</code>，<code>StringId</code>，<code>TypeId</code>啥的，结合相关代码，我猜测这就是我们要找的dex文件的信息了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下：</p>
<p>Java层获取到的<code>mCookie</code>是一个<code>long</code>类型数组，里面都是地址，其中第一个地址是<code>oat_file</code>也就是oat过的文件的地址，当然现在大多数加固都不会允许虚拟机进行oat操作了，因为oat操作会在储存中生成优化过的oat文件，对于加固来说，无疑是自己把代码给出去了。这也是我们上一篇文章里，<code>long</code>数组第一个元素为0的原因：<br><img src="/images/blog/40_0.png" alt="调试器查看内容"></p>
<p>解决方法：<br><a href="https://github.com/KB5201314/ZjDroid/blob/master/app/src/main/java/com/android/reverse/collecter/DexFileInfoCollecter.java#L190" target="_blank" rel="noopener">https://github.com/KB5201314/ZjDroid/blob/master/app/src/main/java/com/android/reverse/collecter/DexFileInfoCollecter.java#L190</a></p>
<p>接下来</p>
<p>我们只需要第二个位置开始的内容，每一个元素都是一个地址，把地址传到<code>native</code>方法里，在<code>native</code>层里，这个地址指向的就是一个<code>DexFile</code>类，而因为类也类似于结构体，也有它的储存结构，只要找到<code>begin_</code>和<code>size_</code>的内容就能dump出内存中的dex（odex）文件。</p>
<h3 id="遇到的几个问题"><a href="#遇到的几个问题" class="headerlink" title="遇到的几个问题"></a>遇到的几个问题</h3><p>关于内存对不到的问题：</p>
<p>我们知道C++和Java是有很大的区别的，在C++里面，一个变量，编译了以后，在运行时你是不能通过变量的名称来找到这个类的。因为这些变量都变成了地址或者偏移量。只代表某个内存区域。不能像Java那样通过反射动态获取。</p>
<p>所以，和结构体类似，想要获取一个C++对象的某个成员变量，你只能通过这个<strong>对象的地址</strong>+<strong>这个成员变量在这个对象中的相对位置</strong>来获取到，</p>
<p>前者我们容易得到，而后者，则需要构造一个和生成这个对象的<code>class</code>或者<code>struct</code>一模一样的<code>class</code>或者<code>struct</code>然后通过指针的形式取得其中的成员变量</p>
<p>看到这里可能就有人有疑问了：</p>
<ul>
<li>为什么我在原始的ZjDroid源码里面看到了和Android源码里面一样的结构体定义或者class定义？</li>
<li>为什么是一模一样？</li>
</ul>
<p>那是因为，只有一模一样，才能有一样的偏移量啊！</p>
<p>假设已经取得的<code>DexFile</code>的某个对象的地址<code>adress</code>(假设是<code>long</code>类型)，想获得对象中的成员变量<code>begin_</code>的值，应该用以下的步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DexFile *dexFile_ptr = (DexFile *)adress; // cast为DexFile类型的指针</span><br><span class="line"></span><br><span class="line">dexFile_ptr -&gt; begin_; // 这样取得begin_的内容</span><br></pre></td></tr></table></figure>
<p>对于第一个问题：设想如果你的代码里面没有<code>DexFile</code>的定义，怎么通过编译？编译器会告诉你找不到符号</p>
<p>实际上第二句：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dexFile_ptr -&gt; begin_;</span><br></pre></td></tr></table></figure></p>
<p>可以理解为:<br>（<code>dexFile_ptr</code>的地址 + <code>begin_</code>这个成员变量在对象里的相对位置）就是<code>begin_</code>的内容在内存中的位置</p>
<p>而这个相对位置，是编译时决定的，与class的结构有关，与编译器有关，与平台有关。</p>
<h3 id="关于C-对象的内存结构"><a href="#关于C-对象的内存结构" class="headerlink" title="关于C++对象的内存结构"></a>关于C++对象的内存结构</h3><p>以下是我个人所了解到的</p>
<ul>
<li>C++中的类如果有虚函数存在，那么对象的内存结构中第一个位置应该是<strong>虚函数表的指针</strong>。<a href="https://www.linuxidc.com/Linux/2014-12/111047.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2014-12/111047.htm</a></li>
<li>C++中的函数与类绑定，在对象中不占内存</li>
<li>C++中的static成员变量与类绑定，在对象中不占内存</li>
</ul>
<h3 id="挫折"><a href="#挫折" class="headerlink" title="挫折"></a>挫折</h3><p>发现自己编译出的so文件中<code>std::string</code>类型的大小和art虚拟机中的不一致，<br><a href="https://github.com/KB5201314/ZjDroid/blob/master/app/src/main/jni/dvmnative/dexfile_art.h#L454" target="_blank" rel="noopener">https://github.com/KB5201314/ZjDroid/blob/master/app/src/main/jni/dvmnative/dexfile_art.h#L454</a></p>
<p>通过dump出这一块内存经过分析可知</p>
<p>内存结构对应关系为：</p>
<p><img src="/images/blog/42_0.png" alt="DexFile类的对象的内存结构"></p>
<p>这里的<code>std::string</code>占了3 * 4 = 12个字节，而我编译出来的so里面，它是只占了4个字节的。</p>
<p>这导致，在那个string之后的内容都发生错位，也就是说，我编译出来的class，偏移量和art虚拟机里面的so文件里的不一样，这导致向ZjDroid发送<code>backsmali</code>命令无法使用</p>
<p>解决办法：</p>
<p>在一定范围内进行内存搜索：<br>因为<code>begin_</code>和<code>head_ptr</code>的值是一样的，我在之后的一定的内存区域内搜索<code>begin_</code>的值就能找到<code>head_ptr</code>的位置了<br><a href="https://github.com/KB5201314/ZjDroid/blob/master/app/src/main/jni/dvmnative/dvmnative.cpp#L583" target="_blank" rel="noopener">https://github.com/KB5201314/ZjDroid/blob/master/app/src/main/jni/dvmnative/dvmnative.cpp#L583</a></p>
<h3 id="出炉"><a href="#出炉" class="headerlink" title="出炉"></a>出炉</h3><p>源码：<br><a href="https://github.com/KB5201314/ZjDroid" target="_blank" rel="noopener">https://github.com/KB5201314/ZjDroid</a><br>apk下载：<br><a href="https://github.com/KB5201314/ZjDroid/releases" target="_blank" rel="noopener">https://github.com/KB5201314/ZjDroid/releases</a></p>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>由于原始版本的源码过于老旧，似乎只适配到Android sdk 17</p>
<p>在高版本上部分api发生改变，会引发异常</p>
<p>已知：</p>
<ul>
<li>应用敏感行为监控有部分功能不能使用，尤其是网络相关，比如新版Android删了<code>apache</code>的<code>http</code>库改用<code>Okhttp</code>，ZjDroid还未跟进。</li>
<li>ZjDroid的<code>backsmali</code>命令虽然获取dex信息部分（native层）已经搞定，但是ZjDroid所使用的<code>org.jf.dexlib2</code>等库是四年前的版本，不支持art，要改为新版的话，要做很多修改。</li>
</ul>
<p>欢迎提交改进</p>
<h3 id="查看Android源码的网站"><a href="#查看Android源码的网站" class="headerlink" title="查看Android源码的网站"></a>查看Android源码的网站</h3><ul>
<li>grepcode:支持查看Android5.1.1及以前的源码，支持文件比较<br><a href="http://www.grepcode.com/" target="_blank" rel="noopener">http://www.grepcode.com/</a></li>
<li>androidxref:资源全，但文件比较功能没上面的那个好用<br><a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>解决爱加密加固之后使用xposed hook的时候log打印不出来的问题:<br><a href="https://bbs.pediy.com/thread-216965.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-216965.htm</a></li>
<li>C++类对象的内存模型:<br><a href="https://www.linuxidc.com/Linux/2014-12/111047.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2014-12/111047.htm</a></li>
<li>std::string源码探秘和性能分析：<br><a href="https://blog.csdn.net/ybxuwei/article/details/51326830" target="_blank" rel="noopener">https://blog.csdn.net/ybxuwei/article/details/51326830</a></li>
<li>修改安卓源码：Art模式下的通用脱壳方法:<br><a href="http://www.freebuf.com/articles/terminal/166307.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/terminal/166307.html</a></li>
<li>GDB中打印ART基础类:<br><a href="http://www.cnblogs.com/YYPapa/p/6858787.html" target="_blank" rel="noopener">http://www.cnblogs.com/YYPapa/p/6858787.html</a></li>
<li>阿里早期Android加固代码的实现分析:<br><a href="http://www.voidcn.com/article/p-ntseiwvg-bqs.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-ntseiwvg-bqs.html</a></li>
<li>[原创]阿里早期加固代码还原4.4-6.0:<br><a href="https://bbs.pediy.com/thread-215078.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-215078.htm</a></li>
<li>dex_file.h头文件<br><a href="http://androidxref.com/7.1.2_r36/xref/art/runtime/dex_file.h" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/art/runtime/dex_file.h</a></li>
<li>dex_file.h头文件（Android P）<br><a href="https://android.googlesource.com/platform/art/+/android-p-preview-2/libdexfile/dex/dex_file.h" target="_blank" rel="noopener">https://android.googlesource.com/platform/art/+/android-p-preview-2/libdexfile/dex/dex_file.h</a></li>
<li>dalvik_system_DexFile.h头文件<br><a href="http://androidxref.com/7.1.2_r36/xref/art/runtime/native/dalvik_system_DexFile.h" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/art/runtime/native/dalvik_system_DexFile.h</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>[Codeforces]Contest 1005 E2. Median on Segments (General Case Edition)</title>
    <url>/blog/44/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://codeforces.com/contest/1005/problem/E2" target="_blank" rel="noopener">Codeforces Round #496 (Div. 3) - E2. Median on Segments (General Case Edition)</a></p>
<h3 id="0x00问题转化"><a href="#0x00问题转化" class="headerlink" title="0x00问题转化"></a>0x00问题转化</h3><p>为求得中位数为m的所有区间组合，可以将问题转化为两个更容易的问题</p>
<blockquote>
<p>“求&lt;中位数为大于等于m的数&gt;的所有组合数量 - &lt;中位数为大于等于m+1的数&gt;的所有组合数量”</p>
</blockquote>
<h3 id="0x00求解问题"><a href="#0x00求解问题" class="headerlink" title="0x00求解问题"></a>0x00求解问题</h3><p>求&lt;中位数为大于等于m的数&gt;的所有组合数量</p>
<p>从左到右遍历输入数据，若遇到大于等于m的则+1，否则-1<br><strong>若某个区间[a,b]中+1 -1的和最终大于0(即大于等于m的数多于小于等于m的数)，则[a,b]区间的中位数大于等于m</strong></p>
<p>统计这些区间的数目，就是答案<br>但是遍历区间复杂度是n^2，要计算每一个子区间的和值，可以采用类似于前缀数组的思想，<br>但是这样整体的复杂度至少是n^2，数据量n最多是20w，可能会出现TL，</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cnblogs.com/widsom/p/9290269.html" target="_blank" rel="noopener">http://www.cnblogs.com/widsom/p/9290269.html</a></p>
<p>优化：<br>要统计[a,b]大于0出现的次数，也就是统计“[0,b]的值 &gt; [0,a-1]的值”这种情况出现的次数，<br>可以采用一次遍历输入数据，假设访问到第c个数，<a href="k=0,1,2...c">0,k</a>可采用类似于前缀数组的方式迭代计算，</p>
<p>同时用数组或map来保存先前[0,k] (k=0,1,2…c-1)的值出现的次数，<br>将小于[0,c]的值出现的次数相加，所有的c都这样操作，加起来的就是答案<br>为将小于[0,c]的值出现的次数相加，可以采用类似于莫队算法的办法，边界一次移动一格</p>
<p><img src="/images/blog/44_0.png" alt="举例某一时刻的状态"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> an[MAXN];</span><br><span class="line"><span class="keyword">int</span> appear[MAXN * <span class="number">2</span>];<span class="comment">//数组开两倍，从中间开始用以满足加减</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = n;<span class="comment">// 使用数组从中间开始</span></span><br><span class="line">	appear[count]++;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> mo = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (an[i] &gt;= m) &#123;<span class="comment">// +1</span></span><br><span class="line">			mo += appear[count];</span><br><span class="line">			count++;</span><br><span class="line">			appear[count]++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// -1</span></span><br><span class="line">			count--;</span><br><span class="line">			mo -= appear[count];</span><br><span class="line">			appear[count]++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += mo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, an + i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = solve(m);</span><br><span class="line">	<span class="built_in">memset</span>(appear, <span class="number">0</span>, <span class="keyword">sizeof</span>(appear));</span><br><span class="line">	ans -= solve(m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces contest 1005</tag>
        <tag>Codeforces Round 496 (Div. 3)</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>[POJ]1150 The Last Non-zero Digit</title>
    <url>/blog/45/</url>
    <content><![CDATA[<h3 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h3><p><a href="http://poj.org/problem?id=1150" target="_blank" rel="noopener">http://poj.org/problem?id=1150</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/txl199106/article/details/40653579" target="_blank" rel="noopener">https://blog.csdn.net/txl199106/article/details/40653579</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了统计2，5的总因子数，还统计末尾位为3，7，9的数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">(LL co[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> m = n; m &gt; <span class="number">0</span>; m = m / <span class="number">5</span>) &#123;<span class="comment">// 处理1...n之间的奇数的末尾位</span></span><br><span class="line">		<span class="comment">// 末尾位可能为1, 3, 5, 7, 9</span></span><br><span class="line">		<span class="comment">// 1无需统计，3,7,9只要求统计出现在末位的次数</span></span><br><span class="line">		<span class="comment">// 5需要统计作为因子出现过的次数</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将这些奇数分为以5的倍数和非5的倍数</span></span><br><span class="line">		<span class="comment">// 例如1,3,5,7,9,11,13...,53,55,57,59</span></span><br><span class="line">		<span class="comment">// 分为1,3,7,9,11,13,17...,53,57,59和5*1，5*3，5*5...5*11，在for循环里每次m处以5来实现问题转换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 先统计1...m的奇数中不含因子5的数中末尾3，7，9出现的次数</span></span><br><span class="line">		co[<span class="number">1</span>] += m / <span class="number">10</span> + ((m % <span class="number">10</span>) &gt;= <span class="number">3</span>); <span class="comment">// m[1] 统计3</span></span><br><span class="line">		co[<span class="number">3</span>] += m / <span class="number">10</span> + ((m % <span class="number">10</span>) &gt;= <span class="number">7</span>); <span class="comment">// m[1] 统计7</span></span><br><span class="line">		co[<span class="number">4</span>] += m / <span class="number">10</span> + ((m % <span class="number">10</span>) &gt;= <span class="number">9</span>); <span class="comment">// m[1] 统计9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开始问题转换（利用for循环）(其实也可像下面那样用递归)</span></span><br><span class="line">		<span class="comment">// 将1...m的奇数中含有因子5的（5，15，25，35...）(共有(m / 10 + ((m % 10) &gt;= 5))个)，先处以因子5，转化为统计（1，3，5，7...）</span></span><br><span class="line">		co[<span class="number">2</span>] += m / <span class="number">10</span> + ((m % <span class="number">10</span>) &gt;= <span class="number">5</span>);<span class="comment">//统计因子5</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// m[0] 统计2</span></span><br><span class="line">	co[<span class="number">0</span>] += n / <span class="number">2</span>;<span class="comment">// 处理1...n之间的偶数，每个先处以2，问题转换为统计1...(n/2)，采用递归</span></span><br><span class="line">	count(co, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		LL co_1[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//依次统计2，3，5，7，9的数目</span></span><br><span class="line">		LL co_2[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">		count(co_1, n);<span class="comment">// 统计1...n</span></span><br><span class="line">		count(co_2, n - m);<span class="comment">// 统计1...n-m</span></span><br><span class="line">		<span class="comment">// 统计完相减</span></span><br><span class="line">		<span class="comment">// for (int i = 0; i &lt; 5; ++i)</span></span><br><span class="line">		<span class="comment">// &#123;</span></span><br><span class="line">		<span class="comment">// 	printf("%d ", co_1[i]);</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="comment">// printf("\n");</span></span><br><span class="line">		<span class="comment">// for (int i = 0; i &lt; 5; ++i)</span></span><br><span class="line">		<span class="comment">// &#123;</span></span><br><span class="line">		<span class="comment">// 	printf("%d ", co_2[i]);</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="comment">// printf("\n");</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> r_2[] = &#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>&#125;; <span class="comment">// 观察发现，2^i的尾数循环出现（除了2^0尾数是1外，其余情况尾数都以6，2, 4, 8...出现）（例如 1，2，4，8，16，32，64）</span></span><br><span class="line">		<span class="keyword">int</span> r_3[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>&#125;; <span class="comment">// 3^i的尾数循环出现</span></span><br><span class="line">		<span class="keyword">int</span> r_7[] = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>&#125;; <span class="comment">// 7^i的尾数循环出现</span></span><br><span class="line">		<span class="keyword">int</span> r_9[] = &#123;<span class="number">1</span>, <span class="number">9</span>&#125;; <span class="comment">// 9^i的尾数循环出现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ans = (ans * r_3[(co_1[<span class="number">1</span>] - co_2[<span class="number">1</span>]) % <span class="number">4</span>]) % <span class="number">10</span>;</span><br><span class="line">		ans = (ans * r_7[(co_1[<span class="number">3</span>] - co_2[<span class="number">3</span>]) % <span class="number">4</span>]) % <span class="number">10</span>;</span><br><span class="line">		ans = (ans * r_9[(co_1[<span class="number">4</span>] - co_2[<span class="number">4</span>]) % <span class="number">2</span>]) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (co_1[<span class="number">0</span>] - co_2[<span class="number">0</span>] &gt; co_1[<span class="number">2</span>] - co_2[<span class="number">2</span>]) &#123;</span><br><span class="line">			<span class="comment">// 2的数目多于5</span></span><br><span class="line">			ans = (ans * r_2[((co_1[<span class="number">0</span>] - co_2[<span class="number">0</span>]) - (co_1[<span class="number">2</span>] - co_2[<span class="number">2</span>])) % <span class="number">4</span>]) % <span class="number">10</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (co_1[<span class="number">0</span>] - co_2[<span class="number">0</span>] &lt; co_1[<span class="number">2</span>] - co_2[<span class="number">2</span>]) &#123;</span><br><span class="line">			<span class="comment">// 5的数目多于2</span></span><br><span class="line">			ans = <span class="number">5</span>;<span class="comment">// 奇数乘以5，尾数依然是5</span></span><br><span class="line">		&#125;<span class="comment">// 2的数目和5的数目相同时乘1，无需乘</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>阶乘</tag>
        <tag>最低非零位</tag>
      </tags>
  </entry>
  <entry>
    <title>[POJ]1061 青蛙的约会</title>
    <url>/blog/46/</url>
    <content><![CDATA[<h3 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h3><p><a href="http://poj.org/problem?id=1061" target="_blank" rel="noopener">http://poj.org/problem?id=1061</a></p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>此题用扩展欧几里得计算<br>(n-m) <em> X ≡ (x-y) (mod l) 的最小正整数解<br>即(n-m) </em> X + l * Y = (x-y)</p>
<p>贝祖定理： <strong>ax + by = m 有整数解时当且仅当m是gcd(a,b)的倍数。</strong><br>用扩展欧几里得能算出<strong>ax + by = gcd(a,b)</strong>的一个特解<br>此特解乘上<strong>m / gcd(a,b)</strong>得到的就是<strong>ax + by = m</strong>的特解</p>
<p><strong>所有的解x mod (b/gcd(a,b))同余</strong><br><strong>所有的解y mod (a/gcd(a,b))同余</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/ccnuacmhdu/article/details/79415284" target="_blank" rel="noopener">https://blog.csdn.net/ccnuacmhdu/article/details/79415284</a><br><a href="https://www.cnblogs.com/xeoncdy/p/7265419.html" target="_blank" rel="noopener">https://www.cnblogs.com/xeoncdy/p/7265419.html</a><br><a href="https://blog.csdn.net/sun897949163/article/details/51894372" target="_blank" rel="noopener">https://blog.csdn.net/sun897949163/article/details/51894372</a><br><a href="https://blog.csdn.net/yoer77/article/details/69568676" target="_blank" rel="noopener">https://blog.csdn.net/yoer77/article/details/69568676</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LL x, y, m, n, l;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展欧几里得求二元一次方程的一个解</span></span><br><span class="line"><span class="function">LL <span class="title">exGCD</span><span class="params">(LL a, LL b, LL&amp;x, LL&amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">1</span>;<span class="comment">// a * 1 + b * 0 = a</span></span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LL r = exGCD(b, a % b, x, y);</span><br><span class="line"></span><br><span class="line">	LL t_y = y;</span><br><span class="line">	y = x + (-a / b) * y;</span><br><span class="line">	x = t_y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;<span class="comment">//返回值为gcd</span></span><br><span class="line">	<span class="comment">// 记法：该函数返回时满足 a * x + b * y = gcd; 调整x和y只是为了返回上一层调用后能重新调整x'和y'</span></span><br><span class="line">	<span class="comment">// x' = y</span></span><br><span class="line">	<span class="comment">// y' = x + (-a/b) * y</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld"</span>, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	LL a = ((n - m) % l + l ) % l;<span class="comment">//（将X的系数化为正的）</span></span><br><span class="line"></span><br><span class="line">	LL x0, y0;</span><br><span class="line"></span><br><span class="line">	LL gcd = exGCD(a, l, x0, y0);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((!a) || (x - y) % gcd) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	x0 = x0 * (x - y) / gcd;<span class="comment">// x0原先是 (n-m) * X + l * Y = gcd 的一个特解，现在将它化为 (n-m) * X + l * Y = (x-y)的特解X0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找出最小的正整数解X0,所有X mod (b/gcd(a,b))同余</span></span><br><span class="line">	x0 = ((x0 % (l / gcd)) + (l / gcd)) % (l / gcd);<span class="comment">// 用%表示mod的办法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, x0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>[hihoCoder]1777 彩球</title>
    <url>/blog/47/</url>
    <content><![CDATA[<h3 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h3><p><a href="https://hihocoder.com/problemset/problem/1777" target="_blank" rel="noopener">https://hihocoder.com/problemset/problem/1777</a></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p>第一行三个正整数 n, k, P<br>  对于50%的数据，有1 ≤ n, k, P ≤ 10^9<br>  对于100%的数据，有1 ≤ n, k, P ≤ 10^18</p>
</blockquote>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>考察大数的幂次取模<br>乘法溢出</p>
<p>用快速幂和快速乘解题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastMultiply</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t = a;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			ans = (ans + t) % p;</span><br><span class="line">		&#125;</span><br><span class="line">		t = (t + t) % p;</span><br><span class="line">		b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> k, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t = n;</span><br><span class="line">	<span class="keyword">while</span> (k) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			ans = fastMultiply(ans, t, p);</span><br><span class="line">		&#125;</span><br><span class="line">		t = fastMultiply(t, t, p);</span><br><span class="line">		k = k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n, k, p;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;k, &amp;p);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, fastPow(k, n, p));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>hihoCoder</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>快速乘</tag>
        <tag>大数处理</tag>
      </tags>
  </entry>
  <entry>
    <title>[Codeforces]Contest 1009 E. Intercity Travelling</title>
    <url>/blog/48/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Educational Codeforces Round 47 (Rated for Div. 2) - E. Intercity Travelling<br><a href="http://codeforces.com/contest/1009/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1009/problem/E</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>n千米，有n段路，共有n-1个可能可以休息的地方，则共有2^(n-1)种可能的休息方式;<br>要计算 p⋅2^(n−1)，也就是计算所有的可能的休息方式下的消耗之和;<br>分解出来，就是要计算所有的可能的休息方式中所有的a[i]的和;<br>也就是求和 sum(a[i] * 消耗a[i]出现的总次数) (i-&gt;1,2,3,…n);</p>
<p>我们可以按照这种思路，统计a[1]出现的总次数，a[2]出现的次数，这个应该是有规律的;<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如n=4的情况</span><br><span class="line"></span><br><span class="line">0  1  2  3  4</span><br><span class="line">#--#--#--#--#</span><br><span class="line">其中 1,2,3 这几个点既可以是休息，也可以是不休息两种状态</span><br></pre></td></tr></table></figure></p>
<p>先考虑简单的，要使a[1]出现:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若a[1]出现在 0-1 之间，显然这是必定的，和 1,2,3 休息与不休息都没关系，有所以在 0-1 出现a[1]的次数是 2^3 = 2^(n-1) 次</span><br><span class="line">若a[1]出现在 1-2 之间，则必须是在 1 点处休息了，而 2，3 处则没关系，那么所有在 1-2 出现a[1]的次数是 2^2 = 2^0 * 2^(n-2) = 2^(n-2) 次</span><br><span class="line">若a[1]出现在 2-3 之间，则必须是在 2 点休息了，和在 1，3 的状况没关系，那么所有在 2-3 出现a[1]的次数是 2^2 = 2^1 * 2^(n-3) = 2^(n-2) 次</span><br><span class="line">同理可得a[1]出现在 3-4 之间的次数是 2^2 = 2^2 * 2^(n-4) = 2^(n-2) 次</span><br><span class="line"></span><br><span class="line">则a[1]出现的总次数是 2^3 + 2^2 + 2^2 + 2^2</span><br></pre></td></tr></table></figure></p>
<p>再考虑a[2],a[3],a[4]的情况，<br>a[2]出现的总次数是 2^2 + 2^1 + 2^1<br>a[3]出现的总次数是 2^1 + 2^0<br>a[4]出现的总次数是 2^0</p>
<p>可以发现规律<br><strong>a[i]出现的次数是 2^(n-i) + 2^(n-i-1) * (n-i)</strong></p>
<p>乘以a[i]加起来就是答案</p>
<p>拙劣代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n最大为100000, n^2算法不可取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// long long an[1000005];</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> _2n[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">	_2n[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		b = (b * <span class="number">2</span>) % MOD;</span><br><span class="line">		_2n[i] = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> a;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a);</span><br><span class="line">		ans = (ans + ((_2n[n - i] + ((n - i) * _2n[n - i - <span class="number">1</span>]) % MOD) * a) % MOD) % MOD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// TL旧代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// for (int k = 1; k &lt;= n; ++k) &#123;</span></span><br><span class="line">	<span class="comment">// 	ans = (ans + ans) % MOD;</span></span><br><span class="line">	<span class="comment">// 	printf("x2\n");</span></span><br><span class="line">	<span class="comment">// 	for (int i = 1; i &lt; k; ++i) &#123;</span></span><br><span class="line">	<span class="comment">// 		ans = (ans + an[i] * _2n[k - i - 1]) % MOD;</span></span><br><span class="line">	<span class="comment">// 		printf("+a[%d] x 2^%d\n", i, k - i - 1);</span></span><br><span class="line">	<span class="comment">// 	&#125;</span></span><br><span class="line">	<span class="comment">// 	ans = (ans + an[k]) % MOD;</span></span><br><span class="line">	<span class="comment">// 	printf("+a[%d] x 2^0\n", k);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>Codeforces contest 1009</tag>
        <tag>Educational Codeforces Round 47 (Rated for Div. 2)</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces contest 1082 E. Increasing Frequency</title>
    <url>/blog/50/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1082/problem/E" target="_blank" rel="noopener">原题在这</a></p>
<p>这题搞了好久，大意是讲给一个长为n的数串，让其中<strong>某一个子区间的数</strong>都+k，然后使得整个串里等于c的数个数尽可能大，问最大多少</p>
<p>串里的数范围挺宽的，先想这个+k，实际上就是尽可能多的把不是c的变成c，尽量少把c变成其它的，要注意这里k选定了以后，能变成c的数就只有是c-k</p>
<p>由于串里的c一开始的数量是确定的，于是最终c的数量=原来c的数量+(变成了c的数的数量-变成了别的数的c的数量)，其实我们就是要求括号里的最大值</p>
<h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><p>代码是我看了别人的提交后写的，感觉这里能想到dp的都是神仙吧，(这都什么人呀!!!!)</p>
<p>理解了这个dp后我才修好了我下面写的贪心</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 答案 = c的次数(不变)+最佳的(区间内非c的某种元素出现次数-c的出现次数)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cl[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN];<span class="comment">// 保存遍历过程中i上一次出现的位置</span></span><br><span class="line"><span class="keyword">int</span> dp[MAXN];<span class="comment">// dp[i]以i位置结尾处的最佳结果</span></span><br><span class="line"><span class="keyword">int</span> dpo[MAXN];<span class="comment">// 以c-i作为k的最佳结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;c);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (t == c) &#123;</span><br><span class="line">			cl[i]++;</span><br><span class="line">		&#125;</span><br><span class="line">		cl[i] += cl[i - <span class="number">1</span>];<span class="comment">// 前缀数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (t == c) &#123;</span><br><span class="line">			dp[i] = max(<span class="number">0</span>, dp[i - <span class="number">1</span>] - <span class="number">1</span>);<span class="comment">// 要么c所在位置不选，则以此处为结尾的最佳差值为0；要么选上,则继承以上一个位置结尾的差值再减去1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 不为c时</span></span><br><span class="line">			dpo[i] = max(<span class="number">1</span>, (dpo[pre[t]] + <span class="number">1</span>) - (cl[i] - cl[pre[t]])); <span class="comment">// 从上次这个t出现的位置（不包括）到这个位置结束这段区间，要么从当前位置重新开始一个区间(1)（肯定比不开始(0)好），要么接上上一段区间，其它情况都不如这两种情况；</span></span><br><span class="line">			dp[i] = max(dp[i - <span class="number">1</span>], dpo[i]);<span class="comment">//要么不是当前的t为参照进行变换(dp[i-1])，要么是(dpo[i])</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pre[t] = i;</span><br><span class="line"></span><br><span class="line">		result = max(result, dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result += cl[n];<span class="comment">//最后得加上总序列中c出现的次数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>这题一开始考虑数据范围很大，二层三层循环啥的肯定gg，然后想到<strong>求一段给定数列的子区间和的最大值的方法</strong>，那种方法只要一次遍历数组不断更新前缀和的最小值，然后每次更新max(当前的前缀和-之前找到的最小值)</p>
<p>这里也效仿一下，对所有除了c以外出现的数都这么求<br>注意这里计算最小前缀和的时刻我放到了遇到t并处理之前，然后再计算当前前缀和，然后再相减更新结果</p>
<p>注意在这里k是有很多取值的（因为串里的数在一个情况下都能变成c），我们这里一并进行运算了，这些k的取值情况之间相互是没有联系的，具体的看代码吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用了类似于一次遍历数组求区间最大和的那种办法的思想（即遍历数组不断max(当前前缀和-min(历史上的前缀和))），对除了c以外的那些数都做这种计算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cl[MAXN];<span class="comment">//c的出现次数前缀数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mins[MAXN];<span class="comment">//历史上(i出现次数-那时c出现次数取最小值的时候)i出现次数的值</span></span><br><span class="line"><span class="keyword">int</span> minpos[MAXN];<span class="comment">//i出现上述最小值的位置</span></span><br><span class="line"><span class="keyword">int</span> nows[MAXN];<span class="comment">//当前出现i的次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;c);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">		cl[i] += cl[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (t == c) &#123;</span><br><span class="line">			cl[i]++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//每次在遇到t时,先计算一下在这次t出现之前的最小前缀和，不考虑除t和c以外的其它元素，因为此时k=c-t已经确定，其它数在这种情况下没有影响</span></span><br><span class="line">			<span class="keyword">if</span> (nows[t] - cl[i] &lt; mins[t] - cl[minpos[t]]) &#123;</span><br><span class="line">				mins[t] = nows[t];</span><br><span class="line">				minpos[t] = i - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//然后再考虑这次t的出现，处理t</span></span><br><span class="line">			nows[t]++;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//相减更新结果</span></span><br><span class="line">			result = max(result, ((nows[t] - cl[i]) - (mins[t] - cl[minpos[t]])));</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result += cl[n];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[奇技淫巧]Android Studio免DDMS免configure快速调试Smali项目</title>
    <url>/blog/49/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>Android Studio是开发Android应用的一大利器，极大的提高了生产力（虽然比较臃肿），debug功能也非常好用，而且不止能debug Java代码，smali代码也能调试，配合apktool使用真的是爽的很（除了indexing花了老半天这个问题以外）。</p>
<p>但是！这个利器在<strong>调试smali工程的时候</strong>，就表现得十分不友好啦，以前有DDMS的时候还好一些，能看到调试端口号，但是经常遇到DDMS和AndroidStudio的adb端口冲突的问题，水火不容，无奈之下只能<code>adb shell am start -D -n xxx.xxxx.xxxx/.xxxx</code>手动以debug模式启动应用，配合<code>adb forward tcp:xxxx jdwp:xxxx</code>，但是不知道咋回事经常遇到<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unable to open debugger port (localhost:8603): java.io.IOException &quot;handshake failed - connection prematurally closed&quot;</span><br></pre></td></tr></table></figure></p>
<p>每次遇到这种错误，我心中是一万只草泥马飞奔而过啊！这tm还让不让人debug啦！</p>
<p><img src="/images/blog/49_0.png" alt="WTF!"></p>
<h3 id="冷静分析"><a href="#冷静分析" class="headerlink" title="冷静分析"></a>冷静分析</h3><p>想起了Android Studio打开纯Android项目的时候，在顶部工具栏会有一个调试用的按钮<code>Attach debugger to Android process</code>,就是那个图标是竖着的长方形，右下角一只小虫子的按钮，点一下可以选择要attch的进程<br><img src="/images/blog/49_1.png" alt="Attach debugger to Android process"></p>
<p>这个功能在开发的时候用起来很爽，但是当我们打开的不是Android项目时：<br><img src="/images/blog/49_2.png" alt="WTF!"></p>
<p>这个按钮没了<br><img src="/images/blog/49_3.png" alt="假的Android Studio吧"></p>
<h3 id="别着急"><a href="#别着急" class="headerlink" title="别着急"></a>别着急</h3><p>这应该是Android Studio 设计的问题，它被设计成了只要不是Android项目就不显示那些按钮，但是它忽略了调试smali的情况</p>
<p>冷静，何必和一个小按钮过意不去呢，让我们来想想对策。</p>
<p>Run -&gt; 没有<br>Help -&gt; Find Action -&gt; 搜不到</p>
<p>就在这山穷水复无路之际，突然想出个点子：</p>
<p><strong>快捷键！</strong><br><strong>快捷键！</strong><br><strong>快捷键！</strong></p>
<h3 id="解决办法是快捷键"><a href="#解决办法是快捷键" class="headerlink" title="解决办法是快捷键"></a>解决办法是快捷键</h3><p><strong>Setting -&gt; 搜索 -&gt; Attach debugger to Android process -&gt; keymap</strong></p>
<p><img src="/images/blog/49_4.png" alt="真·Attach debugger to Android process"></p>
<p>不出所料真的搜到了，<strong>这里的快捷键是我添加的，原先没有快捷键</strong>，我设置的是<code>Ctrl + Alt + R</code><br>R就是<code>reverse</code>嘛，+D的都被占了没办法。</p>
<p>确认，出来试试。</p>
<p>果然功夫不负有心人！</p>
<p><img src="/images/blog/49_5.png" alt="真·Choose Process"></p>
<p>测试发现完全ok！</p>
<h3 id="DDMS，再见"><a href="#DDMS，再见" class="headerlink" title="DDMS，再见"></a><del>DDMS，再见</del></h3><p>去你丫的DDMS，再见（丢）！<br><img src="/images/blog/49_6.png" alt="丢了"></p>
<p>不行。。。</p>
<p><img src="/images/blog/49_7.png" alt="捡起"><br>Android Studio 里还没有 Method Profiling 呢</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Debug</tag>
        <tag>DDMS</tag>
      </tags>
  </entry>
  <entry>
    <title>AVD_7.1_x86 安装微信经历</title>
    <url>/blog/51/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>好久没有写博客了，并不是其中没有折腾2333，作业太多好多事情都没写（其实就是懒）</p>
<p>那啥，手头有两台手机，一台太烂但是7.1.1 root过（曾经的主力机，依然坚挺），另一台是7.0 垃圾索大法，au定制机，没法root。<br>前一台没有运动传感器，想拿来计步都不行，第二台有传感器但是不能root，就不能微信刷步数啦23333（真是贪婪的人类）</p>
<p>寻思着在avd上装微信刷步数。于是有了下面的折腾记录，同时也是做个笔记，避免以后绕弯路，毕竟，博客都是给以后的自己看的23333。</p>
<h3 id="AVD-4-4"><a href="#AVD-4-4" class="headerlink" title="AVD_4.4"></a>AVD_4.4</h3><p>原先我就有一台Android 4.4的虚拟设备，已经root而且装了xp，接着安装微信和模块打算开刷的时候，我点开微信，悲剧发生了，闪退！！！！<br>看一下logcat，傻逼微信在新版用了一个sdk21之后才加入的函数，但是自己又声称最低支持Android4.4，我真是dnlm！！！！</p>
<p>没办法，看来4.4上是没法折腾的，索性再开一台Android 7.1的AVD吧，说不定以后还要用上呢。</p>
<h3 id="AVD-7-1"><a href="#AVD-7-1" class="headerlink" title="AVD_7.1"></a>AVD_7.1</h3><p>怎么安装这个就不用我多说啦，困难的地方主要就是root和安装微信这两个。</p>
<h4 id="root"><a href="#root" class="headerlink" title="root"></a>root</h4><p>root的话，就参考这个了：<br>把supersu官网的那一套东西下载下来（虽然各个版本方案不同，但是文件都在里头）<br><a href="https://blog.csdn.net/luvsnow/article/details/79963025" target="_blank" rel="noopener">android emulator 获取 Root权限</a></p>
<p>注意启动的时候加上<code>-writable-system</code><br>可惜的是，这种root好像是短时期的，不能按电源键重启设备，也不能adb reboot重启虚拟设备，这样再开之后root就会没。不过恢复也很简单，只要再走一遍</p>
<ul>
<li>adb root</li>
<li>adb remount</li>
<li>adb shell</li>
<li>su –install</li>
<li>su -d&amp;</li>
<li>setenforce 0<br>然后授权管理里面root又有啦</li>
</ul>
<h4 id="装微信"><a href="#装微信" class="headerlink" title="装微信"></a>装微信</h4><p>装微信可没那么简单，毕竟这里可是AVD_x86，要是简单的话你也不会来这里了。</p>
<p>微信只给了arm的lib，但是AVD普遍是x86的，会发生安装不上提示ABI不兼容的情况，对于这种问题有两个解决办法：</p>
<ul>
<li>安装arm的AVD（×）<br>  缺点：不是一般的慢，看不到开机完成</li>
<li>ARM-Translation（√）<br>  这个东西似乎是intel搞个一个闭源的层，能把apk里的arm用的so库在运行时动态地转换成x86的指令，所有x86的Android设备里都有这个，Android-x86和Genymotion据说都内置这个东西，总之牛逼就对了。</li>
</ul>
<h5 id="ARM-Translation"><a href="#ARM-Translation" class="headerlink" title="ARM-Translation"></a>ARM-Translation</h5><p>先贴一堆参考前人的资料</p>
<ol>
<li><a href="https://testerhome.com/topics/14231" target="_blank" rel="noopener">移动测试基础 Android 模拟器 Genymotion 安装配置与 ARM 支持</a></li>
<li><a href="https://android.stackexchange.com/questions/179482/android-emulator-install-failed-no-matching-abis-failed-to-extract-native-lib" target="_blank" rel="noopener">Android Emulator - INSTALL_FAILED_NO_MATCHING_ABIS: Failed to extract native libraries, res=-113</a></li>
<li><a href="https://blog.csdn.net/Roland_Sun/article/details/49735601" target="_blank" rel="noopener">如何打开Android X86对houdini的支持</a></li>
<li><a href="https://blog.csdn.net/wangkai0681080/article/details/79523003" target="_blank" rel="noopener">Android模拟器知识以及改造</a></li>
<li><a href="https://github.com/Rprop/libhoudini" target="_blank" rel="noopener">Github/Rprop/libhoudini</a></li>
<li><a href="http://baba.zhaoxiuyuan.com/2017/11/126_android_x86_houdini/" target="_blank" rel="noopener">Android-X86集成houdini(Arm兼容工具)</a></li>
</ol>
<p>资料这么多，我来梳理一下下吧：<br>要使用这个ARM-Translation其实不麻烦。主要下面几个步骤：</p>
<ul>
<li>改<code>build.prop</code>里的<code>ro.product.cpu.abilist</code>和<code>ro.product.cpu.abilist32</code>为<code>x86,armeabi-v7a,armeabi</code>，骗过包安装器，让它能把微信装上(参考第4篇文章)</li>
<li><p>改<code>default.prop</code>里的<code>ro.dalvik.vm.native.bridge=0</code>为<code>ro.dalvik.vm.native.bridge=libhoudini.so</code>，开启系统内的NativeBridge(参考第4篇文章)<br>  这里必须说一下，这个<code>default.prop</code>不在<code>system.img</code>里面，在<code>ramdisk.img</code>里面，<code>ramdisk.img</code>是只读的，只在启动的时候读一次到内存里。所以对<code>default.prop</code>的修改重启后会丢失，唯一的办法是手动编辑一个<code>ramdisk.img</code>，然后用emulator的<code>-ramdisk</code>选项指定修改后的<code>ramdisk.img</code>文件。</p>
<p>  编辑的方法也不难，参考这个里面的第二种方法<a href="https://blog.csdn.net/linuxdriverdeveloper/article/details/8124319" target="_blank" rel="noopener">制作/解压android ramdisk.img镜像</a></p>
<ul>
<li>从SDK目录里找到ramdisk.img，备份一份到自己的avd目录里，</li>
<li>用gunzip解压它，再用cpio解包到一个目录里</li>
<li>在这目录里找到<code>default.prop</code>进行修改</li>
<li>注意回package的时候，不要用cpio打包，可能会有问题导致开机不了，用<code>mkbootfs ./你之前解包到的目录 | gzip &gt; ramdisk-new.img</code>制作修改后的镜像（可以从这下载mkbootfs <a href="https://github.com/shenyuanv/mkboot-tools" target="_blank" rel="noopener">https://github.com/shenyuanv/mkboot-tools</a> ）</li>
<li>最后的<code>ramdisk-new.img</code>就是修改过的<code>ramdisk.img</code>了，在启动avd时用emulator的<code>-ramdisk</code>选项指定它即可。</li>
</ul>
</li>
<li><p>第3篇文章里面设置里那个叫<code>Enable native bridge</code>的选项我一直没有找到，它说效果只是<code>persist.sys.nativebridge</code>从0改成了1，保险起见，我在<code>build.prop</code>里加了<code>persist.sys.nativebridge=1</code></p>
</li>
<li><p>执行enable_nativebridge<br>  这几篇文章里都提到了<code>enable_nativebridge</code>这个东西，但是我找了一番，我的AVD里面没有这个脚本啊啊，真的服了，为什么google做了这个东西又不拿出来给我们用呢？？？？咱啥也不知道，咱也不敢问</p>
<p>  不过还好，在万能的github上面找到了一段<code>enable_nativebridge</code>，大概读一读能发现，恰好是Android7用的，而且考虑了各种情况，甚至还可以在线下载文件（显然访问不了，不过有办法解决的），<a href="https://gist.github.com/41a5d8ba498ceecca28e9d1069a32ede" target="_blank" rel="noopener">https://gist.github.com/41a5d8ba498ceecca28e9d1069a32ede</a>，访问不了gist的可以用google快照看。方便大家我就贴在下面了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/system/bin/sh</span></span><br><span class="line"></span><br><span class="line">PATH=/system/bin:/system/xbin</span><br><span class="line"></span><br><span class="line">houdini_bin=0</span><br><span class="line">dest_dir=/system/lib<span class="variable">$1</span>/arm<span class="variable">$1</span></span><br><span class="line">binfmt_misc_dir=/proc/sys/fs/binfmt_misc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">if</span> [ <span class="string">"`uname -m`"</span> = <span class="string">"x86_64"</span> ]; <span class="keyword">then</span></span><br><span class="line">		v=7_y</span><br><span class="line">		url=http://goo.gl/SBU3is</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		v=7_x</span><br><span class="line">		url=http://goo.gl/0IJs40</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	v=7_z</span><br><span class="line">	url=http://goo.gl/FDrxVN</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -s /system/lib<span class="variable">$1</span>/libhoudini.so ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">log</span> -pi -thoudini <span class="string">"found /system/lib<span class="variable">$1</span>/libhoudini.so"</span></span><br><span class="line"><span class="keyword">elif</span> [ -e /system/etc/houdini<span class="variable">$v</span>.sfs ]; <span class="keyword">then</span></span><br><span class="line">	mount /system/etc/houdini<span class="variable">$v</span>.sfs <span class="variable">$dest_dir</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">if</span> mountpoint -q <span class="variable">$dest_dir</span>; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">kill</span> -9 `fuser -m <span class="variable">$dest_dir</span>`</span><br><span class="line">		umount -f <span class="variable">$dest_dir</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	mkdir -p /data/arm</span><br><span class="line">	<span class="built_in">cd</span> /data/arm</span><br><span class="line">	<span class="keyword">while</span> ! mount houdini<span class="variable">$v</span>.sfs <span class="variable">$dest_dir</span>; <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">while</span> [ <span class="string">"<span class="variable">$(getprop net.dns1)</span>"</span> = <span class="string">""</span> ]; <span class="keyword">do</span></span><br><span class="line">			sleep 10</span><br><span class="line">		<span class="keyword">done</span></span><br><span class="line">		wget <span class="variable">$url</span> -cO houdini<span class="variable">$v</span>.sfs &amp;&amp; <span class="built_in">continue</span></span><br><span class="line">		rm -f houdini<span class="variable">$v</span>.sfs</span><br><span class="line">		sleep 30</span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[ -s /system/lib<span class="variable">$1</span>/libhoudini.so ] || mount --<span class="built_in">bind</span> <span class="variable">$dest_dir</span>/libhoudini.so /system/lib<span class="variable">$1</span>/libhoudini.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># this is to add the supported binary formats via binfmt_misc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -e <span class="variable">$binfmt_misc_dir</span>/register ]; <span class="keyword">then</span></span><br><span class="line">	mount -t binfmt_misc none <span class="variable">$binfmt_misc_dir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$binfmt_misc_dir</span></span><br><span class="line"><span class="keyword">if</span> [ -e register ]; <span class="keyword">then</span></span><br><span class="line">	[ -e /system/bin/houdini<span class="variable">$1</span> ] &amp;&amp; dest_dir=/system/bin</span><br><span class="line">	<span class="comment"># register Houdini for arm binaries</span></span><br><span class="line">	<span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">':arm_exe:M::\\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x28::'</span><span class="string">"<span class="variable">$dest_dir</span>/houdini:P"</span> &gt; register</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">':arm_dyn:M::\\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x28::'</span><span class="string">"<span class="variable">$dest_dir</span>/houdini:P"</span> &gt; register</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">':arm64_exe:M::\\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xb7::'</span><span class="string">"<span class="variable">$dest_dir</span>/houdini64:P"</span> &gt; register</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">':arm64_dyn:M::\\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\xb7::'</span><span class="string">"<span class="variable">$dest_dir</span>/houdini64:P"</span> &gt; register</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">if</span> [ -e arm<span class="variable">$&#123;1&#125;</span>_exe ]; <span class="keyword">then</span></span><br><span class="line">		houdini_bin=1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">log</span> -pe -thoudini <span class="string">"No binfmt_misc support"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$houdini_bin</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">log</span> -pe -thoudini <span class="string">"houdini<span class="variable">$1</span> enabling failed!"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">log</span> -pi -thoudini <span class="string">"houdini<span class="variable">$1</span> enabled"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[ <span class="string">"<span class="variable">$(getprop ro.zygote)</span>"</span> = <span class="string">"zygote64_32"</span> -a -z <span class="string">"<span class="variable">$1</span>"</span> ] &amp;&amp; <span class="built_in">exec</span> <span class="variable">$0</span> 64</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>把这个脚本放到avd里的<code>/system/bin/</code>目录下，记得把<code>log -pi -thoudini</code>改成<code>echo</code>方便我们最后观察是否成功了。</p>
<h6 id="houdini-sfs"><a href="#houdini-sfs" class="headerlink" title="houdini.sfs"></a>houdini.sfs</h6><p>其中最核心的是那个houdini.sfs文件，当然各个Android版本的文件名不太一样，国内要下载的话，第6篇文章里的作者给了短网址还原的办法，不过我还发现另外一个仓库 <a href="https://github.com/Rprop/libhoudini" target="_blank" rel="noopener">https://github.com/Rprop/libhoudini</a> ，这里面各个版本的sfs文件都有，阅读脚本发现，可以<strong>手动下载这个文件</strong>然后放到<code>/system/etc/</code>下面。</p>
<p>这个sfs文件其实是<code>squashfs</code>格式的一个影像，脚本里把它挂载到<code>/system/lib/arm</code>文件夹里（64位的情况是另一个文件夹，这里的描述都以x86为准，x86_64看上面的脚本进行变通）。</p>
<p><strong>一些意外</strong></p>
<ul>
<li><p>中途mount这个houdini.sfs的过程发生了一些意外，首先提示<code>No such file or directory</code>，手动<code>mkdir /system/lib/arm</code>解决了这个问题。</p>
</li>
<li><p>之后说<code>mount: losetup failed 1</code>，改为手动mount加上<code>-v</code>选项后说</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &apos;/system/etc/houdini7_x.sfs&apos; type &apos;ext3&apos; on &apos;/system/lib/arm/&apos;</span><br></pre></td></tr></table></figure>
<p>  显然它把我文件格式搞错了，这个sfs文件应该是<code>squashfs</code>而不是<code>ext3</code>，加<code>-t</code>选项强制指定<code>squashfs</code>格式后告诉我<code>No such device</code>，你说你马呢，我文件好端端在这你告诉我没有。无奈之下想到了<code>strace</code>大法，给这条命令前加上<code>strace</code>，查看系统调用过程，发现其中调用了<code>mount()</code>函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount(&quot;/system/etc/houdini7_x.sfs&quot;, &quot;/system/lib/arm/&quot;, &quot;squashfs&quot;, MS_SILENT, NULL) = -1 ENODEV (No such device)</span><br></pre></td></tr></table></figure>
<p>  man查mount()的手册发现，<code>ENODEV</code>表示不支持的文件系统格式，也就是说<strong>这个avd它丫的不支持<code>squashfs</code>这个文件系统</strong>，网上说可以在编译的时候加选项，但是显然我们是不会去编译的，费力不讨好。解决办法很简单，在宿主机上mount一下，把里面的文件拿出来<code>adb push</code>到avd的<code>/system/lib/arm</code>这个目录，大功告成。</p>
</li>
<li><p>之后还有个</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount --bind $dest_dir/libhoudini.so /system/lib$1/libhoudini.so</span><br></pre></td></tr></table></figure>
<p>  又失败了（Android终端里的命令好像就没几个好使的），目的主要是把<code>libhoudini.so</code>从<code>/system/lib/arm</code>文件夹引到<code>/system/lib</code>下面去，这个用<code>ln -s</code>搞一下就好。</p>
</li>
</ul>
<p>这么搞一通，终于等来了输出<code>houdini enabled</code>。至此<code>houdini</code>就算是迁进去了。</p>
<h5 id="装微信-1"><a href="#装微信-1" class="headerlink" title="装微信"></a>装微信</h5><p>微信还是那样装，打开也能登陆，看起来甚至没有任何问题，但是打开微信小程序的时候就出现问题了，直接崩掉。<br>logcat里冒出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">houdini : [17913] Unsupported feature (ID:0x20e000b2).</span><br></pre></td></tr></table></figure></p>
<p>在这之前的一个日志是houdini加载了微信里面的一个<code>libj2v8.so</code>文件，也许是因为这个文件里面的指令有点特殊所以崩的吧。</p>
<p>上网找了找，发现不少人遇到类似的这种<code>Unsupported feature</code>问题，尝试过ida开<code>libhoudini.so</code>找这个字符串，发现这样的错误一共有六类，字符串好像是<code>Unsupported feature (ID:0x20e%05x)</code>，也就是说后面的<code>0x000b2</code>是变化的，但是字符串引用的地方没找到，因为ida反汇编的时候很多函数没有反汇编成功，再加上我ida用的不太熟，就没看了。最后瞅了一眼<code>houdini.sys</code>里面有个<code>houdini</code>可执行文件，执行一下输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[18097] </span><br><span class="line">[18097] Please don&apos;t use this program directly!</span><br><span class="line">[18097] Use to check version only.</span><br><span class="line">[18097] Usage: --version        output version information and exit!</span><br><span class="line">[18097]</span><br></pre></td></tr></table></figure></p>
<p>看了一下我的–version输出是<code>Houdini version: 6.1.2d_x.48748</code>。它强调<code>don&#39;t use this program directly</code>，我就纳闷了，难不成这个程序除了输出version，里面还有东西？？？<br>索性拿ida开了一下，不出我所料，里面甚至有完整的<code>libhoudini.so</code>里面的内容，关键是这个文件ida反汇编得比较完善，按字符串找出错地方，发现是落入了一个switch语句的default区域，无奈代码太复杂，看不懂，放弃了。</p>
<h5 id="现有的其它方案"><a href="#现有的其它方案" class="headerlink" title="现有的其它方案"></a>现有的其它方案</h5><p>参考了现有的Android x86项目，发现它也使用到了houdini这个东西来实现arm架构支持，在它的Android7.1.1(sdk 25)版本中，同样也发现了<code>enable_nativebridge</code>这个脚本文件，在pc上u盘启动Android x86能够完美打开微信小程序，但是奇怪的是，根据脚本语句，它内部使用的不是对应的houdini7_x，而是houdini6_y，下面贴出<code>enable_nativebridge</code>的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/system/bin/sh</span></span><br><span class="line"></span><br><span class="line">PATH=/system/bin:/system/xbin</span><br><span class="line"></span><br><span class="line">houdini_bin=0</span><br><span class="line">dest_dir=/system/lib$1/arm$1</span><br><span class="line">binfmt_misc_dir=/proc/sys/fs/binfmt_misc</span><br><span class="line"></span><br><span class="line">cd /data/arm</span><br><span class="line">if [ -e /system/lib$1/libhoudini.so ]; then</span><br><span class="line">	log -pi -thoudini "found /system/lib$1/libhoudini.so"</span><br><span class="line">elif [ -e /system/etc/houdini$1.sfs ]; then</span><br><span class="line">	busybox mount /system/etc/houdini$1.sfs $dest_dir</span><br><span class="line">else</span><br><span class="line">	if mountpoint -q $dest_dir; then</span><br><span class="line">		kill -9 `fuser -m $dest_dir`</span><br><span class="line">		umount -f $dest_dir</span><br><span class="line">	fi</span><br><span class="line">	while ! busybox mount houdini$1.sfs $dest_dir; do</span><br><span class="line">		while [ "$(getprop net.dns1)" = "" ]; do</span><br><span class="line">			sleep 10</span><br><span class="line">		done</span><br><span class="line">		if [ -z "$1" ]; then</span><br><span class="line">			[ "`uname -m`" = "x86_64" ] &amp;&amp; url=http://goo.gl/Knnmyl || url=http://goo.gl/JsoX2C</span><br><span class="line">		else</span><br><span class="line">			url=http://goo.gl/n6KtQa</span><br><span class="line">		fi</span><br><span class="line">		wget $url -cO houdini$1.sfs &amp;&amp; continue</span><br><span class="line">		rm -f houdini$1.sfs</span><br><span class="line">		sleep 30</span><br><span class="line">	done</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> you don<span class="string">'t see the files '</span>register<span class="string">' and '</span>status<span class="string">' in /proc/sys/fs/binfmt_misc</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">then</span> run the following <span class="built_in">command</span>:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mount -t binfmt_misc none /proc/sys/fs/binfmt_misc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> this is to add the supported binary formats via binfmt_misc</span></span><br><span class="line"></span><br><span class="line">if [ ! -e $binfmt_misc_dir/register ]; then</span><br><span class="line">	mount -t binfmt_misc none $binfmt_misc_dir</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd $binfmt_misc_dir</span><br><span class="line">if [ -e register ]; then</span><br><span class="line">	[ -e /system/bin/houdini$1 ] &amp;&amp; dest_dir=/system/bin</span><br><span class="line"><span class="meta">	#</span><span class="bash"> register Houdini <span class="keyword">for</span> arm binaries</span></span><br><span class="line">	if [ -z "$1" ]; then</span><br><span class="line">		echo ':arm_exe:M::\\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x28::'"$dest_dir/houdini:P" &gt; register</span><br><span class="line">		echo ':arm_dyn:M::\\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x28::'"$dest_dir/houdini:P" &gt; register</span><br><span class="line">	else</span><br><span class="line">		echo ':arm64_exe:M::\\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xb7::'"$dest_dir/houdini64:P" &gt; register</span><br><span class="line">		echo ':arm64_dyn:M::\\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\xb7::'"$dest_dir/houdini64:P" &gt; register</span><br><span class="line">	fi</span><br><span class="line">	if [ -e arm$&#123;1&#125;_exe ]; then</span><br><span class="line">		houdini_bin=1</span><br><span class="line">	fi</span><br><span class="line">else</span><br><span class="line">	log -pe -thoudini "No binfmt_misc support"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $houdini_bin -eq 0 ]; then</span><br><span class="line">	log -pe -thoudini "houdini$1 enabling failed!"</span><br><span class="line">else</span><br><span class="line">	log -pi -thoudini "houdini$1 enabled"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">[ "$(getprop ro.zygote)" = "zygote64_32" -a -z "$1" ] &amp;&amp; exec $0 64</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>之后有尝试将houdini6_x安装到模拟器（选择x而不是y是因为x86的avd模拟器是32位的而不是64位）中，情况比houdini7_x要糟糕，这次是大概意思是是模拟器缺少x86的某些feature，程序都不能跑起来了，具体情况没有再深究了，后继想要继续弄的话，我想，可以从这个方面继续考虑。另外，houdini的原理可以探究一番，比如试试替代品什么的</p>
<h5 id="放弃装微信"><a href="#放弃装微信" class="headerlink" title="放弃装微信"></a>放弃装微信</h5><p>似乎模拟器里微信开不了小程序是现在的一种通病，夜神啥的也开不了，据说得上旧版本微信，我这里尝试安装微信7.0前的最后一个版本，但是登录之后就一直给我闪退了，日志也啥都没，emmmm，比较烦躁。</p>
<p>最后结局是：老老实实买新手机刷步数吧！</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="INSTALL-FAILED-CONTAINER-ERROR"><a href="#INSTALL-FAILED-CONTAINER-ERROR" class="headerlink" title="INSTALL_FAILED_CONTAINER_ERROR"></a>INSTALL_FAILED_CONTAINER_ERROR</h4><p>如果adb安装微信的时候提示<code>INSTALL_FAILED_CONTAINER_ERROR</code>，不是网上说的那种因为<code>Manifest.xml</code>里面写的安装位置不对的原因，多半是一些玄学问题，只要在<code>adb install</code>加上<code>-r</code>这个选项就好了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Xposed</tag>
        <tag>AVD</tag>
        <tag>root</tag>
      </tags>
  </entry>
  <entry>
    <title>自制玩具操作系统--week1</title>
    <url>/blog/52/</url>
    <content><![CDATA[<h2 id="DAY-0x00"><a href="#DAY-0x00" class="headerlink" title="DAY 0x00"></a>DAY 0x00</h2><p>先装个翻译插件，装了半天找了个勉强能用的<br>然后考虑用git来做版本控制，方便和原版进行比较找出自己的修改，然后发现文字编码问题，于是乎捣鼓了个工具来批量转换文件编码（一大堆时间栽进去了）。</p>
<p>第0天用16进制编辑器编辑出一个image文件</p>
<h2 id="DAY-0x01"><a href="#DAY-0x01" class="headerlink" title="DAY 0x01"></a>DAY 0x01</h2><p>这张软盘共有1440KB大小，最高地址为0x168000-1</p>
<h4 id="文件描述"><a href="#文件描述" class="headerlink" title="文件描述"></a>文件描述</h4><ul>
<li>tolset\z_tools\qemu目录中的MakeFile启动qemu-win.bat，本质上是设置环境并带参数启动qemu.exe</li>
<li>tolset\z_tools\qemu\vgabios.bin : <em>BIOS (ia32) ROM Ext.</em> (19*512)</li>
<li>hellos0\helloos.img：<em>DOS/MBR boot sector</em>, code offset 0x4e+2, OEM-ID “HELLOIPL”, root entries 224, sectors 2880 (volumes &lt;=32 MB), sectors/FAT 9, sectors/track 18, sectors 2880 (volumes &gt; 32 MB), serial number 0xffffffff, label: “HELLO-OS   “, FAT (12 bit), followed by FAT</li>
</ul>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><ul>
<li>编译<code>.nas</code>文件用工具<code>nask</code>，<code>nask helloos.nas helloos.img</code></li>
<li><code>DB</code>(define byte)用来以十六进制定义数据，一次一个Byte，多个之间逗号分割<br>DB后还可以直接接字符串，字符串用<code>&quot;包围&quot;</code>起来，<strong>编译器不在字符串后面自动加\0</strong></li>
<li><code>RESB</code>(reserve byte)用来定义空的字节个数，后面接数字，等价于<code>DB</code>后面加一堆<code>0x00</code></li>
<li>数字字面量的表示形式和c语言里面一样0x开头为16进制</li>
<li><code>;</code>用于注释</li>
<li><code>DW</code>(define word),定义两个字节的数据</li>
<li><code>DD</code>(define double-word),定义4个字节的数据</li>
<li>数据部分支持先执行<code>加减乘除</code>运算再将结果写入</li>
<li><code>$</code>变量表示在<code>这个位置之前</code>已经写入的字节<strong>个数</strong></li>
</ul>
<h4 id="镜像文件格式"><a href="#镜像文件格式" class="headerlink" title="镜像文件格式"></a>镜像文件格式</h4><ul>
<li>该软盘扇区大小为512字节，启动区在第一个扇区内，<strong>计算机首先从最初的一个扇区内开始读盘</strong>，启动区的末尾必须为<code>0x55AA</code>（无特别意义，仅仅作为启动区的标记）</li>
<li>软盘的一次读写以一个扇区为单位</li>
<li>IPL是initial program loader的意思，启动程序加载器</li>
<li>操作系统和操作系统的加载程序在同一个地方的启动机制叫做bootstrap方式</li>
</ul>
<h2 id="DAY-0x02"><a href="#DAY-0x02" class="headerlink" title="DAY 0x02"></a>DAY 0x02</h2><h4 id="汇编-1"><a href="#汇编-1" class="headerlink" title="汇编"></a>汇编</h4><ul>
<li><code>ORG</code>指令指定程序装载到内存中的指定地址(这里一开始没看懂)</li>
<li><code>JMP</code>指令跳转到标签处</li>
<li>作者的nask汇编中指令遵循Intel汇编，第一个是目标操作数，第二个是源操作数</li>
</ul>
<table>
<thead>
<tr>
<th>寄存器名</th>
<th>全称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>AX</td>
<td>accumulator</td>
<td>累加寄存器</td>
</tr>
<tr>
<td>CX</td>
<td>counter</td>
<td>计数寄存器</td>
</tr>
<tr>
<td>DX</td>
<td>data</td>
<td>数据寄存器</td>
</tr>
<tr>
<td>BX</td>
<td>base</td>
<td>基址寄存器（例如用于指向数组起始位置）</td>
</tr>
<tr>
<td>SP</td>
<td>stack pointer</td>
<td>栈指针寄存器</td>
</tr>
<tr>
<td>BP</td>
<td>base pointer</td>
<td>基址指针寄存器（栈帧的基地址）</td>
</tr>
<tr>
<td>SI</td>
<td>source index</td>
<td>源变址寄存器</td>
</tr>
<tr>
<td>DI</td>
<td>destination index</td>
<td>目的变址寄存器</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>寄存器名</th>
<th>全称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ES</td>
<td>extra segment</td>
<td>附加段寄存器</td>
</tr>
<tr>
<td>CS</td>
<td>code segment</td>
<td>代码段寄存器</td>
</tr>
<tr>
<td>SS</td>
<td>stack segment</td>
<td>（栈指针寄存器的）段寄存器</td>
</tr>
<tr>
<td>DS</td>
<td>data segment</td>
<td>数据段寄存器</td>
</tr>
<tr>
<td>FS</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>GS</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<ul>
<li><code>AH/AL</code>,<code>AX</code>,<code>EAX</code>,<code>RAX</code>分别为8，16，32，64位寄存器</li>
<li>标签<code>label</code>等价于地址，每个标签的地址是按照ORG指令加上偏移量计算得出的</li>
<li><code>[]</code>表示多一层寻址</li>
<li><code>BYTE</code>、<code>WORD</code>、<code>DWORD</code>这些汇编保留字和<code>[地址]</code>的组合，表示以给出的地址为低地址的一块数据</li>
<li><code>CMP</code>比较指令</li>
<li><code>JE</code>结果相等时的条件跳转</li>
<li><code>INT</code>是软件中断指令，可以调用BIOS里预设的函数，后面接一个数字表示调用不同的函数。<br>调用前先将数据存到指定的寄存器</li>
<li><code>HLT</code>，(halt)让CPU停止动作，进入待机状态</li>
</ul>
<p>##未完待续</p>
<p>先睡觉了，天气冷，折腾一天了。</p>
<ul>
<li>Linux 汇编器：对比 GAS 和 NASM：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-gas-nasm.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-gas-nasm.html</a></li>
<li>各种编译器的区别 ASM: MASM, NASM, FASM?<br><a href="https://stackoverflow.com/questions/10179933/asm-masm-nasm-fasm/10180015" target="_blank" rel="noopener">https://stackoverflow.com/questions/10179933/asm-masm-nasm-fasm/10180015</a></li>
</ul>
<h2 id="DAY-0x02-续"><a href="#DAY-0x02-续" class="headerlink" title="DAY 0x02 续"></a>DAY 0x02 续</h2><p>上网搜了一下，发现原来的info地址已经变成了<a href="http://oswiki.osask.jp/" target="_blank" rel="noopener">http://oswiki.osask.jp/</a>但是依然不能用，最后在google快照里面找到了踪迹<code>http://webcache.googleusercontent.com/search?q=cache:</code>后面接网页url即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?(AT)memorymap</span><br></pre></td></tr></table></figure></p>
<p>helloos4中只取了helloos.nas的前半部分作为<code>ipl.nas</code></p>
<h4 id="汇编-2"><a href="#汇编-2" class="headerlink" title="汇编"></a>汇编</h4><ul>
<li>nask编译时第三个参数为编译输出的列表文件，描述每个指令如何翻译成机器语言</li>
<li><code>ORG</code>指令编译不产生字节</li>
</ul>
<h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><ul>
<li><code>#</code>注释，<code>\</code>续行符号</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">目标: 依赖文件</span></span><br><span class="line">	命令... \</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个目标是默认目标</li>
<li>目标可以是一个文件，也可以是一个标签，称为伪目标</li>
</ul>
<ul>
<li><code>eding</code>能编辑img文件，将其它img文件放到指定的位置</li>
<li><code>ipl.bin</code>就是<code>helloos.img</code>的前0x00200个字节</li>
</ul>
<p>启动时，首先执行BIOS，然后BIOS加载软盘的启动区，并在一些列操作之后跳转到启动区起始处的第一条<code>JMP</code>指令。<br><strong>启动区内容的装载地址为 0x00007c00-0x00007dff</strong>，这不是操作系统规定的，也不是img镜像文件中指定的，镜像文件得遵循这一规定，这一过程由BIOS进行<br>day1和day2的最终镜像文件没有区别，在helloos2中作者故意将程序区不以汇编代码形式展示，是因为其中要用到标签的地址，而这个地址要结合<code>ORG</code>指令计算得出，到helloos3时才加入<code>ORG</code>指令<br>参考FAT12启动区的定义，软盘的信息描述在0x62处截止，作者填充了18个字节的内容，然后在偏移量为0x50处写入代码</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>FAT12文件系统之引导扇区结构：\<br><a href="http://xitongbangshou.com/?p=41" target="_blank" rel="noopener">http://xitongbangshou.com/?p=41</a></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>自制玩具操作系统--week2</title>
    <url>/blog/53/</url>
    <content><![CDATA[<h2 id="DAY-0x03"><a href="#DAY-0x03" class="headerlink" title="DAY 0x03"></a>DAY 0x03</h2><h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><ul>
<li>命令块中<code>-del + 文件</code>表示让make中删除该文件</li>
</ul>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><ul>
<li><code>INT 0x13</code>中断表示操作磁盘<br>|参数|取值和含义|<br>|–|————–|<br>|AH|<code>0x00</code>复位磁盘,<code>0x02</code>读盘,<code>0x3</code>写盘,<code>0x4</code>校验,<code>0xc</code>寻道|<br>|AL|要处理的扇区数目(最少为1)|<br>|CH|表示柱面号&amp;0xff (从0开始)|<br>|DH|磁头号(从0开始)|<br>|CL|扇区号(0-5位)|(柱面号&amp;0300)&gt;&gt;2 (从1开始)|00000011 00000000<br>|DL|驱动器号(从0开始)|<br>|ES:BX|ES*16+BX缓冲区地址(ES左移4位,即十六进制后面追加一个0)|<br>读盘成功后CF置0,失败则置1</li>
</ul>
<p>例如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV		AX,0x0820</span><br><span class="line">MOV		ES,AX			; 缓冲区段地址</span><br><span class="line">MOV		CH,0			; 柱面号为0</span><br><span class="line">MOV		DH,0			; 磁头号0</span><br><span class="line">MOV		CL,2			; 扇区号2</span><br><span class="line"></span><br><span class="line">MOV		AH,0x02			; AH=0x02 : 从磁盘读入</span><br><span class="line">MOV		AL,1			; 1读取一个扇区</span><br><span class="line">MOV		BX,0			; 缓冲区地址</span><br><span class="line">MOV		DL,0x00			; 0号驱动器</span><br><span class="line">INT		0x13			; 磁盘BIOS调用</span><br><span class="line">JC		error</span><br></pre></td></tr></table></figure></p>
<p>该1.44Md的3.5寸软盘共有<strong>80个柱面(cylinder)(0-79),2个磁头(0-1),18个扇区(1-18)</strong><br>启动区位于C0-H0-S1,扇区序号按<code>扇区→磁头→柱面</code>的顺序进位</p>
<ul>
<li><code>JC</code>(Jump if Carry)(CF)条件跳转,产生进位时跳转</li>
<li><code>JNC</code></li>
<li><code>JAE</code>(Jump if above or equal)大于等于时跳转</li>
<li><code>JBE</code>(Jump if below or equal)大于等于时跳转</li>
<li><code>JB</code></li>
<li><code>EQU</code>是queal的缩写,<code>CYLS EQU 10</code>表示定义符号<code>CYLS</code>为数字10</li>
</ul>
<h4 id="内存区域-x86"><a href="#内存区域-x86" class="headerlink" title="内存区域(x86)"></a>内存区域(x86)</h4><p>低地址区域<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-------------------------------------------------------|0x00000000</span><br><span class="line">|	1 KiB 	RAM - partially unusable (see above) 		|</span><br><span class="line">|	Real Mode IVT (Interrupt Vector Table)			 	|0x000003FF</span><br><span class="line">|-------------------------------------------------------|0x00000400</span><br><span class="line">|	256 bytes 	RAM - partially unusable (see above)	|</span><br><span class="line">|	BDA (BIOS data area)								|0x000004FF</span><br><span class="line">|-------------------------------------------------------|0x00000500</span><br><span class="line">|	almost 30 KiB 	RAM (guaranteed free for use)		|</span><br><span class="line">|	Conventional memory									|0x00007BFF</span><br><span class="line">|-------------------------------------------------------|0x00007C00 ←</span><br><span class="line">|	512 bytes 	RAM - partially unusable (see above)	|</span><br><span class="line">|	Your OS BootSector									|0x00007DFF</span><br><span class="line">|-------------------------------------------------------|0x00007E00</span><br><span class="line">|	480.5 KiB 	RAM (guaranteed free for use)			|</span><br><span class="line">|	Conventional memory									|0x0007FFFF</span><br><span class="line">|-------------------------------------------------------|0x00080000</span><br><span class="line">|	128 KiB 	RAM - partially unusable (see above)	|</span><br><span class="line">|	EBDA (Extended BIOS Data Area)						|0x0009FFFF</span><br><span class="line">|-------------------------------------------------------|0x000A0000</span><br><span class="line">|	384 KiB 	various (unusable)						|</span><br><span class="line">|	Video memory, ROM Area								|0x000FFFFF</span><br><span class="line">|-------------------------------------------------------|</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>Memory Map (x86):\<br><a href="https://wiki.osdev.org/Memory_Map_(x86" target="_blank" rel="noopener">https://wiki.osdev.org/Memory_Map_(x86)</a>)</li>
</ul>
<p>关于作者开发的<code>edimg.exe</code>工具<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">edimg imgin:../z_tools/fdimg0at.tek \ <span class="comment">#读取映像文件</span></span><br><span class="line">		wbinimg src:ipl.bin len:512 from:0 to:0 \ <span class="comment">#将指定文件的内容写入映像的指定位置，一般用于写入引导扇区</span></span><br><span class="line">		copy from:haribote.sys to:@: \ <span class="comment">#将文件写入磁盘映像中或从中取出文件,@:表示盘符，类似于C:和D:等</span></span><br><span class="line">		imgout:haribote.img <span class="comment">#输出文件名</span></span><br></pre></td></tr></table></figure></p>
<p><code>ipl.nas</code>启动后从C0-H0-S2开始加载，加载到0x08200地址处，略过了启动区。<br><code>haribote.nas</code>开头设置<code>ORG 0xc200</code>，其中<code>0xc200=0x08200-0x00200+0x04200</code>,意味着这段程序将被加载到<code>0xc200</code>这个地址<br>作者书中说整个磁盘上的内容被加载到<code>0x08000</code>号地址，但实际上代码只加载了第二扇区开始的内容到<code>0x08000</code>，调试查看<code>0x08000-0x08200</code>并没有找到启动区的数据，发现该系统采用小端字节序，不知道和我用的是bochs还是qemu也没有关系</p>
<ul>
<li><code>0x04200</code>，查阅资料得知这是FAT12文件系统的文件数据区（第33扇区）,所以用<code>edimg</code>进行<code>copy</code>操作到磁盘中的第一个文件的地址偏移量就是<code>0x04200</code></li>
</ul>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li>edimg工具的使用:\<br><a href="http://webcache.googleusercontent.com/search?q=cache:hex7N0E90QkJ:hrb.osask.jp/wiki/%3Ftools/edimg+&amp;cd=2&amp;hl=zh-CN&amp;ct=clnk" target="_blank" rel="noopener">http://webcache.googleusercontent.com/search?q=cache:hex7N0E90QkJ:hrb.osask.jp/wiki/%3Ftools/edimg+&amp;cd=2&amp;hl=zh-CN&amp;ct=clnk</a></li>
<li>【文件系统】FAT12文件系统简介:\<br><a href="https://blog.csdn.net/xhyzjiji/article/details/49027013" target="_blank" rel="noopener">https://blog.csdn.net/xhyzjiji/article/details/49027013</a></li>
</ul>
<p>启动程序加载器完成磁盘数据的加载以后，跳转到第一个文件的位置开始执行，确认无误以后<code>make run</code>但是究竟程序有没有出错呢，屏幕一片黑啥也看不出，于是在切换显卡模式以后，往屏幕上输出一段信息确定启动没有问题。</p>
<p>然后是加了一堆预定义的地址，记录一堆数据，其中有一个图像缓冲区的初始地址<code>0xa0000</code>，于是尝试直接debug往这个地址以及后面的那块区域里面写东西，但是并没有像预想的那样在屏幕上出现图案。emmm先留着。</p>
<p>查看网页发现<code>0xa0000到0xaffff</code>是VRAM的空间，一个像素点是一个字节，分辨率是320*200，试试循环画点？</p>
<p>尝试了如下代码，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		MOV		DX,0xf0</span><br><span class="line">		MOV		CX,0</span><br><span class="line">		MOV		BX,0</span><br><span class="line">		MOV		AX,0xa000</span><br><span class="line">		MOV		ES,AX</span><br><span class="line">		JMP		write_VRAM</span><br><span class="line"></span><br><span class="line">write_VRAM:</span><br><span class="line">		MOV		BX,CX</span><br><span class="line">		ADD		CX,1</span><br><span class="line">		CMP		CX,320*200</span><br><span class="line">		MOV		[ES:BX],DX</span><br><span class="line">		JBE		write_VRAM</span><br></pre></td></tr></table></figure></p>
<p>结果整个屏幕果然呈现了棕绿色，吧DX改为0x0f，结果屏幕变成了全白色<br>最后选定了<code>0x08</code>，深灰色</p>
<p>证实了，确实能直接在显示内存区域直接写数据然后显示出来</p>
<p>接下来在<code>asmhead.nas</code>里加上一堆汇编代码，然后最终调用了<code>bootpack.c</code>的<code>HariMain()</code>，然后用汇编编写了一个输出模式为<code>WCOFF</code>的<code>naskfunc.nas</code>文件，其中编写了执行HLT指令的函数<code>io_hlt()</code>，然后编译成目标文件让<code>bootpack.c</code>链接,暴露的函数名称要声明为<code>GLOBAL</code>。<br>在</p>
<ul>
<li><code>bim</code>是作者设计的一种文件格式，意思是<code>binary image</code></li>
</ul>
<p>将目标文件用作者的工具链接起来以后就会得到bim文件</p>
<ul>
<li><code>hrb</code>是机器指令组成的文件<br>作者将c文件编译(cc1)，转为nas(gas2nask)，汇编编译(nask)得到目标文件，目标文件链接(obj2bim)得到bim文件，bim文件转换为hrb文件(bim2hrb)，然后asmhead.nas汇编(nask)出来的文件和这个hrb文件拼接起来就得到了最终的机器指令文件(haribote.sys)，由ipl加载并执行<br>（真麻烦）</li>
</ul>
<p>总之这样超长的第三天过去了，还剩下asmhead里面加的100行代码作者没有解释<br>不如先试着看看吧，能看多少是多少</p>
<h4 id="汇编-1"><a href="#汇编-1" class="headerlink" title="汇编"></a>汇编</h4><ul>
<li><code>OUT</code>指令和<code>IN</code>指令是对外设的操作的读写指令(访问系统的io空间)<br>  <code>OUT 0x21,AL</code>表示将AL寄存器的值写入0x21端口</li>
<li><code>CLI</code>指令禁止中断发生，<code>STL</code>指令允许中断发生</li>
<li><code>CALL</code>命令在跳转前将下一条指令的地址（段和偏移）压入栈中，执行<code>RET</code>时则从栈中取出地址回到<code>CALL</code>的下一跳地址处执行</li>
</ul>
<h2 id="DAY-0x04"><a href="#DAY-0x04" class="headerlink" title="DAY 0x04"></a>DAY 0x04</h2><p>因为自带的cc1不支持最高只支持c99，用着很不爽，改成了电脑上装的gcc输出汇编指令，发现也能运行，只是gas2nask的时候程序状态值为1，但是不影响运行，修改makefile在该条指令前加上<code>-</code>就能避免整个make进程的中断</p>
<h4 id="汇编-2"><a href="#汇编-2" class="headerlink" title="汇编"></a>汇编</h4><ul>
<li>编写C语言函数的的汇编函数体时，寄存器要慎用，自由读写的只有<code>EAX,ECX,EDX</code><br>这三个，其他的只能使用其值而不能改变</li>
<li><code>[INSTRSET &quot;i486p&quot;]</code>指令(instr set,判断指令集)标识这个汇编程序是提供给486使用的（EAX等寄存器名不能16位的8086中使用，自386开始的cpu都是32位的）</li>
</ul>
<h4 id="Makefile-1"><a href="#Makefile-1" class="headerlink" title="Makefile"></a>Makefile</h4><ul>
<li>命令前加上<code>-</code>表示即使这条命令即使出错也继续执行</li>
</ul>
<p>作者第四天一开始在c程序里面进行了绘制操作，但是我在第三天的时候已经用汇编指令对图像内存缓存地址区域进行了写值，因此，这里验证了<code>write_mem8</code>以后注释这一段了<br>在第三天的时候我也用汇编的形式在<code>asmhead.nas</code>里做了作者第四天做的第二件事情，写入条纹图案，只不过我写入的条纹时写入的是<code>i</code>而不是<code>i&amp;0x0f</code>，不过也看到了一些奇怪的条纹</p>
<p>之后作者长篇叙述了指针的概念及其实现,这些已经懂了的知识就草草看完进入第四天的第6小节了</p>
<h4 id="VGA8位色号"><a href="#VGA8位色号" class="headerlink" title="VGA8位色号"></a>VGA8位色号</h4><p>作者定义的调色板:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:#000000:黑	 6:#00ffff:浅亮蓝	12:#000084:暗蓝</span><br><span class="line">1:#ff0000:亮红	 7:#ffffff:白		13:#840084:暗紫</span><br><span class="line">2:#00ff00:亮绿	 8:#c6c6c6:亮灰		14:#008484:浅暗蓝</span><br><span class="line">3:#ffff00:亮黄	 9:#840000:暗红		15:#848484:暗灰</span><br><span class="line">4:#0000ff:亮藍	10:#008400:暗绿</span><br><span class="line">5:#ff00ff:亮紫	11:#848400:暗黄</span><br></pre></td></tr></table></figure></p>
<h4 id="VGA-EGA调色板技术"><a href="#VGA-EGA调色板技术" class="headerlink" title="VGA/EGA调色板技术"></a>VGA/EGA调色板技术</h4><p>调色板是当初为了节约宝贵的内存空间而设计的一种解决方案，屏幕上最多可以显示16种颜色，在EGA的16个颜色寄存器存储颜色的。每个颜色存储器有<code>3*6=18</code>位，其中R、G、B各用6位表示，即R、G、B各有64种取值，从0到63代表颜色的程度，所以一种颜色用18位表示。这样机器能够显示的颜色总共有<code>64*64*64=256k</code>种，但是同一时刻在屏幕上显示的颜色只有16种，图像缓存区域中每个像素点只需用一个字节（实际上是0-15的值）来表示这16种颜色的索引号。</p>
<ul>
<li>c语言中,函数内定义的static类型的数据会被存放到栈外的一块单独的内存区域,如果指定了初始值,相当于<code>DB 初始数据</code></li>
</ul>
<p><code>EFLAGS</code>寄存器(32位，由FLAGS扩展而来)，<code>FLAGS</code>的各个位含义<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------------------------</span><br><span class="line">|15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|</span><br><span class="line">|  |NT| IOPL|OF|DF|IF|TF|SF|ZF|  |AF|  |PF|  |CF|</span><br><span class="line">-------------------------------------------------</span><br></pre></td></tr></table></figure></p>
<p>中断标志位在第9位</p>
<h4 id="汇编-3"><a href="#汇编-3" class="headerlink" title="汇编"></a>汇编</h4><ul>
<li><code>PUSHFD</code>(push flags double-word)，将32位的EFLAGS压栈，对应的还有<code>POPFD</code><br>  因为<code>EFLAGS</code>和其他寄存器，比如<code>EAX</code>之间没有直接的汇编指令相互传送，因而需要用栈作为中介</li>
<li>根据C语言的规约，执行<code>RET</code>语句时，EAX寄存器中的值被看作是函数的返回值</li>
</ul>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ul>
<li>视频图形阵列-视频DA转换器<br><a href="http://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?VGA" target="_blank" rel="noopener">http://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?VGA</a></li>
</ul>
<h2 id="DAY-0x05"><a href="#DAY-0x05" class="headerlink" title="DAY 0x05"></a>DAY 0x05</h2><p>由hankaku.txt生成的obj文件中，<code>.data</code>段存的是连续的字符数据，该obj文件导出了一个符号<code>_hankaku</code><br>要使用该外部obj导出的符号，只要在c文件里用<code>extern char hankaku[4096]</code>即可 </p>
<p>第五天的实验开始出现了问题，因为之前由于忍受不了只允许使用c99标准，我改成了用gcc -S 输出代码，但是现在似乎问题更大了，gcc输出的汇编中包含一个叫<code>.section .rdata</code>的段，这个段不能被<code>gas2nask</code>识别，而函数调用参数中的字符串字面量就在这个段里存着<br>比如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">putfonts8_asc(vram, xsize, ysize, 0, 0, COL8_FFFFFF, &quot;test it!&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这条里面的<code>&quot;test it!&quot;</code>就在这个段里，被gas2nask忽略掉了以后，导致生成的nas文件里头缺失了这部分内容，nask编译出错。<br>上网意外找到了作者的github，clone下来编译不过关，缺少个文件，遂放弃。<br>有意外找到OSASK项目的项目中文首页，从中下载了2010年的版本，没想到这个作者依然没有注意到这个bug，我绝望了，删光了下载的东西，决心不用nask了，另外想办法整一下</p>
<p>回忆编译流程，发现bootpack.c最终是为了生成.obj目标文件，而这个作者偏偏要先生成.gas，再生成.nas，再用他那个nask编译成.obj，其实这其中的步骤完全就可以省略嘛，我之前就用了gcc，现在，直接可以<code>gcc -c</code>生成目标文件，于是乎改写Makefile，直接通过编译！（坑爹的作者）</p>
<p>既然改了这么多，代码也越来越乱，干脆一改到底，就用c++，反正c++也是兼容c的问题不大。</p>
<p>但是用c++编译，链接时出现问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning : can&apos;t link _HariMain</span><br></pre></td></tr></table></figure></p>
<p>原因是c++编译的名字修饰规则和c的不匹配，入口函数被编译成了<code>__Z8HariMainv</code>，这下我大概明白它的原理了，我们在写的<code>bootpack.cpp</code>是要被作为类库一样被链接的，而另外一边是已经写好了的，所以只能让我们这边做妥协，到解决办法是定义处套上<code>extern &quot;C&quot;</code>就好了</p>
<p>在引入了c++的基础上，我新建了几个文件，还增加了Cursor类和Mouse类，Cursor对象相当于一个隐形的光标，封装的函数，可以方便地进行定位，比如，下一格，换行等操作，这样代码也更加清晰。</p>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><ul>
<li>32位模式，<code>DS:EBX</code>不再表示DS*16+EBX，而是<code>EBX+(DS所表示的段的起始地址)</code>，而且缺省时也默认使用DS这个段寄存器。</li>
</ul>
<h5 id="段的有关信息（CPU用8个字节，即64位的数据来表示这些信息）"><a href="#段的有关信息（CPU用8个字节，即64位的数据来表示这些信息）" class="headerlink" title="段的有关信息（CPU用8个字节，即64位的数据来表示这些信息）"></a>段的有关信息（CPU用8个字节，即64位的数据来表示这些信息）</h5><ul>
<li>段的大小(存储时存储段的大小-1后的值，以节省空间，limit)</li>
<li>段的起始地址(base)</li>
<li>段的管理属性（禁止写入，禁止执行，系统专用等，ar）</li>
</ul>
<ul>
<li>段寄存器只有16位，即使是在32位模式下也是如此</li>
<li>段寄存器的底三位由于设计原因不能使用，因此只剩下13位，只能表示8192个段</li>
</ul>
<h5 id="GDT-全局段号记录表-global-segment-descriptor-table"><a href="#GDT-全局段号记录表-global-segment-descriptor-table" class="headerlink" title="GDT 全局段号记录表(global segment descriptor table)"></a>GDT 全局段号记录表(global segment descriptor table)</h5><ul>
<li>和调色板一样的思想，8192个段</li>
<li>GDT存在于内存中，用来存储段的有关信息，表中每一项需要8个字节（8192*8个字节=64KB）</li>
<li><code>GDTR</code>寄存器存储了这个表的起始位置和这个表的长度（字节数-1）</li>
</ul>
<h5 id="IDT-中断记录表-interrupt-descriptor-table"><a href="#IDT-中断记录表-interrupt-descriptor-table" class="headerlink" title="IDT 中断记录表(interrupt descriptor table)"></a>IDT 中断记录表(interrupt descriptor table)</h5><ul>
<li>IDT记录了0-255的中断号吗和调用函数的对应关系，表中的每一项也是8个字节</li>
</ul>
<p>数据的组织形式应该是和机器是小端模式有关系，因为GDT的数据结构中base字段的低24位被储存到16位的base_low和base_mid的低八位中了，但是base剩下的最高8位为什么被存储到与前面两个字段不相邻的base_high字段我就不清楚了。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>自制玩具操作系统--week3</title>
    <url>/blog/54/</url>
    <content><![CDATA[<h2 id="DAY-0x06"><a href="#DAY-0x06" class="headerlink" title="DAY 0x06"></a>DAY 0x06</h2><h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><ul>
<li>make中可以使用一般规则（通配规则,依赖中:<code>%.cpp</code>,执行语句中:<code>$*.cpp</code>），但是普通规则比一般规则的优先级更高</li>
</ul>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><ul>
<li>GDTR寄存器有48位</li>
<li><code>PUSHAD</code>将通用寄存器(EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI)按顺序双字压栈，对应的恢复指令为<code>POPAD</code>，该指令的单字版本为<code>POPA</code></li>
<li>普通C程序返回时需要调用<code>RET</code>，但是中断返回时需要调用<code>IRETD</code></li>
<li>C语言认为DS和ES和SS所指向的段都是一样的，因此在中断调用c程序前必须备份ES和DS的值并拷贝SS的值给DS、ES</li>
</ul>
<h4 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h4><p>可以在汇编中混入<code>INT 3</code>指令来断点调试,但是在中断向量表未准备好时,不能使用该方式<br>但是在使用bochsdbg时,可以在汇编中参入<code>MAGIC BREAKPOINT</code>,具体步骤是在bochs配置文件中加入<code>magic_break: enabled=1</code>,然后在汇编中加入<code>xchg bx,bx</code>,然后就能在该处断点</p>
<h4 id="load-gdtr"><a href="#load-gdtr" class="headerlink" title="load_gdtr"></a>load_gdtr</h4><p><code>_load_gdtr</code>函数先取出第1个参数<code>limit</code>，地址为<code>ESP+4</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV		AX,[ESP+4]		; limit</span><br></pre></td></tr></table></figure>
<p>这是一个2字节指令,而因为之前分析过这个机器是小端模式,因此对于<code>0x0000ffff</code>,<code>WORD [ESP+4]</code>就是<code>0xffff</code>,把它放到了AX寄存器,然后<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV		[ESP+6],AX</span><br></pre></td></tr></table></figure></p>
<p>将<code>0xffff</code>放到了更高的两个byte上面,而<code>ESP+8</code>则是第二个参数<code>addr</code>的地址,这样一来,<code>limit</code>的低2字节和<code>addr</code>就连起来了,之后<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LGDT	[ESP+6]</span><br></pre></td></tr></table></figure></p>
<p>直接取了<code>ESP+6</code>为低位的6个byte的数据,放到<code>GDTR</code>寄存器,<br>这就是书上说的<code>GDTR</code>的6个字节的来源,<strong>低2个字节是limit,高4字节是addr</strong></p>
<h4 id="GDT的访问权属性"><a href="#GDT的访问权属性" class="headerlink" title="GDT的访问权属性"></a>GDT的访问权属性</h4><p>段号记录表中的项中的段属性中有一个<code>Gbit</code>位，<br>当该位为1时，记录的<code>limit</code>的单位不是byte而是页的大小，<strong>一页是指4KB</strong></p>
<p>段的访问权属性<code>ar(access_right)</code>,由8位+4位扩展组成，高4位扩展为<code>GD00</code>,其含义为：</p>
<ul>
<li>G:Gbit，段长度单位是byte还是页数</li>
<li>D:32位模式(1),16位程序模式(不可用于调用BIOS)(0)</li>
</ul>
<p>低八位的部分组合的含义<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000（0x00）：未使用的记录表（descriptor table）。</span><br><span class="line">10010010（0x92）：系统专用，可读写的段。不可执行。</span><br><span class="line">10011010（0x9a）：系统专用，可执行的段。可读不可写。</span><br><span class="line">11110010（0xf2）：应用程序用，可读写的段。不可执行。</span><br><span class="line">11111010（0xfa）：应用程序用，可执行的段。可读不可写。</span><br></pre></td></tr></table></figure></p>
<p>x86的处理器通过ring0到ring4四个级别来进行访问控制<br><em>系统模式(ring0)和应用模式(ring3)取决于运行中的程序代码所在的段的访问权限属性低8位是0x9a还是0xfa</em></p>
<h4 id="PIC-Programmable-interrupt-controller-可编程中断控制器"><a href="#PIC-Programmable-interrupt-controller-可编程中断控制器" class="headerlink" title="PIC(Programmable interrupt controller)可编程中断控制器"></a>PIC(Programmable interrupt controller)可编程中断控制器</h4><p><strong>用于将8个中断信号集合成一个中断信号</strong><br>每个PIC上面可以接收8个中断信号，主板上一共有两个PIC，一共有15个可用的中断信号，IRQ2被用于连接从PIC</p>
<blockquote>
<p>中断号码表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IRQ0 	计时器</span><br><span class="line">IRQ1 	键盘</span><br><span class="line">IRQ2 	用于与从站级联</span><br><span class="line">IRQ3 	串口（COM2）</span><br><span class="line">IRQ4 	串口（COM1）</span><br><span class="line">IRQ5 	主要用于ISA / PCI扩展设备</span><br><span class="line">IRQ6 	FDC</span><br><span class="line">IRQ7 	并行端口</span><br><span class="line">IRQ8 	RTC</span><br><span class="line">IRQ9 	主要用于ISA / PCI扩展设备</span><br><span class="line">IRQ10 	主要用于ISA / PCI扩展设备</span><br><span class="line">IRQ12 	鼠标</span><br><span class="line">IRQ13 	FPU（？）</span><br><span class="line">IRQ14 	ATA-0</span><br><span class="line">IRQ15 	ATA-1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>PIC内部有多个寄存器:</p>
<ul>
<li>IMR(interrupt mask register 中断屏蔽寄存器)，PIC的IMR寄存器每一位表示是否允许中断请求(1表示禁止)</li>
<li>ICW(initial control word 初始化控制数据)共有四个，ICW1-ICW4，与PIC主板配线方式、中断信号的电气特性也有关系<br>  ICW3的值用于设定主从PIC。对于主PIC,第几号的IRQ与从PIC相连，就将那位置为1;而对于从PIC,接在主PIC的第几号(0 based)位置上,这个寄存器的值就设置为多少。<br>  ICW2的值用于设定中断号</li>
<li>OCW(操作命令字)</li>
</ul>
<blockquote>
<p>CPU有一根中断型号，由IF中断许可标志位标志标识是否接受外部中断（1表示接受，STL指令置1，CTL指令置0），而PIC可以对它导出的一共8个RIQ端口分别控制是否接受中断</p>
</blockquote>
<h2 id="DAY-0x07"><a href="#DAY-0x07" class="headerlink" title="DAY 0x07"></a>DAY 0x07</h2><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><ul>
<li>中断触发后，需要通知PIC已经处理完中断，这样PIC才会继续接受中断。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">io_out8(PIC0_OCW2, <span class="number">0x61</span>);<span class="comment">// 0x61=0x60+0x01，表示已经处理IRQ1上的中断</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>键盘触发的中断会在键盘按下和松开的时候都触发一次</p>
<ul>
<li>似乎<code>io_stihlt()</code>由于CPU规范的原因能保持原子性<br>根据CPU的规范，机器语言的STI指令之后，如果紧跟着HLT指令，那么就暂不受理这两条指令之间的中断，而要等到HLT指令之后才受理</li>
<li>无缓冲的消息机制的键盘按键中断处理在中断密集时，会出现后续的中断来不及被处理（来不及关闭中断开关）的问题，解决办法是使用缓冲区<br>但是我实际操作调试中断时并没有看到传说中的被吞掉的E0数，只看到按下时的<code>0x1D</code>和松开时的<code>0x9D</code></li>
<li>KBC(keyboard controller)键盘控制器，控制键盘和鼠标</li>
</ul>
</blockquote>
<h4 id="关于C"><a href="#关于C" class="headerlink" title="关于C++"></a>关于C++</h4><ul>
<li>为了方便显示，我在Cursor类里面加了个单例模式的static函数，但是C++实现函数内的static变量（局部静态变量）时，为了确保在多线程状态下只初始化一次，在编译时增加了同步锁，但是由于同步锁的实现函数在libstdc++内，而我们是没有链接这个库的，因此使用编译时的<code>-fno-threadsafe-statics</code>选项，禁用该功能。<blockquote>
<p>C++静态局部变量对于基本类型的常量初始化时，采取直接定义一个隐藏的全局变量的方法，例如对于函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ofEndLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>其汇编为<br><img src="/images/blog/os/1.png" alt="用常量初始化静态局部变量"><br>而对于需要调用函数来进行初始化的静态局部变量，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ofEndLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = getValue();</span><br><span class="line">	i++;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则是<br><img src="/images/blog/os/0.png" alt="用函数初始化静态局部变量"><br>这其中就用到了<code>___cxa_guard_acquire</code>和<code>___cxa_guard_release</code>。</p>
<h2 id="DAY-0x08"><a href="#DAY-0x08" class="headerlink" title="DAY 0x08"></a>DAY 0x08</h2><ul>
<li>鼠标的数据除第一次发送的是0xfa(表示启动鼠标后的ACK)以外，其它数据按照3个字节一组发送。<blockquote>
<p>每组中,第一个字节的高4位是对移动有反应的部分(在[0,3]的范围内),低4位是对点击有反应的部分(在[8,f]的范围内)<br>|    |7|6|5        |4        |3|2    |1            |0        |<br>|—|-|-|——-|——-|-|—–|———–|——-|<br>|0    |0|0|上移    |右移    |1|        |            |         |<br>|1    |0|0|下移    |左移    |1|右键    |中键(按下)    |左键    |<br>第二个字节和左右移动有关<br>第三个字节和上下移动有关<br>鼠标与屏幕的y方向正好相反,因此y使用前应该加负号</p>
</blockquote>
</li>
<li>状态和控制寄存器<br>  <code>EFLAGS</code>、<code>EIP</code>、<code>CR0</code>、<code>CR1</code>、<code>CR2</code>、<code>CR3</code><br>  |寄存器    |作用|<br>  |—–    |—|<br>  |EFLAGS    |状态寄存器组|<br>  |EIP    |存储下一条指令的地址|<br>  |CR0|启用保护模式PE（分段机制）（Protection Enable）标志、分页PG（Paging）标志、等|<br>  |CR1|未定义|<br>  |CR2|页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址|<br>  |CR3|页目录基地址寄存器PDBR（Page-Directory Base address Register），保存页目录表的物理地址，页目录表总是放在以4K字节为单位的存储器边界上|</li>
<li>保护模式状态切换之后，需要立即使用JMP指令刷新处理器执行管道</li>
<li>在保护模式下，采用段表的方式，段寄存器中存放段表中目标项的偏移量（单位为Byte）<br>  例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV		AX,1*8			; 段寄存器DS为1*8，表示段表中的从0开始数起的第1个项</span><br><span class="line">MOV		DS,AX</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="asmhead-nas-之后所做的事情"><a href="#asmhead-nas-之后所做的事情" class="headerlink" title="asmhead.nas 之后所做的事情"></a>asmhead.nas 之后所做的事情</h4><ul>
<li>PIC关闭一切中断</li>
<li>设定A20GATE，使CPU能够访问1MB以上的存储器</li>
<li>指定临时段表</li>
<li>切换到保护模式PE，开启分页PG</li>
<li>刷新流水线</li>
<li>初始化除CS外的段寄存器</li>
<li>拷贝<code>bootpack.hrm</code>到<code>0x00280000</code> <code>(512KB)</code></li>
<li>拷贝<code>ipl</code>启动扇区到<code>0x00100000</code> <code>(512B)</code></li>
<li>拷贝磁盘上之前加载到内存区的除了启动区的部分到<code>0x00100200</code></li>
<li>(可能进行)拷贝<code>bootpack.hrm</code>的某块区域到<code>bootpack.hrm</code>指定的栈地址中</li>
<li>初始化栈地址为<code>bootpack.hrm</code>指定的栈地址</li>
<li>设置<code>CS</code>寄存器的值的同时<code>JMP</code>到<code>HariMain</code>函数执行</li>
</ul>
<h4 id="汇编-1"><a href="#汇编-1" class="headerlink" title="汇编"></a>汇编</h4><ul>
<li><code>IMUL</code>，有符号整数乘法</li>
<li><code>SHL</code>，逻辑左移，<code>SHR</code>，逻辑右移</li>
<li><code>ALIGNB</code>表示填充0直到地址能被操作数整除</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul>
<li>PIC 8259A<br><a href="https://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?(PIC" target="_blank" rel="noopener">http://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?(PIC)8259A</a>8259A)</li>
<li>兼容PS/2键盘控制器<br><a href="https://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?(AT" target="_blank" rel="noopener">http://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?(AT)keyboard</a>keyboard)</li>
<li>局部静态变量是如何做到只初始化一次的?<br><a href="www.voidcn.com/article/p-wdezklav-bms.html">www.voidcn.com/article/p-wdezklav-bms.html</a></li>
<li>x86的控制寄存器CR0,CR1,CR2,CR3<br><a href="https://www.cnblogs.com/liubiyonge/p/9350494.html" target="_blank" rel="noopener">https://www.cnblogs.com/liubiyonge/p/9350494.html</a></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>自制玩具操作系统--week4</title>
    <url>/blog/55/</url>
    <content><![CDATA[<h2 id="DAY-0x09"><a href="#DAY-0x09" class="headerlink" title="DAY 0x09"></a>DAY 0x09</h2><h4 id="内存检查"><a href="#内存检查" class="headerlink" title="内存检查"></a>内存检查</h4><ul>
<li>内存检查前需要先禁用缓存，通过修改CR0寄存器实现这一点</li>
<li>内存检查是通过对内存单元进行<code>写、反转、判断、反转、判断</code>，来确定一个内存单元的可用性的</li>
</ul>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ul>
<li>内存的使用情况的表示方法多样，可以用一个bit标记一页的状态，也可以用内存区域的起始地址和长度来表示一个空的区域。</li>
<li>memman_free时，由于按地址有序，于是改用二分查找的方式寻找插入位置，以提高效率</li>
</ul>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>为了方便调试，手撸了一个<code>log.cpp</code>，输出时只需构建字符串然后调用<code>log::info()</code>，能够在屏幕上滚动输出，就像终端一样，还支持不同日志等级，不同颜色显示<br><img src="/images/blog/os/2.png" alt="日志"></p>
<h2 id="DAY-0x0A"><a href="#DAY-0x0A" class="headerlink" title="DAY 0x0A"></a>DAY 0x0A</h2><p>这一天的几乎全是软件层面的事情了。<br>    实验中跟随作者实现了图层，但是我把SHEET重新命名为了Canvas，并且将结构体改成了类，把那些操作函数改成了成员函数，因为我实在是受不了作者的代码结构了，把一堆函数分散开而且每一次调用都要在参数里加上ctl这种做法实在是啰嗦，而且一改动的话几乎全部都要改，按照类来设计的话，可以把代码很好的组织起来，这种逻辑最适合设计成面向对象的程序。</p>
<p>​    而最让我头疼的是屏幕刷新的问题，因为作者只用了两个图层，而我还加了一个滚动的日志层，一共三个层，这样导致每次鼠标来一下中断都要滚动输出一下，屏幕闪烁得不行，不知道后面到定时器的时候有没有其它的办法<br><img src="/images/blog/os/3.gif" alt="卡顿的屏幕"></p>
<p>​    在将直接写入改成写入到图层的过程中，经常遇到一些问题，但是在机器码层面不方便调试，因此，将之前我找到的<code>bochsdbg</code>支持的断点魔法<code>xchg    bx,bx</code>，封装成<code>void bochsdbg()</code>函数加到naskfunc里头，然后在不同的地方调用该函数，这样就能找出代码是在那个地方跑飞的了。</p>
<p>​    作者对屏幕的刷新策略是，从底部到顶部逐层刷新，我尝试过另外一种方法，外层循环是整个屏幕的所有位置，对于每一个位置，按高度从顶部向下遍历，直至找到非透明像素，但是这种方法效率不高，可能是因为有些时候虽然图层很多但是顶部的图层面积较小，导致要么不再图层边界内，要么遇到透明像素的情况。</p>
<h2 id="DAY-0x0B"><a href="#DAY-0x0B" class="headerlink" title="DAY 0x0B"></a>DAY 0x0B</h2><p>​    由于自己写的东西魔改的太多，作者是在每次界面改动之后就立刻调用<code>fresh_map</code>和<code>fresh_sub</code>刷新，但是这样会导致一轮循环中重复刷新某一区域（过度绘制）的问题，在大面积更新时势必遇到卡顿。而我由于多了一层log图层，该图层背景透明且每次输出都会整个刷新，因此我考虑采用另外的方式，为了解决这一问题，我决定在主while循环中进行真正的刷新操作，其他时候调用<code>notifyRefresh()</code>进行标志位的设置。<br>​    另外，将刷新map的操作也进行优化，窗口位置移动时，如果对新旧窗口分别刷新，实际上在移动区域不大的情况下，是有一部分区域重叠了的，对于这一情况，将图像分割成多个不重叠的区域，分别进行刷新，可以节省大量刷新操作。<br>​    作者的函数需要传入图层高度，作者提到，它不能适应把窗口变成透明或者把不透明变成透明的情况，为了避免这种状况，我每次map刷新都从最底部的图层开始，这在一定程度上影响了效率。<br>​    为了避免多处代码对同一区域进行刷新map的操作，我借鉴了网上一道求解<code>n个矩形重叠覆盖的面积</code>的算法题的思想，先将所有待刷新的区域矩形记录下来，先不刷新map，而在刷新屏幕之前，对这些区域进行划分，分块进行map的刷新操作，</p>
<p>左边作者的，右边我的，可以看到，我的速度慢了十倍多，但是并不卡顿<br><img src="/images/blog/os/4.gif" alt=""></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul>
<li>UVA 11345 Rectangles(n个矩形重叠覆盖的面积)<br><a href="https://blog.csdn.net/u013480600/article/details/39481243" target="_blank" rel="noopener">https://blog.csdn.net/u013480600/article/details/39481243</a></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>自制玩具操作系统--week6</title>
    <url>/blog/57/</url>
    <content><![CDATA[<h2 id="DAY-0x0F"><a href="#DAY-0x0F" class="headerlink" title="DAY 0x0F"></a>DAY 0x0F</h2><h4 id="两种JMP指令"><a href="#两种JMP指令" class="headerlink" title="两种JMP指令"></a>两种JMP指令</h4><p><code>near jmp</code>只修改IP寄存器的值，而<code>far jmp</code>同时修改<code>IP</code>寄存器和<code>CS</code>寄存器的值(用<code>:</code>隔开)<br>用于任务切换的JMP命令就属于far-JMP命令，用于任务切换的JMP命令在切换回这个任务后，会从这条JMP命令后继续执行。</p>
<h4 id="GDT中的TSS段"><a href="#GDT中的TSS段" class="headerlink" title="GDT中的TSS段"></a>GDT中的TSS段</h4><p>TSS(task status segment)，全称任务状态段<br>CPU在执行带有段地址的指令时，会去确认GDT中对应项的配置，可用此判断是JMP指令还是far-JMP，</p>
<h4 id="TR-task-register-寄存器"><a href="#TR-task-register-寄存器" class="headerlink" title="TR(task register)寄存器"></a>TR(task register)寄存器</h4><p><code>TR</code>寄存器记录当前正在运行的是哪一个任务，任务切换时，寄存器的值会自动变化，每次给<code>TR</code>寄存器赋值的时候，需要将其在GDT中的序号乘以8。</p>
<p>两个任务交替进行输出：<br><img src="/images/blog/os/6.png" alt="两个任务交替进行输出"></p>
<h2 id="DAY-0x10"><a href="#DAY-0x10" class="headerlink" title="DAY 0x10"></a>DAY 0x10</h2><p>作者原先只定义了两个任务，并且只是在超时之后将其强行进行切换，但是实际中的场景比这样的复杂得多，因而封装了切换任务的的逻辑，并且在这样的基础上实现任务增减、任务优先级设置，因此我这里模仿CanvasCtl的结构去实现task的管理</p>
<h4 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h4><p>多任务建立起来以后，窗口（window）的数量也相应增加，为此实现了窗口和任务的绑定关系、窗口焦点的变化。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>原先的task切换时，采用的是公平竞争的方式，每个任务被执行的几率相等，但是在实际的操作系统中，往往需要让某些进程拥有更高的优先级。要实现这样的功能，只要在task中加入priority字段，然后在切换任务时考虑这个字段即可。<br><img src="/images/blog/os/7.png" alt="task不同的优先级"></p>
<h2 id="DAY-0x11"><a href="#DAY-0x11" class="headerlink" title="DAY 0x11"></a>DAY 0x11</h2><h4 id="命令行窗口"><a href="#命令行窗口" class="headerlink" title="命令行窗口"></a>命令行窗口</h4><p>这一天的内容基本上是对现有知识的应用，读取键盘输入、keytable的转换、按键的不同情况的响应等。<br>由于我之前写了log输出模块，可以像命令行那样一行一行显示日志文本，所以这个命令行窗口其实和我之前的那个日志模块有些类似，因此我直接将原先的代码进行修改，结合作者的实现，加入读取键盘输入的逻辑。<br>对各种按键锁的支持其实就是获取锁的状态，并进行记录，然后在触发按键响应过程中判断锁的状态，以此进行过滤。<br><img src="/images/blog/os/8.png" alt=""><br>但是一些组合键的响应支持还不够完善，期待下一天的相关内容。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>自制玩具操作系统--week7</title>
    <url>/blog/58/</url>
    <content><![CDATA[<h2 id="DAY-0x12"><a href="#DAY-0x12" class="headerlink" title="DAY 0x12"></a>DAY 0x12</h2><h4 id="让新进程执行对象的成员函数"><a href="#让新进程执行对象的成员函数" class="headerlink" title="让新进程执行对象的成员函数"></a>让新进程执行对象的成员函数</h4><p>今天回看之前的内容，发现命令行窗口那一块比较乱，于是乎建了一个<code>Console</code>类，把和控制台有关的比如图层、<code>Fifo</code>队列等打包起来，然后把进程的执行函数<code>console_task</code>改成无参的成员函数，但是要知道它其实是隐式传入了一个<code>this</code>指针，所以在设置<code>eip</code>的时候可不是仅仅传入成员函数指针那么容易。</p>
<p>c++的编译器在调用函数时传入this指针时的方法称为<code>__thiscall</code>调用约定，有两种实现，一种是通过<code>ecx</code>寄存器传参，另一种是压栈为第一个参数传参。<br>要确定当前编译器使用的是哪种<code>__thiscall</code>调用约定，直接拿个例子编译一下看看就好了。</p>
<p>先拿了一个直接用对象去调用成员函数的例子来观察，<br><img src="/images/blog/os/9.png" alt="9.png"><br>可以看到，普通成员函数其实只是一个一般的函数，但是在调用前将这个对象的指针赋值给了<code>ecx</code>寄存器，这个<code>ecx</code>就是this指针啦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">task_cons-&gt;tss.esp = memman_alloc_4k(memman, <span class="number">64</span> * <span class="number">1024</span>) + <span class="number">64</span> * <span class="number">1024</span> - <span class="number">4</span>; <span class="comment">// 没有用栈传递的参数，这里只要预留压栈ebx所需的空间即可</span></span><br><span class="line">task_cons-&gt;tss.ecx = (<span class="keyword">int</span>)<span class="keyword">this</span>; <span class="comment">// this指针通过ecx传递</span></span><br><span class="line">task_cons-&gt;tss.eip = (<span class="keyword">int</span>) (<span class="keyword">void</span>*)&amp;console_task; <span class="comment">// 指定成员函数</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 可以通过this指针访问成员变量，这里不用费心思从栈上传一堆参数了</span></span><br><span class="line"><span class="comment">// *((int *) (task_cons-&gt;tss.esp + 4)) = (int)canvas_cons;</span></span><br></pre></td></tr></table></figure>
<h4 id="支持美式键盘"><a href="#支持美式键盘" class="headerlink" title="支持美式键盘"></a>支持美式键盘</h4><p>之前做的时候没有注意到作者的键盘映射居然不是美式的，怪不得有些按键效果不太对<br>从网上找到一份类似的键盘映射表换一下就好了</p>
<p><a href="https://github.com/gdevic/linice/blob/829862cb11e4f062d561c854536fa338985672bb/linsym/Keymaps.c" target="_blank" rel="noopener">https://github.com/gdevic/linice/blob/829862cb11e4f062d561c854536fa338985672bb/linsym/Keymaps.c</a></p>
<h2 id="DAY-0x13"><a href="#DAY-0x13" class="headerlink" title="DAY 0x13"></a>DAY 0x13</h2><h4 id="改用c-编译器后患无穷"><a href="#改用c-编译器后患无穷" class="headerlink" title="改用c++编译器后患无穷"></a>改用c++编译器后患无穷</h4><p>之前提到我现在的代码用的是c++来编写，编译器用的mingw64里的c++，在做<code>type</code>命令时，遇到了一个玄学bug。</p>
<p>其中一段代码如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">224</span>; x++) &#123;<span class="comment">// 遍历所有文件</span></span><br><span class="line">	<span class="keyword">if</span> (sys::finfo[x].name[<span class="number">0</span>] == <span class="number">0x00</span>) &#123;<span class="comment">// 后面没有任何文件了</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断文件名称是否符合</span></span><br><span class="line">	<span class="keyword">if</span> ((sys::finfo[x].type &amp; <span class="number">0x18</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">11</span>; ++y) &#123;<span class="comment">// 遍历文件名中的char</span></span><br><span class="line">			<span class="keyword">if</span> (sys::finfo[x].name[y] != file_name[y]) &#123;<span class="comment">// 和参数中的文件名比较</span></span><br><span class="line">				LOGD(<span class="string">"%d nq %d at %d"</span>, (<span class="keyword">int</span>)sys::finfo[x].name[y], (<span class="keyword">int</span>)file_name[y], y);</span><br><span class="line">				LOGD(<span class="string">"f0:%se"</span>,sys::finfo[x].name);</span><br><span class="line">				LOGD(<span class="string">"f1:%se"</span>,file_name);</span><br><span class="line"></span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一下运行结果<br><img src="/images/blog/os/10.png" alt="10.png"><br>注意到log里倒数第三行，<code>32 nq 0 at 13</code>，<br>首先说明一下，这里比较的是文件名的11个字符（文件名8byte+扩展名3byte，处理时跳过了小数点）。<br>它看起来比较时匹配到了MakeFile这个文件，但是在文件名索引为13(即y=13)的地方发生不匹配。</p>
<p>what happened？ y怎么可能等于13？？？？？</p>
<p>上面for循环判断不是写着<code>y &lt; 11</code>吗，程序疯了吧。<br>看一下<code>FILEINFO</code>结构体的定义<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FILEINFO</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> name[<span class="number">8</span>], ext[<span class="number">3</span>], type;</span><br><span class="line">	<span class="keyword">char</span> reserve[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> time, date, clustno;<span class="comment">// clustno 表示起始扇区</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看起来作者是用了一个结构体的特性，<code>name</code>（文件名）和<code>ext</code>（后缀）的内存是连续放置的，所以作者打算一次性比较11个字符来匹配文件名和后缀。<br>但是为什么这里y能跑到13呢？难道是内存不够了篡改了y的值？但是输出那里没法解释啊，输出的y是13，总不会是输出函数有问题吧。</p>
<p>为了探寻真相，来看看汇编<br><img src="/images/blog/os/11.png" alt="11.png"><br>由于有字符串，这段代码并不难找到，上方是循环体，<code>loc_494</code>是for循环的判断，看起来<code>eax</code>就是那个<code>y</code>变量，奇怪的是，在<code>loc_494</code>那里让<code>y</code>加一然后就<code>jmp</code>走继续执行循环体了，没看到和循环边界<code>11</code>比较的<code>cmp</code>部分，吃惊。<br>开始猜测是傻逼编译器又给我优化了，把for循环里<code>y</code>的上界改成<code>8</code>编译试试看。<br><img src="/images/blog/os/12.png" alt="12.png"><br>只见原来的<code>jmp</code>变成了<code>jnz</code>，跳转指令之前出现了一条<code>cmp</code>指令，傻逼编译器石锤了！</p>
<p>解决办法，把<code>sys::finfo[x].name</code>赋值给一个临时变量，这样傻逼编译器就看不到它的长度，也就不会优化了，骗过了编译器<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* aim_name = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)sys::finfo[x].name;</span><br></pre></td></tr></table></figure></p>
<p>不过这个傻逼编译器为什么要把我这个给优化掉呢？？</p>
<h4 id="hlt-hrb"><a href="#hlt-hrb" class="headerlink" title="hlt.hrb"></a>hlt.hrb</h4><p><code>hlt.hrb</code>里面本质上是编译好的机器指令，<br>那么<code>bootpack.hrb</code>应该也是机器指令，那么<code>OBJ2BIM</code>应该就是链接器，<code>haribote.sys</code>就是<code>asmhead.bin</code>和<code>bootpack.hrb</code>这两个机器指令文件组合起来的，所以也是编译好的机器指令。</p>
<h2 id="DAY-0x14"><a href="#DAY-0x14" class="headerlink" title="DAY 0x14"></a>DAY 0x14</h2><p>最后作者传入字符串地址最后什么都没有输出，先看了一下后一天的内容，发现作者又是通过在别处内存处存储临时的值来实现的，感觉这样很别扭，于是想能否获取到要打印的字符串的地址然后把地址传过去，作者说遇到的问题是分段的问题，尝试了一番，发现可以把<code>CS</code>段寄存器的值先存到别的寄存器，然后在<code>hrb_api</code>里面恢复出来传到<code>cons_putstr</code>里面，再在<code>naskfunc</code>里面写一个依据段寄存器和偏移地址取数据的函数，让<code>cons_putstr</code>去调用取字符。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cons_putstr</span><span class="params">(Console *console, <span class="keyword">int</span> ds, <span class="keyword">int</span> ecx)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span> (ch = get_data(ds, ecx)) &#123;</span><br><span class="line">		console-&gt;putfont8(ch);</span><br><span class="line">		ecx++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_get_data:		; int get_data(int ds, int ecx);</span><br><span class="line">		MOV		ECX,[ESP+8]</span><br><span class="line">		MOV		EAX,[ESP+4]</span><br><span class="line">		MOV		EDX,DS</span><br><span class="line">		MOV		DS,EAX</span><br><span class="line">		MOV		EAX,0</span><br><span class="line">		MOV		AL,[DS:ECX]</span><br><span class="line">		MOV		DS,EDX</span><br><span class="line">		RET</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>自制玩具操作系统--week8</title>
    <url>/blog/60/</url>
    <content><![CDATA[<h2 id="DAY-0x17"><a href="#DAY-0x17" class="headerlink" title="DAY 0x17"></a>DAY 0x17</h2><h4 id="关于链接器obj2bim"><a href="#关于链接器obj2bim" class="headerlink" title="关于链接器obj2bim"></a>关于链接器obj2bim</h4><p>翻看源码发现，obj2bim其实就是个链接器，依据一个.rul规则文件来生成链接后的二进制文件。</p>
<h5 id="输入文件"><a href="#输入文件" class="headerlink" title="输入文件"></a>输入文件</h5><p>它接受的输入文件有obj和lib这两种文件，其中lib文件也有两种，一种是标准的pe文件，有一种是作者自定义的格式，在链接前会decode成标准的lib文件，然后从lib文件解压出obj文件来进行处理，所以这个链接器主要进行的是对obj文件的处理。<br>例如haribote / golibc.lib就是作者自定义的一种格式的文件，它原本是一个标准的win下的lib文件，编写工具将其转换出来后发现里头并没有什么有意思的东西，只是几个字符串相关的处理函数的实现。</p>
<h5 id="处理obj"><a href="#处理obj" class="headerlink" title="处理obj"></a>处理obj</h5><p>处理过程在<code>loadobj</code>函数中，主要是用一个全局的数组存储所有的obj文件对象。</p>
<ul>
<li>数据拷贝<br>对于每个obj，将各个段依次解析，拷贝其中的数据到一片开辟的空间中。</li>
<li>重定位表处理<br>对于每个段，都开辟了一块空间存储重定位表的表项数组，然后解析每个段指向的<code>relocation table</code>重定位表，obj文件中重定位表的结构如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RELOCATION</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		DWORD  VirtualAddress;</span><br><span class="line">		DWORD  RelocCount;</span><br><span class="line">	&#125; M;</span><br><span class="line">	DWORD  SymbolTableIndex;</span><br><span class="line">	WORD Type;</span><br><span class="line">&#125; IMAGE_RELOCATION;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中<code>VirtualAddress</code>指向的是需要被重定位的位置相对于当前段的偏移量。<br>每个重定位表项有一个指向符号表的索引号，这部分操作总的来说就是把重定位表里面的项解析成程序中的结构，最后把重定位表的第一个元素的指针以及重定位表项的数目记录到obj中的对应的段中</p>
<ul>
<li>符号表<br>处理完段以后，处理符号表，排除一些符号比如调试用的符号，然后加载到之前的符号数组里，同时把bss段进行对齐。<br>符号表中包含两种组成，一种是定义在外部的符号，一种是定义在本obj文件的符号。<br>obj2bim这个链接器进程维护了一个包含所有符号的数组（相当于一个巨大的符号表），对于符号表中的每一项，先到该符号数组中去查找，如果找不到就添加一个新的符号。<br>每个符号项在程序中还带有一个指针，指向定义它的obj结构体实例，从而最终能区分一个符号是否被定义。<br>obj文件中符号表项的结构如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SYMBOL</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		BYTE    ShortName[<span class="number">8</span>];</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			DWORD   Short;     <span class="comment">// if 0, use LongName</span></span><br><span class="line">			DWORD   Long;      <span class="comment">// offset into string table</span></span><br><span class="line">		&#125; Name;</span><br><span class="line">		DWORD   LongName[<span class="number">2</span>];  <span class="comment">//two byte potioner</span></span><br><span class="line">	&#125; N;</span><br><span class="line">	DWORD   Value;</span><br><span class="line">	SHORT   SectionNumber;</span><br><span class="line">	WORD    Type;</span><br><span class="line">	BYTE    StorageClass;</span><br><span class="line">	BYTE    NumberOfAuxSymbols;</span><br><span class="line">&#125; IMAGE_SYMBOL;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="开始链接"><a href="#开始链接" class="headerlink" title="开始链接"></a>开始链接</h5><ul>
<li><p>处理指定的label<br>加载完所有的obj以后，读取rul文件中的<code>label</code>字段，然后读取rul文件中指定的符号，如果找不到就会报错。<br>之后遍历所有的符号，对用到的符号进行标记。</p>
</li>
<li><p><strong>预链接</strong><br>预处理完以后，三次调用<code>link0()</code>函数依次收集所有obj的代码段、所有obj的数据段、所有obj的bss段，组成三个大段。<br>收集过程中，将数据填充到<code>filebuf</code>中，根据rul文件中规定的每个大段的起始逻辑地址算出obj中每个段的的逻辑地址，以便后面符号的确定时使用，最后计算出这三个大段的逻辑地址的结束位置</p>
</li>
<li><p><strong>符号值的确定</strong><br>重定位主要是因为编译时单个obj不能确定代码所在的地址，要到链接时把所有obj放到一起才能确定符号的位置，而符号代表的就是地址，所以，我们要把符号的值进行修改。<br>具体操作是：<strong>每个符号原先的偏移量（符号表示的值）加上上一步计算出的它所在的obj文件的对应段的逻辑地址，变成该符号（表示的值）的逻辑地址</strong></p>
</li>
<li><p>输出map文件（可选）<br>然后开始输出.map文件，输出三种段的大小以及处理过的全局的符号表（符号的逻辑地址和符号的字符串表示，吐槽一下作者由于不会写按地址进行排序函数，用了一种很慢的办法来排序）</p>
</li>
<li><p><strong>link</strong><br>这样搞了一通以后下面就是真的link过程了，之前已经把符号的值重新计算过了，现在就是要<strong>把符号的值应用到要重定位的地方</strong>。<br>其实代码中每个需要重定位的语句都会在重定位表里面生成一项。<br>这个link过程其实就是对重定位表项的处理，由于上面的上面一步中已经处理出了符号（表示的值）的逻辑地址了，那这里<strong>只需要在每个重定位表项里面把<code>VirtualAddress</code>处的值改成对应的符号（表示的值）就行了</strong>（注意这里不一定是直接写入符号的值（逻辑地址），因为有的指令比如call指令可能接受的不是绝对地址，而是相对于pc值的地址）。</p>
</li>
</ul>
<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>最后输出作者规定的一种格式的文件，将代码段和数据段的信息（大小，文件中的位置，逻辑地址）写到文件起始位置。<br>接下来是是写入了rul文件中指定的那个label符号表示的值（在文件中偏移量为24的位置）。例如rul中<code>label</code>项写的是<code>_HariStartup</code>，那么就是把<code>_HariStartup</code>符号的入口地址写到这了。<br>然后是在指定的位置写入了代码段和数据段的内容，至此链接过程完成。</p>
<h5 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h5><ul>
<li>重定位的时候究竟改了什么？<br>代码中有一个让我很疑惑的地方，就是在”link”步骤的时候，往<code>VirtualAddress</code>写东西（4字节）时，作者刻意用了小端模式的写法，而之前各个地方赋值的时候，都没有刻意用小端，为了探查究竟，用工具来解析一下这所谓的重定位表，<br>这是<code>bootpack.obj</code>中<code>HariMain</code>函数的一部分汇编。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000047a &lt;_HariMain&gt;:</span><br><span class="line"> ...</span><br><span class="line"> 480:   81 ec dc 00 00 00       sub    $0xdc,%esp</span><br><span class="line"> 486:   e8 00 00 00 00          call   48b &lt;_HariMain+0x11&gt;	; 这里</span><br><span class="line"> 48b:   e8 00 00 00 00          call   490 &lt;_HariMain+0x16&gt;</span><br><span class="line"> 490:   e8 00 00 00 00          call   495 &lt;_HariMain+0x1b&gt;</span><br><span class="line"> 495:   e8 00 00 00 00          call   49a &lt;_HariMain+0x20&gt;</span><br><span class="line"> 49a:   c7 44 24 04 f8 00 00    movl   $0xf8,0x4(%esp)</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意<code>0x486</code>那里第一个<code>call</code>汇编应该是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call    __Z7init_dtv    ; init_dt(void)`</span><br></pre></td></tr></table></figure></p>
<p><code>init_dt(void)</code>应该是<code>dsctbl.obj</code>中的导出函数，</p>
<p>再看解析出来的重定位表的一部分<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                               Symbol    Symbol</span><br><span class="line">Offset    Type              Applied To         Index     Name</span><br><span class="line">--------  ----------------  -----------------  --------  ------</span><br><span class="line">...</span><br><span class="line">00000487  REL32                      00000000        35  __Z7init_dtv</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>表中<code>__Z7init_dtv</code>这个符号的<code>Offset</code>是<code>00000487</code>，这是什么意思呢？<br>注意看上面汇编中，<code>0x486</code>的那条<code>call</code>指令，长度为5个字节，后面从<code>0x487</code>开始的四个字节都是十六进制的<code>00</code>，我们可以大胆的猜测，这应该是留空给链接器填入链接后的地址的。</p>
<blockquote>
<p>事实上查阅i386汇编手册就可以知道，这是<code>call</code>指令的一种五字节长的版本，在<code>0xE8</code>后面接四字节的相对地址构成一条<code>call</code>指令，这对链接器来说就很方便了，不知道对于其它架构的机器码链接器是怎么做链接的。</p>
</blockquote>
<p>也就是说，最后我们把<code>__Z7init_dtv</code>的地址填到这里就能<code>call</code>了吧？其实不是这样的啦，<code>call</code>需要的是相对地址，所以链接器得先根据重定位表中该项的<code>type</code>进行个判断，<strong>把符号的值减去（当前指令的地址+4）的值</strong>写入到这个<code>call</code>语句中，所以说，链接时的重定位是要修改<code>.text</code>段的。</p>
<p>同理，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov     dword ptr ds:__ZN3sys8memtotalE, eax ; sys::memtotal</span><br></pre></td></tr></table></figure></p>
<p>对应的是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4e4:   a3 00 00 00 00          mov    %eax,0x0</span><br></pre></td></tr></table></figure></p>
<p>这里指令中也有四字节的空间是留出来让链接器时重定位<code>__ZN3sys8memtotalE</code>这个外部引用用的</p>
<ul>
<li>关于.bss段<br>全局变量存到.bss段里头，而这个段比较特殊，只在段的header里面存储它的大小，在运行加载时才为其初始化空间，但是显然裸机是不会帮我们分配<code>.bss</code>段的，而且这个操作系统我们还没有写加载器，那<code>.bss</code>段只能由这个静态链接器来展开了，验证一番发现在<code>link0</code>里面对<code>.bss</code>段腾出了空间的逻辑。</li>
</ul>
<h4 id="关于bim2hrb"><a href="#关于bim2hrb" class="headerlink" title="关于bim2hrb"></a>关于bim2hrb</h4><p>bim2hrb对比obj2bim就简单的多了，只是把bim的前面若干个字节进行了一些变动，加上了堆的空间的指定，然后调整了一下开头处存储的地址和大小什么的数据，还在前面加上了作者自己的魔术字<code>Hari</code>。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li>Intel call指令<br><a href="https://www.cnblogs.com/scu-cjx/p/6879041.html" target="_blank" rel="noopener">https://www.cnblogs.com/scu-cjx/p/6879041.html</a></li>
<li>PE格式第七讲,重定位表<br><a href="https://www.cnblogs.com/iBinary/p/7690069.html" target="_blank" rel="noopener">https://www.cnblogs.com/iBinary/p/7690069.html</a></li>
<li>[原创]010edit模版(obj文件分析)<br><a href="https://bbs.pediy.com/thread-222934.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-222934.htm</a></li>
</ul>
<h4 id="异常中断"><a href="#异常中断" class="headerlink" title="异常中断"></a>异常中断</h4><p>x86中，从0x00到0x1f都是异常所使用的中断，IRQ的中断号都是从0x20之后开始的。<br>0x00 除零异常（当试图除以0时产生）<br>0x0c 栈异常<br>0x0d 非法内存访问<br>0x06 非法指令异常（当试图执行CPU无法理解的机器语言指令， 例如当试图执行一段数据时，有可能会产生）</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>自制玩具操作系统--week5</title>
    <url>/blog/56/</url>
    <content><![CDATA[<h2 id="DAY-0x0C"><a href="#DAY-0x0C" class="headerlink" title="DAY 0x0C"></a>DAY 0x0C</h2><h4 id="PIT-Programmable-Interval-Timer-可编程的间隔型定时器"><a href="#PIT-Programmable-Interval-Timer-可编程的间隔型定时器" class="headerlink" title="PIT (Programmable Interval Timer 可编程的间隔型定时器)"></a>PIT (Programmable Interval Timer 可编程的间隔型定时器)</h4><p>查阅资料知道AT兼容机中PIT时钟频率为<code>1.19318MHz</code><br>中断周期设定的值的单位是一个时钟周期，因此要达到频率为<code>100Hz</code>的中断，中断周期应该设定为<code>1.19318*1000000/100=11931.8≈11932</code><br>在qemu上跑的时候,count是按照预想的速度增加的,而在bochs上面时,count的速度明显的降低,猜测是bochs的时钟的问题,google了一番发现很多用bochs的也遇到了类似的问题,但是好像并没有找到解决方案</p>
<h2 id="DAY-0x0D"><a href="#DAY-0x0D" class="headerlink" title="DAY 0x0D"></a>DAY 0x0D</h2><h4 id="timerctl"><a href="#timerctl" class="headerlink" title="timerctl"></a>timerctl</h4><p>这里由于pit设置了100Hz的定时器,所以理想的情况下能够以0.01ms的整数倍的时间间隔来进行中断,作者在实现完成以后进行了先后三次优化,但是对于最后一次优化,我感觉作者在超时后将定时器指针数组整体移位的优化还不如不优化,所以我只实现了using变量,以确定一个循环检索的上界</p>
<h4 id="fifo重用优化"><a href="#fifo重用优化" class="headerlink" title="fifo重用优化"></a>fifo重用优化</h4><p>这一段我没有使用作者的优化方式，因为将fifo重用会增加程序的复杂性，对于排错也不友好，另外，将数据按大小分层的话，如果后面增加了设备或者数据种类一多，又要去更改分层方式。</p>
<h2 id="DAY-0x0E"><a href="#DAY-0x0E" class="headerlink" title="DAY 0x0E"></a>DAY 0x0E</h2><p>到这里遇到了一个小插曲，程序能够在qemu模拟器上运行，但是到了bochs，由于定时器的速度太快，而bochs比qemu忙，每轮循环中都有定时器事件发生，导致鼠标和键盘中断被定时器所抢先，键盘和鼠标的相应被“饿死”了，在这种情况下更换循环中if条件判断的先后顺序解决了问题</p>
<h4 id="提高分辨率"><a href="#提高分辨率" class="headerlink" title="提高分辨率"></a>提高分辨率</h4><p>做到这一步的时候被作者坑到了，作者给的nas文件里面把<code>[INSTRSET &quot;i486p&quot;]</code>提前到了第一行但是却没有在书中说明，导致nask一直编译不通过，害我还以为哪里写错了。</p>
<p>使用VBE时，显卡能利用的VBE信息写入到以ES:DI开始的512字节中。<br>视频缓冲区位置也变成了由VBE信息指定的区域（不再是VGA的0x0x000a0000）</p>
<h4 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h4><p>做到这里的时候倒是发现了以前写下的好几个bug，本着自己写自己修的原则只好修复之。</p>
<p>由于我之前将光标封装成了Cursor类，所以字符操作什么的用<code>Cursor::next()</code>和<code>Cursor::backspace()</code>还是很爽的。遗憾的是我封装的时候还是直接对varm区域进行操作，没有绑定到画板<code>Canvas</code>（也就是作者的SHEET）上面这样的话对于窗口边界的判断就很麻烦了，后面考虑改成和<code>Canvas</code>组合在一起。</p>
<h4 id="改善log的性能"><a href="#改善log的性能" class="headerlink" title="改善log的性能"></a>改善log的性能</h4><p>为了改善log的性能，原先是每次来一条日志信息，当场就把数据给写到log拥有的那块画板上面，这样的话，如果一个主循环周期内产生了多条log，那么除了最后一次刷新操作，之前的操作全部都是浪费的，因此，给Canvas里面增加了一个函数指针callback字段，在每一轮主循环周期判别进行屏幕刷新前，首先调用所有canvas的callback函数，这样虽然会带来循环时的浪费，但是相比于多次log时的多次刷新来说，还是划得来的。<br>后面还可以考虑只对新增的log进行绘制，而对于旧的log绘制时只拷贝对应区域的图像数据</p>
<h4 id="debug屏幕刷新"><a href="#debug屏幕刷新" class="headerlink" title="debug屏幕刷新"></a>debug屏幕刷新</h4><p>由于我刷新机制和作者的不太一样，是按分块刷新屏幕的，有时候也容易出bug，为了检验效果同时也使其更加直观，所以我用宏来做了一个显示屏幕刷新区域的debug功能，将每次刷新时进行的的分块用红色线条圈起来，如图所示<br><img src="/images/blog/os/5.png" alt="分块区域"></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li>关于PIT<br><a href="http://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?(PIT)8254" target="_blank" rel="noopener">http://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?(PIT)8254</a></li>
<li>关于输入键盘映射<br><a href="http://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?（AT）keyboard" target="_blank" rel="noopener">http://webcache.googleusercontent.com/search?q=cache:http://oswiki.osask.jp/?（AT）keyboard</a> </li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派集群——无盘启动树莓派</title>
    <url>/blog/64/</url>
    <content><![CDATA[<p>最近从同学那里拿到了几个闲置的树莓派，外加一个路由器和一块2T的硬盘，于是乎想用这些派来搭建一个简单的集群。但是发现SD卡实在是不够，遂尝试使用nfs的方式来启动树莓派。</p>
<p>实验中用到的东西主要有：</p>
<ul>
<li>树莓派3B v1.2</li>
<li>刷有openwrt固件的路由器（竞斗云2.0）</li>
<li>挂载在路由器上的移动硬盘（U盘应该也可以，不过要足够大）</li>
<li>一张烧录了Raspberry Pi OS的SD卡（只在配置过程中会用到一次）</li>
<li>一条网线（连接派和路由器）</li>
<li>测试过程用的：HDMI转VGA线、USB键盘、USB鼠标</li>
</ul>
<p><img src="../images/blog/64/image-20201004200939893.png" alt="树莓派3B"></p>
<h2 id="树莓派开启USB-network启动"><a href="#树莓派开启USB-network启动" class="headerlink" title="树莓派开启USB/network启动"></a>树莓派开启USB/network启动</h2><p>为了让树莓派支持从nfs启动，我们需要给树莓派的OTP写入一个标志位。我们需要先准备一张烧录了Raspberry Pi OS的SD卡，插入树莓派启动。</p>
<p>首先进行系统更新，让树莓派更新到最新的bootloader</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt full-upgrade</span><br></pre></td></tr></table></figure>
<p>增加启动选项，在下一次启动时，树莓派会根据该选项修改OTP（OTP的写入是一次性的，不可以改回去，但是在树莓派的启动顺序中，USB启动是排在SD卡之后的，因此并不会对实际使用造成影响）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> program_usb_boot_mode=1 | sudo tee -a /boot/config.txt</span><br></pre></td></tr></table></figure>
<p>在重启之前，我们读取OTP，这是没有开启过网络启动的树莓派的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ vcgencmd otp_dump | grep 17:</span><br><span class="line">17:1020000a</span><br></pre></td></tr></table></figure>
<p>重启之后，会发现OTP相应位应该已经被修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ vcgencmd otp_dump | grep 17:</span><br><span class="line">17:3020000a</span><br></pre></td></tr></table></figure>
<p>此时可以修改<code>/boot/config.txt</code>去掉<code>program_usb_boot_mode=1</code>选项</p>
<h2 id="配置文件系统"><a href="#配置文件系统" class="headerlink" title="配置文件系统"></a>配置文件系统</h2><p>在启动前，我们需要为树莓派准备系统文件。由于我们不需要运行桌面程序，而仅仅将树莓派作为服务器，所以我们选择了<a href="https://dietpi.com/" target="_blank" rel="noopener">DietPi</a>的系统镜像来部署，其实Raspberry Pi OS镜像的部署方式也大同小异。</p>
<p>下载后解压得到以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DietPi_RPi-ARMv6-Buster/</span><br><span class="line">├── DietPi_RPi-ARMv6-Buster.img</span><br><span class="line">├── hash.txt</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>
<p>我们需要先将img文件通过loop设备挂载到本机上，具体的方法可以在网上找到，挂载后可以看到这个img文件里包含两个分区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME      MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0       7:0    0  1015M  1 loop </span><br><span class="line">├─loop0p1 259:0    0   256M  1 part /run/media/imlk/boot</span><br><span class="line">└─loop0p2 259:1    0 754.9M  1 part /run/media/imlk/rootfs</span><br></pre></td></tr></table></figure>
<p>分区名称分别是<code>boot</code>分区和<code>rootfs</code>分区。boot分区存放的主要是启动阶段需要的<code>bootcode.bin</code>以及系统内核文件，该分区在Linux启动后一般会被挂载到<code>/boot</code>目录下。<code>rootfs</code>分区就更好理解了，就是被挂载到<code>/</code>的根文件系统。</p>
<h4 id="准备系统文件"><a href="#准备系统文件" class="headerlink" title="准备系统文件"></a>准备系统文件</h4><p>我们准备了一块2T的移动硬盘，在上面划分了512G的ext4格式分区用来存储树莓派的根文件系统，在我们的演示中，我们将该分区挂载到了<code>/mnt/cluster/</code>。</p>
<p>为了便于管理，我们在该分区中创建一个名为<code>system</code>的目录，用来存放不同树莓派设备的文件，不同的树莓派设备的文件被放在它们的序列号所对应的子目录下（用序列号仅仅是为了区分设备而已，你也可以用别的名称）。例如我们当前的树莓派设备序列号是<code>000000008a4232c8</code>，则该设备的文件路径为<code>/mnt/cluster/system/000000008a4232c8</code>。</p>
<p>（序列号可以通过<code>cat /proc/cpuinfo</code>命令的<code>Serial</code>字段找到）</p>
<p>然后使用rsync命令将镜像的<code>rootfs</code>分区内容拷贝到子目录下的rootfs目录中（注意目录末尾的<code>/</code>不能忽略，否则语义不同）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo rsync -a /run/media/imlk/rootfs/ /mnt/cluster/system/000000008a4232c8/rootfs/</span><br></pre></td></tr></table></figure>
<p>接着，我们将<code>boot</code>分区的内容拷贝到rootfs目录下的boot子目录中（其实也可以放在一个单独的目录下，但是这样的话我们就还需要在<code>/etc/fstab</code>下配置一条<code>/boot</code>的nfs条目）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo rsync -a /run/media/imlk/boot/ /mnt/cluster/system/000000008a4232c8/rootfs/boot/</span><br></pre></td></tr></table></figure>
<p>为了方便，我们在rootfs的父目录下创建一个软链接，指向<code>rootfs/boot</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo ln -s rootfs/boot /mnt/cluster/system/000000008a4232c8/boot</span><br></pre></td></tr></table></figure>
<p>最终对应该设备的目录树如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@g-dock:~# tree -L 2 /mnt/cluster/system</span><br><span class="line">/mnt/cluster/system</span><br><span class="line">└── 000000008a4232c8</span><br><span class="line">    ├── boot -&gt; rootfs/boot		# 对应boot分区</span><br><span class="line">    └── rootfs					# 对应rootfs分区</span><br><span class="line"></span><br><span class="line">3 directories, 0 files</span><br></pre></td></tr></table></figure>
<p>上面的<code>boot</code>软链接对应了原始镜像中<code>boot</code>分区的内容，<code>rootfs</code>目录对应了原始镜像中<code>rootfs</code>分区的内容。</p>
<p>至此，一台树莓派设备的系统文件初始化完成。如果我们现在要新增一台树莓派，可以直接拷贝一份<code>000000008a4232c8</code>目录，命名为新树莓派的序列号。</p>
<h2 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h2><h4 id="在路由器上挂载移动硬盘"><a href="#在路由器上挂载移动硬盘" class="headerlink" title="在路由器上挂载移动硬盘"></a>在路由器上挂载移动硬盘</h4><p>我们使用一台竞斗云2.0作为路由设备，在它上面挂载移动硬盘。</p>
<p>测试速度如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@g-dock:/etc/opkg# hdparm -Tt /dev/sda4 </span><br><span class="line">/dev/sda4:</span><br><span class="line"> Timing cached reads:   714 MB in  2.00 seconds = 356.74 MB/sec</span><br><span class="line"> Timing buffered disk reads:  88 MB in  3.19 seconds =  27.63 MB/sec</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@g-dock:/etc/opkg# bonnie++ -n 0 -u 0  -f -b -d /mnt/data</span><br><span class="line">Using uid:0, gid:0.</span><br><span class="line">Writing intelligently...done</span><br><span class="line">Rewriting...done</span><br><span class="line">Reading intelligently...done</span><br><span class="line">start &apos;em...done...done...done...done...done...</span><br><span class="line">Version  1.98       ------Sequential Output------ --Sequential Input- --Random-</span><br><span class="line">                    -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--</span><br><span class="line">Name:Size etc        /sec %CP  /sec %CP  /sec %CP  /sec %CP  /sec %CP  /sec %CP</span><br><span class="line">OpenWrt          1G           32.1m  56 13.4m  28           27.0m  28  96.3  31</span><br><span class="line">Latency                       34156us     183ms               166ms     515ms</span><br><span class="line"></span><br><span class="line">1.98,1.98,OpenWrt,1,1601667412,1G,,8192,5,,,32834,56,13675,28,,,27680,28,96.3,31,,,,,,,,,,,,,,,,,,,34156us,183ms,,166ms,515ms,,,,,,</span><br></pre></td></tr></table></figure>
<p>（可选）开启硬盘禁止自动休眠（spin-down）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@g-dock:~# hdparm -S 0 /dev/sda</span><br><span class="line"></span><br><span class="line">/dev/sda:</span><br><span class="line"> setting standby to 0 (off)</span><br></pre></td></tr></table></figure>
<h4 id="配置PXE引导服务器"><a href="#配置PXE引导服务器" class="headerlink" title="配置PXE引导服务器"></a>配置PXE引导服务器</h4><p>我们使用<code>dnsmasq</code>内置的的PXE引导服务来为树莓派实现网络启动的第一步。<code>dnsmasq</code>是一个常用的提供DHCP服务和DNS服务的进程。首先我们需要修改它的配置文件，让它在网络启动过程作为PXE引导服务器，并通过tftp协议为树莓派提供boot分区中的<code>bootcode.bin</code>和内核文件。</p>
<p>修改<code>/etc/dnsmasq.conf</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log-facility=/var/log/daemon.log	# 指定日志文件输出路径</span><br><span class="line"># port=0 							# 设定port=0会禁用dns服务，不需要配置</span><br><span class="line">log-dhcp							# 在日志中显示dhcp请求信息</span><br><span class="line">enable-tftp							# （关键）启动tftp服务</span><br><span class="line">tftp-root=/mnt/cluster/tftpboot		# （关键）设定tftp服务的基础根目录</span><br><span class="line">tftp-unique-root=mac				# （关键）设定用mac地址区分不同设备的根目录</span><br><span class="line">pxe-service=0,&quot;Raspberry Pi Boot&quot;	# （关键）pxe服务相关配置</span><br></pre></td></tr></table></figure>
<p>配置完后重启<code>dnsmasq</code>。</p>
<p>该配置文件中，<code>log-facility</code>指定日志文件输出路径，<code>log-dhcp</code>表示在日志中显示dhcp请求信息，开启这两者方便我们排除错误。我们还设定了<code>/mnt/cluster/tftpboot</code>作为基础根目录，同时设定<code>tftp-unique-root=mac</code>来为区分为不同设备提供的文件，该选项会自动在基础根目录后追加mac地址，例如mac地址为<code>b8:27:eb:42:32:c8</code>的设备所看到的目录为<code>/mnt/cluster/tftpboot/b8-27-eb-42-32-c8/</code>。</p>
<p>接下来我们在挂载的硬盘分区中创建<code>tftpboot</code>目录，并根据树莓派网口的mac地址，创建一个指向该设备boot分区内容的软链接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo ln -s ../system/000000008a4232c8/boot/ /mnt/cluster/tftpboot/b8-27-eb-42-32-c8</span><br></pre></td></tr></table></figure>
<p>最终<code>tftpboot</code>目录的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@g-dock:~# tree /mnt/cluster/tftpboot/</span><br><span class="line">/mnt/cluster/tftpboot/</span><br><span class="line">└── b8-27-eb-42-32-c8 -&gt; ../system/000000008a4232c8/boot/</span><br><span class="line"></span><br><span class="line">1 directory, 0 files</span><br></pre></td></tr></table></figure>
<p>这样，树莓派启动时向<code>dnsmasq</code>查询文件，<code>dnsmasq</code>就会在<code>/mnt/cluster/tftpboot/b8-27-eb-42-32-c8/</code>中，即该设备的boot分区文件中查找。</p>
<p>至此，树莓派已经能够从路由器上加载内核文件并执行。</p>
<h4 id="配置nfs服务器"><a href="#配置nfs服务器" class="headerlink" title="配置nfs服务器"></a>配置nfs服务器</h4><p>经过上一步，内核虽然可以成功启动，但是是无法挂载rootfs的，接下来，我们需要用nfs来提供rootfs。</p>
<p>在路由器上安装nfs-server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install nfs-kernel-server</span><br></pre></td></tr></table></figure>
<p>配置<code>/etc/exports</code>文件，将我们之前在磁盘中准备的<code>system</code>目录暴露出去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@g-dock:/mnt/cluster# cat /etc/exports </span><br><span class="line">/mnt/cluster/system   192.168.1.0/255.255.255.0(rw,sync,no_subtree_check,no_root_squash)</span><br></pre></td></tr></table></figure>
<p>(注意括号中的选项不要写错，尤其是注意需要配置<code>no_root_squash</code>选项，否则nfs客户端无法以root用户身份执行操作)</p>
<p>启动nfs服务：（通常会使用portmap来搭配提供rpc，但是我们路由器上没有安装portmap，我们使用rpcbind替代）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@g-dock:~# service rpcbind start</span><br><span class="line">root@g-dock:~# service rpcbind enable</span><br><span class="line">root@g-dock:~# service nfsd start</span><br><span class="line">root@g-dock:~# service nfsd enable</span><br></pre></td></tr></table></figure>
<p>可以再自己的电脑上测试能否挂载nfs：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[imlk@imlk-pc cluster]$ sudo mount -t nfs 192.168.1.1:/mnt/cluster/system/000000008a4232c8/rootfs ./system/</span><br><span class="line">[imlk@imlk-pc cluster]$ tree -L 1 system/</span><br><span class="line">system/</span><br><span class="line">├── bin</span><br><span class="line">├── boot</span><br><span class="line">├── dev</span><br><span class="line">├── etc</span><br><span class="line">├── home</span><br><span class="line">├── lib</span><br><span class="line">├── lost+found</span><br><span class="line">├── media</span><br><span class="line">├── mnt</span><br><span class="line">├── opt</span><br><span class="line">├── proc</span><br><span class="line">├── root</span><br><span class="line">├── run</span><br><span class="line">├── sbin</span><br><span class="line">├── srv</span><br><span class="line">├── sys</span><br><span class="line">├── tmp</span><br><span class="line">├── usr</span><br><span class="line">└── var</span><br><span class="line"></span><br><span class="line">19 directories, 0 files</span><br></pre></td></tr></table></figure>
<p>可以看到上面我们成功将一台设备的rootfs通过nfs挂载到了我们的机器上（挂在失败的注意检查服务器<code>/etc/exports</code>中的配置，以及服务器的防火墙配置）</p>
<h4 id="最后一点点配置"><a href="#最后一点点配置" class="headerlink" title="最后一点点配置"></a>最后一点点配置</h4><p>下面的配置文件均指rootfs目录下的文件，而不是路由器自身的文件</p>
<h5 id="配置内核命令行-boot-cmdline-txt"><a href="#配置内核命令行-boot-cmdline-txt" class="headerlink" title="配置内核命令行/boot/cmdline.txt"></a>配置内核命令行<code>/boot/cmdline.txt</code></h5><p>我们需要配置内核命令行选项，让内核从nfs挂载rootfs。</p>
<p>首先在路由器上查看rootfs中的<code>/boot/cmdline.txt</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@g-dock:~# cat /mnt/cluster/system/000000008a4232c8/boot/cmdline.txt </span><br><span class="line">console=serial0,115200 console=tty1 root=PARTUUID=907af7d0-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait quiet net.ifnames=0</span><br></pre></td></tr></table></figure>
<p>删除<code>root=</code>和<code>rootfstype=</code>的内容，改成<code>root=/dev/nfs</code>和<code>nfsroot=192.168.1.1:/mnt/cluster/system/000000008a4232c8/rootfs,vers=3,proto=tcp</code>，后者是指定rootfs在nfs服务器上的路径。需要注意的是<code>vers=3</code>这个配置，在有些文献中配置 的是<code>vers=4.1</code>，但是实测dietpi的内核似乎不支持挂载4.1版本的nfs，改成<code>vers=3</code>后就成功了。</p>
<p>改完之后内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@g-dock:~# cat /mnt/cluster/system/000000008a4232c8/boot/cmdline.txt </span><br><span class="line">console=serial0,115200 console=tty1 root=/dev/nfs nfsroot=192.168.1.1:/mnt/cluster/system/000000008a4232c8/rootfs,vers=3,proto=tcp rw ip=dhcp rootwait elevator=deadline</span><br></pre></td></tr></table></figure>
<h5 id="配置自动挂载-etc-fstab"><a href="#配置自动挂载-etc-fstab" class="headerlink" title="配置自动挂载/etc/fstab"></a>配置自动挂载<code>/etc/fstab</code></h5><p>由于我们配置了内核启动时从nfs获取rootfs，<code>/etc/fstab</code>里不再需要挂载<code>/</code>。我们删除rootfs里<code>/etc/fstab</code>文件中关于<code>/</code>和<code>/boot</code>的挂载条目：要删除的条目类似于如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PARTUUID=907af7d0-02 / auto noatime,lazytime,rw 0 1</span><br><span class="line">PARTUUID=907af7d0-01 /boot auto noatime,lazytime,rw 0 2</span><br></pre></td></tr></table></figure>
<h5 id="配置网络接口初始化-etc-network-interfaces"><a href="#配置网络接口初始化-etc-network-interfaces" class="headerlink" title="配置网络接口初始化/etc/network/interfaces"></a>配置网络接口初始化<code>/etc/network/interfaces</code></h5><p>这部分和init进程初始化网络接口有关系，它会读取<code>/etc/network/interfaces</code>中的配置对网络接口进行初始化。由于我们在加载rootfs时已经初始化了eth0，这里我们不能再对eth0进行重新初始化，否则nfs会中断，导致init进程提示<code>a start job is running for the raise network</code>然后block住。</p>
<p>我们需要注释掉和eth0有关的条目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ethernet</span><br><span class="line">#allow-hotplug eth0</span><br><span class="line">#iface eth0 inet dhcp</span><br><span class="line">#address 192.168.0.100</span><br><span class="line">#netmask 255.255.255.0</span><br><span class="line">#gateway 192.168.0.1</span><br><span class="line">#dns-nameservers 9.9.9.9 149.112.112.112</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>拔掉树莓派的SD卡，用网线连接树莓派的网口和路由器，如果有HDMI和键盘也都可以接上，然后通电。等待10秒左右，树莓派会fallback到USB/Network方式启动。</p>
<p>查看dnsmasq的日志文件，第一阶段树莓派向dnsmasq请求<code>bootcode.bin</code>：</p>
<p><img src="../images/blog/64/image-20201004200646054.png" alt="image-20201004200646054"></p>
<p>第二阶段向dnsmasq请求内核和其它文件：</p>
<p><img src="../images/blog/64/image-20201004200744633.png" alt="image-20201004200744633"></p>
<p>接下来内核会初始化dhcp客户端，然后通过nfs挂载rootfs。</p>
<p>成功启动：</p>
<p><img src="../images/blog/64/IMG_20201004_201311.jpg" alt="IMG_20201004_201311"></p>
<h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><ul>
<li><p>内核启动后卡住，显示类似于下面的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP-Config: Complete:</span><br><span class="line">...</span><br><span class="line">random: crng init done</span><br></pre></td></tr></table></figure>
<p>原因：内核挂载rootfs失败，请检查<code>boot/cmdlime.txt</code>中填写的内容</p>
</li>
<li><p>启动或关机时卡卡住，屏幕上的systemd日志显示<code>[***] A start job is running for LSB: raise network interfaces</code></p>
<p><code>/etc/network/interfaces</code>配置问题，由于rootfs是通过nfs挂载的，因此系统启动后不应改变<code>eth0</code>接口的状态，否则已挂载的根文件系统会宕掉。</p>
</li>
</ul>
<h2 id="相关文献"><a href="#相关文献" class="headerlink" title="相关文献"></a>相关文献</h2><ul>
<li><p>树莓派的两种USB启动模式</p>
<p><a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/usb.md" target="_blank" rel="noopener">https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/usb.md</a></p>
</li>
<li><p>树莓派启动顺序</p>
<p><a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/bootflow.md" target="_blank" rel="noopener">https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/bootflow.md</a></p>
</li>
<li><p>树莓派配置网络启动教程(official)</p>
<p><a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/net_tutorial.md" target="_blank" rel="noopener">https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/net_tutorial.md</a></p>
</li>
<li><p>预启动执行环境（PXE）</p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>路由器</tag>
        <tag>NFS</tag>
      </tags>
  </entry>
  <entry>
    <title>自制玩具操作系统--week9</title>
    <url>/blog/61/</url>
    <content><![CDATA[<h2 id="DAY-0x18"><a href="#DAY-0x18" class="headerlink" title="DAY 0x18"></a>DAY 0x18</h2><h4 id="分页前的准备"><a href="#分页前的准备" class="headerlink" title="分页前的准备"></a>分页前的准备</h4><p>Linux并没有非常依赖于段表，而是采用的分页结构，将内核和用户程序的段设置为覆盖整个内存区域以此来绕过分段结构，但是显然这个30天操作系统的作者并不打算这样做，它把内核数据段设置为整个内存区域，但是却把代码段设置成0x00280000开始的空间。这对于之后加入类似于Linux的分页模式造成了不便，首先我们想办法把内核数据段改为覆盖整个内存区。</p>
<p>先看一下内存区域图：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-------------------------------------------------------|0x00280000</span><br><span class="line">|	512KB	0x00080000Byte								|</span><br><span class="line">|	bootpack.hrb内容被asmhead.nas整体加载到此区域执行		|0x002fffff</span><br><span class="line">|-------------------------------------------------------|0x00300000</span><br><span class="line">|	64KB	0x00010000Byte								|</span><br><span class="line">|	内核栈												|0x0030ffff</span><br><span class="line">|-------------------------------------------------------|0x00310000</span><br><span class="line">|	960KB	0x000f0000Byte								|</span><br><span class="line">|	bootpack.hrb中的数据区域								|</span><br><span class="line">|	0x003c0000存放了MEMMAN(大小大约0x8000Byte)				|0x003fffff</span><br><span class="line">|-------------------------------------------------------|0x00400000(4M)</span><br></pre></td></tr></table></figure></p>
<p>作者将bootpack.hrb放到了0x00280000处，然后通过farjmp指令<code>JMP DWORD 2*8:0x0000001b</code>（注意作者的第二个段的base是0x00280000），跳到bootpack.hrb的头部的一个写有jmp指令的跳板（一个根据相对pc的偏移量跳转的jmp指令）,然后继续跳入bootpack.hrb的代码段。</p>
<p>那么我们首先要解决逻辑地址的问题，原先bootpack.hrb逻辑地址是从0开始的，但是现在我们把第二个段的base从0x00280000改到0，相应的逻辑地址应该加上0x00280000，结合之前分析作者的obj2bim和bim2hrb的逻辑知道，在.rul文件中可以修改链接时代码段的逻辑基地址，我们这里在原来的基础上加上0x00280000，asmhead.nas中的临时段表和dsctbl.cpp根据段表的结构相应的改成覆盖全部内存区域<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set_segmdesc(gdt + ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)__KERNEL_DS &gt;&gt; <span class="number">3</span>), <span class="number">0xffffffff</span>, <span class="number">0x00000000</span>, AR_DATA32_RW);</span><br><span class="line">set_segmdesc(gdt + ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)__KERNEL_CS &gt;&gt; <span class="number">3</span>), <span class="number">0xffffffff</span>, <span class="number">0x00000000</span>, AR_CODE32_ER);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; limit 0xffffffff base:0x00000000 ar:0xc092 </span><br><span class="line">DW		0xffff,0x0000,0x9200,0x00cf</span><br><span class="line">; limit 0xffffffff base:0x00000000 ar:0x409a</span><br><span class="line">DW		0xffff,0x0000,0x9a00,0x00cf</span><br></pre></td></tr></table></figure>
<p>然后这里要将bootpack.hrb的头部的跳板jmp指令进行修改，在内存中先将jmp指令的偏移量减去0x00280000再set回去<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV		EBX,0x0028001c</span><br><span class="line">MOV		EAX,[EBX]</span><br><span class="line">SUB		EAX,0x00280000</span><br><span class="line">MOV		[EBX],EAX</span><br><span class="line">JMP		DWORD 2*8:0x0028001b</span><br></pre></td></tr></table></figure></p>
<p>效果如下，能够成功启动，但是执行用户程序hello的时候有一点问题，显然是因为我们动了.rul文件的原因，得把用户程序链接用的.rul文件和和内核程序的分开来<br><img src="/images/blog/os/17.png" alt=""></p>
<h4 id="内核代码二级分页"><a href="#内核代码二级分页" class="headerlink" title="内核代码二级分页"></a>内核代码二级分页</h4><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>这是网上找的Linux的线性地址到物理地址映射的图<br><img src="/images/blog/os/16.png" alt=""></p>
<p>我们这里准备在内核中先做两个映射</p>
<ul>
<li>这部分512MB空间直接通过偏移量的方式给内核程序用<br>0xc0000000-0xdfffffff -&gt; 0x000000000000-0x00001fffffff</li>
<li>这部分最高的512MB空间由于开启了VBE画面模式，图像缓冲存在这里，因此避免麻烦我们直接映射<br>0xe0000000-0xffffffff -&gt; 0x0000e0000000-0x0000ffffffff</li>
</ul>
<h5 id="调逻辑地址"><a href="#调逻辑地址" class="headerlink" title="调逻辑地址"></a>调逻辑地址</h5><p>首先，我们要再次调整逻辑地址，这次调整的是bootpack数据段（包括栈区域）和bootpack代码段的地址，在.rul文件中改成这样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code(align:1, logic:0xC0280024,      file:0x24);</span><br><span class="line">data(align:4, logic:0xC0310000, file:code_end);</span><br></pre></td></tr></table></figure></p>
<p>asmhead中加载bootpack的地址要做一些修改使它保持在原来的地方，之后我们分页开启后用高逻辑地址来进行访问这部分低物理地址空间<br>然后就是在jmp到bootpack之前，用汇编来填充我们的页目录和页表了</p>
<h5 id="写入页表"><a href="#写入页表" class="headerlink" title="写入页表"></a>写入页表</h5><p>页目录项的结构<br><img src="/images/blog/os/15.png" alt=""><br>页表项的结构<br><img src="/images/blog/os/18.png" alt=""><br>要注意的是，页目录项中存储的地址应该是页表的物理地址而不是页表的线性地址。</p>
<p>线性地址中10位对应页目录项索引，10位对应页表项索引，一个页目录项和一个页表项的大小都是4字节，所以一张页目录大小和一张页表大小都是<code>4*2^10B = 4KB</code>，也就是要占用掉0x1000大小的地址空间。<br>我们将<code>0x00400000</code>作为页目录起始位置，页目录之后放置页表<br>这些表一共耗费了<code>1GB/4KB*4+4KB=1MB+4KB</code>的空间，分配了高1G的线性地址，低位的地址在进入bootpack后再进行动态分配。</p>
<h5 id="启用页表"><a href="#启用页表" class="headerlink" title="启用页表"></a>启用页表</h5><p>让CR3存储页目录的物理地址，再在R0中设置pg标志位为1。由于x86默认是二级页表，如果想启用其他类型的页表需要先给CR4寄存器的某些位赋值。<br>开启页表后出现的一个问题是，由于CPU取指也依赖于段表和页表这两级的地址转换。<br>在执行<code>MOV CR0,EAX</code>后，我们的代码只能用线性地址来访问了，但是现在我们的EIP寄存器中的依然是物理地址（之所以是物理地址是因为我们已经绕过了段表），在我们的设计中，bootpack的线性地址和物理地址是不同的。</p>
<p>为解决这个问题，我们将计就计，在内存的高物理地址区（和bootpack的线性地址数值上相同的那里，写入<code>MOV CR0,EAX</code>这条开启分页的指令的机器码(仅3个字节)，然后从asmhead里面jmp到这个地方执行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(0) [0x0000c0280000] 0010:00000000c0280000 (unk. ctxt): mov cr0, eax              ; 0f22c0</span><br></pre></td></tr></table></figure></p>
<p>执行完这条指令后分页已经开启，EIP采用线性地址，经过页表的转换，实际上执行的代码落在了内存的低物理地址区域里，也就是我们加载的bootpack代码入口<code>0x00280003</code>处。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bochs:4&gt; n</span><br><span class="line">Next at t=34870451</span><br><span class="line">(0) [0x000000280003] 0010:00000000c0280003 (unk. ctxt): nop                       ; 90</span><br></pre></td></tr></table></figure></p>
<p>为了方便编写，加载bootpack后，把前头部前0x1b个字节全部改写成nop指令，这样在高地址开启分页后，下一条指令会落回在一堆nop指令组成的“滑板”上，一直滑到bootpack开头0x1b处的那个jmp指令那里，最终会成功舶入bootpack.cpp的HariMain函数。</p>
<p>通过在HariMain函数的开始加上一条bochsdbg()语句断点来进行验证<br><img src="/images/blog/os/19.png" alt=""></p>
<h5 id="修改c层代码"><a href="#修改c层代码" class="headerlink" title="修改c层代码"></a>修改c层代码</h5><p>进入bootpack只是开启分页之后的第一步，现在的c层代码是不能使用的，直接continue会立刻崩掉，原因有好几个：</p>
<ul>
<li>代码中硬编码了太多的低地址，像binfo什么的，还有作者随便拿来存储变量的一部分低地址，都要加上一个偏移量，可以用宏的方式来实现</li>
<li>memtest函数的范围问题</li>
<li>load_gdtr和load_idtr的地址问题（一开始以为得加载物理地址），后面总是莫名其妙页错误，然后发现开启分页以后去load的话应该load线性地址</li>
<li>代码不规范存在取用null指针的bug，我们还没有映射低地址区域所以会直接页错误PE</li>
<li>TASK结构体里面的cr3字段要处理</li>
</ul>
<p>注意几点：</p>
<ul>
<li>页错误的中断号是0x0e</li>
<li>改完bug前先不要允许任何中断，否则可能在发生中断时突然crash，导致在调试时会把正确的代码误以为是错误的</li>
<li>结合.map文件和静态分析工具分析错误位置</li>
</ul>
<p><img src="/images/blog/os/20.png" alt=""></p>
<p>用户态分页表需要为每一个task建立一个页目录，在task切换的时候赋值cr3，时间关系我们下周再做这个了。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>自制玩具操作系统--week10</title>
    <url>/blog/62/</url>
    <content><![CDATA[<h2 id="DAY-0x1B"><a href="#DAY-0x1B" class="headerlink" title="DAY 0x1B"></a>DAY 0x1B</h2><p>回顾<code>TSS</code>结构体，其中有一<code>CR3</code>字段，该字段在task切换的时候会自动赋值给<code>CR3</code>寄存器，我们可以在这里给用户程序设置额外的页目录地址（物理地址），</p>
<p>首先需要分配一张页表</p>
<p>按照内存中的结构来构造页目录结构体和页表结构体<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAGE_DE</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entrys[PAGE_DE_ENTRY_NUM];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">PAGE_DE* <span class="title">alloc_page_de</span><span class="params">(MEMMAN* memman)</span> </span>&#123;</span><br><span class="line">	PAGE_DE* p = (PAGE_DE*)memman_alloc_4k(memman, <span class="keyword">sizeof</span>(PAGE_DE));</span><br><span class="line">	utils::<span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(PAGE_DE));</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获得页表以后，可以分配一定的内存区域来存放用户程序数据，作者在运行用户程序时，采用新增一项段表的方法将逻辑地址映射到物理地址，但是我们这里依然绕过段表，直接用页表映射到物理地址。<br>所以，我们将从<code>0x00000000</code>开始的线性地址区域映射到我们刚刚分配的用户程序区域的物理地址：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map_page_addr2addr(sys::memman, pagede, <span class="number">0</span>, segsiz, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)q - LADDR_K_BASE, <span class="number">7</span>, <span class="number">7</span>); <span class="comment">// user access | write | present</span></span><br></pre></td></tr></table></figure></p>
<p>注意flag设置为“用户态可访问、可写、该页存在”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 映射地址到页目录，要求start_laddr和start_paddr低12位相同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_page_addr2addr</span><span class="params">(MEMMAN* memman, PAGE_DE* pagede, <span class="keyword">unsigned</span> <span class="keyword">int</span> start_laddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">unsigned</span> <span class="keyword">int</span> start_paddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> demode, <span class="keyword">unsigned</span> <span class="keyword">int</span> tamode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> end_laddr = start_laddr + size;</span><br><span class="line">	end_laddr = (end_laddr - <span class="number">1</span> + <span class="number">0x1000</span>) / <span class="number">0x1000</span>  * <span class="number">0x1000</span>;<span class="comment">// 4k向上对齐</span></span><br><span class="line">	start_laddr = start_laddr / <span class="number">0x1000</span> * <span class="number">0x1000</span>;<span class="comment">// 4k向下对齐</span></span><br><span class="line">	start_paddr = start_paddr / <span class="number">0x1000</span> * <span class="number">0x1000</span>;<span class="comment">// 4k向下对齐</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> start_entry = start_laddr &gt;&gt; <span class="number">22</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> end_entry = ((end_laddr - <span class="number">1</span> + <span class="number">0x400000</span>) / <span class="number">0x400000</span>  * <span class="number">0x400000</span>) &gt;&gt; <span class="number">22</span>;<span class="comment">// 4MB对齐</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sub_start_laddr = start_laddr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sub_end_laddr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sub_start_paddr = start_paddr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sub_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start_entry; i &lt; end_entry &amp;&amp; i &lt; PAGE_DE_ENTRY_NUM; ++i) &#123;</span><br><span class="line">		PAGE_TA* pta = (PAGE_TA*)((pagede-&gt;entrys[i]) &amp; <span class="number">0xFFFFF000</span>);</span><br><span class="line">		<span class="keyword">if</span> (pta == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			pta = alloc_page_ta(memman);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pta = (PAGE_TA*)(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)pta) + LADDR_K_BASE);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sub_end_laddr = utils::min(end_laddr, (i + <span class="number">1</span>) &lt;&lt; <span class="number">22</span>);</span><br><span class="line">		sub_size = utils::max(<span class="number">0</span>, sub_end_laddr - sub_start_laddr);</span><br><span class="line">		map_page_addr2addr(pta, sub_start_laddr, sub_size, sub_start_paddr, tamode);<span class="comment">// 填充pta指向的页表</span></span><br><span class="line">		sub_start_paddr += sub_size;</span><br><span class="line">		sub_start_laddr += sub_size;</span><br><span class="line">		set_page_ta2de(pagede, pta, i, demode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，分页结构要求页表映射的内存是按4k对齐的，即线性地址的一页映射物理内存一帧。而作者之前编写的<code>memman_alloc_4k</code>函数仅仅保证了内存区域大小4k对齐，因此我们要对该函数进行修改，让它分配的空间在初始地址和内存大小都按4k对齐。</p>
<p>除了用户程序的页表外，我们还需要把内核程序的页表加入到用户态页目录里面，这样的话，用户态程序调用内核中的api执行内核程序时，就不用更变CR3,直接从当前的task（带有我们准备的用户态页目录）里面映射到内核态的代码了</p>
<p>用户态task的分页：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cr3: 0x00000077e000</span><br><span class="line">0x00000000-0x00000fff -&gt; 0x000020000000-0x000020000fff  /* 低线性地址区域用户程序 */</span><br><span class="line">0xc0000000-0xdfffffff -&gt; 0x000000000000-0x00001fffffff  /* 高线性地址区域内核程序 */</span><br><span class="line">0xe0000000-0xffffffff -&gt; 0x0000e0000000-0x0000ffffffff  /* 高线性地址区域硬件区域 */</span><br></pre></td></tr></table></figure></p>
<p>编写函数执行这一拷贝过程<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_page_de2de</span><span class="params">(PAGE_DE* fromde, <span class="keyword">int</span> fromstart, PAGE_DE* tode, <span class="keyword">int</span> tostart, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count &amp;&amp; fromstart + i &lt; PAGE_DE_ENTRY_NUM &amp;&amp; tostart + i &lt; PAGE_DE_ENTRY_NUM; ++i) &#123;</span><br><span class="line">		tode-&gt;entrys[tostart + i] = fromde-&gt;entrys[fromstart + i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>增加两项用户态的gdt<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set_segmdesc(gdt + ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)__USER_CS &gt;&gt; <span class="number">3</span>), <span class="number">0xFFFFFFFF</span>, <span class="number">0</span>, AR_CODE32_ER + <span class="number">0x60</span>);</span><br><span class="line">set_segmdesc(gdt + ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)__USER_DS &gt;&gt; <span class="number">3</span>), <span class="number">0xFFFFFFFF</span>, <span class="number">0</span>, AR_DATA32_RW + <span class="number">0x60</span>);</span><br></pre></td></tr></table></figure></p>
<p>以用户态运行我们加载的程序<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">start_app(<span class="number">0x1b</span>, __USER_CS, esp, __USER_DS, &amp;(task-&gt;tss.esp0));<span class="comment">// 入口地址0x1b,那里是一个jmp跳板</span></span><br></pre></td></tr></table></figure></p>
<p>运行hello<br><img src="/images/blog/os/21.png" alt=""></p>
<p>可能会质疑如果将内核的页表放到用户态程序的页目录里面会不会导致从用户态直接访问内核数据，毕竟我们绕过了段表，段表的limit已经不能起保护作用了。<br>实际上是不用担心的，因为内核页表的flag中设定了User位为0，只允许内核态代码访问。</p>
<p>编写以下程序<code>touch_kernel.cpp</code>来测试：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HariMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* kp = (<span class="keyword">int</span>*)<span class="number">0xC0000000</span>;</span><br><span class="line">	(*kp) = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/blog/os/22.png" alt=""><br>bochs检测到了页错误PE<br><img src="/images/blog/os/23.png" alt=""></p>
<p>至此，不考虑虚拟内存的用户态分页实现完成</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>newifi 3 刷老毛子固件</title>
    <url>/blog/63/</url>
    <content><![CDATA[<p>新路由器到了两星期了，期间总是出现突然wan网络不通的情况，而且信号也没有上一台强（严重影响蹲坑时玩手机的体验）。参考网友们的建议，准备给newifi3刷老毛子固件玩。</p>
<h3 id="连接路由器"><a href="#连接路由器" class="headerlink" title="连接路由器"></a>连接路由器</h3><p>这里连接路由器有两种方法</p>
<ul>
<li><p>telnet</p>
<p>这玩意虽然默认没有开ssh端口，竟然默认开了telnet，把我给看傻了，直接telnet连上去就好了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[imlk@imlk-pc ~]$ telnet 192.168.99.1</span><br><span class="line">Trying 192.168.99.1...</span><br><span class="line">Connected to 192.168.99.1.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line"> ================================================================</span><br><span class="line"> |                   Welecome to PandoraBox !                   |</span><br><span class="line"> |                    Copyright 2013-2016                       |</span><br><span class="line"> |              D-Team Technology Co.,Ltd. ShenZhen             |</span><br><span class="line"> ================================================================ </span><br><span class="line">newifi_B4C7 login: root</span><br><span class="line">Password:</span><br></pre></td></tr></table></figure>
</li>
<li><p>ssh</p>
<p>上面说过，官方固件没开ssh，但是访问一下这个链接：</p>
<p><a href="http://192.168.99.1/newifi/ifiwen_hss.html" target="_blank" rel="noopener">http://192.168.99.1/newifi/ifiwen_hss.html</a></p>
<p>看到success后你会发现奇迹般地ssh也开放了。</p>
</li>
</ul>
<p>上了路由器先看看，mips架构，可能是基于PandoraBox的固件改的吧，登录文字里写的是PandoraBox。</p>
<p>比较有意思的是<code>/dev/root</code>挂载到<code>/rom</code>，<code>/dev/mtdblock5</code>挂载到<code>/overlay</code>，然后似乎是结合这俩整了个overlayfs直接给挂载到<code>/</code>。得了，又是没见过的操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">overlayfs:/overlay on / type overlayfs (rw,noatime,lowerdir=/,upperdir=/overlay)</span><br></pre></td></tr></table></figure>
<h3 id="breed"><a href="#breed" class="headerlink" title="breed"></a>breed</h3><p>这里下载的<a href="https://breed.hackpascal.net/是一个固件，需要解锁路由器才能刷入。breed的作者提供了一种加载内核模块`newifi-d2-jail-break.ko`刷入的方法，用这种方法似乎是“免解锁”的，具体作者的帖子在这：https://www.right.com.cn/forum/thread-342918-1-1.html" target="_blank" rel="noopener">https://breed.hackpascal.net/是一个固件，需要解锁路由器才能刷入。breed的作者提供了一种加载内核模块`newifi-d2-jail-break.ko`刷入的方法，用这种方法似乎是“免解锁”的，具体作者的帖子在这：https://www.right.com.cn/forum/thread-342918-1-1.html</a></p>
<p>解压后用scp上传到路由器的<code>/tmp/</code>目录加载内核模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insmod &apos;解压后的.ko文件&apos;</span><br></pre></td></tr></table></figure>
<p>之后会卡住一段时间重启，重启后还是官方固件。</p>
<p>接下来要进入恢复模式，断电后按住reset键插入电源启动，注意需要用数据线直连路由器。</p>
<p><img src="../images/blog/2020-03-12 23-13-30屏幕截图.png" alt="Breed web 恢复控制台"></p>
<h3 id="padavan"><a href="#padavan" class="headerlink" title="padavan"></a>padavan</h3><p>这里我选择的是hiboy制作的padavan固件</p>
<p>相关帖子：<a href="https://www.right.com.cn/forum/thread-2110335-1-1.html" target="_blank" rel="noopener">https://www.right.com.cn/forum/thread-2110335-1-1.html</a></p>
<p>下载地址：<a href="https://opt.cn2qq.com/padavan/" target="_blank" rel="noopener">https://opt.cn2qq.com/padavan/</a></p>
<p>固件更新界面选择固件，安装该固件即可，很简单。</p>
<p><img src="../images/blog/2020-03-12 23-20-23屏幕截图.png" alt=""></p>
<p>重启后进入192.168.123.1就是熟悉的界面了，默认账号密码是admin和admin。比较可惜的是它只认440M内存，而总内存应该是512M的。最后测试信号强度要明显比原来的好，一些没网络的角落也能有2.4G信号了。</p>
<p><img src="../images/blog/2020-03-13 12-57-28屏幕截图.png" alt="padavan界面"></p>
<p>后面广告拦截啥的就看个人喜好啦。</p>
]]></content>
      <categories>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>老毛子</tag>
        <tag>固件</tag>
      </tags>
  </entry>
</search>
